{ "module": 
  { "name": "Marshal",
    "file": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/marshal.mli",
    "location": 
      { "implementation": "unknown",
        "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/marshal.mli|0" },
    "info": 
      { "description": "Marshaling of data structures.<br></br> This module provides functions to encode arbitrary data structures as sequences of bytes, which can then be written on a file or sent over a pipe or network connection.  The bytes can then be read back later, possibly in another process, and decoded back into a data structure. The format for the byte sequences is compatible across all machines for a given version of Objective Caml.<br></br> Warning: marshaling is currently not type-safe. The type of marshaled data is not transmitted along the value of the data, making it impossible to check that the data read back possesses the type expected by the context. In particular, the result type of the <span class=\"code\" >Marshal.from_*</span> functions is given as <span class=\"code\" >'a</span>, but this is misleading: the returned Caml value does not possess type <span class=\"code\" >'a</span> for all <span class=\"code\" >'a</span>; it has one, unique type which cannot be determined at compile-type.  The programmer should explicitly give the expected type of the returned value, using the following syntax:<ul><li><span class=\"code\" >(Marshal.from_channel chan : type)</span>. Anything can happen at run-time if the object in the file does not belong to the given type.</li></ul> The representation of marshaled values is not human-readable, and uses bytes that are not printable characters. Therefore, input and output channels used in conjunction with <span class=\"code\" >Marshal.to_channel</span> and <span class=\"code\" >Marshal.from_channel</span> must be opened in binary mode, using e.g. <span class=\"code\" >open_out_bin</span> or <span class=\"code\" >open_in_bin</span>; channels opened in text mode will cause unmarshaling errors on platforms where text channels behave differently than binary channels, e.g. Windows." },
    "type": "sig  end",
    "module_structure": [ 
      { "type": 
          { "name": "Marshal.extern_flags",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/marshal.mli|2603" },
            "info": 
              { "description": "The flags to the <span class=\"code\" >Marshal.to_*</span> functions below." },
            "params": [  ],
            "kind": 
              { "type": "variant",
                "private": "false",
                "constructors": [ 
                  { "name": "No_sharing",
                    "description": "Don't preserve sharing",
                    "type": [  ] }, 
                  { "name": "Closures",
                    "description": "Send function closures",
                    "type": [  ] } ] } } }, 
      { "value": 
          { "name": "Marshal.to_string",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/marshal.mli|2815" },
            "info": 
              { "description": "<span class=\"code\" >Marshal.to_string v flags</span> returns a string containing the representation of <span class=\"code\" >v</span> as a sequence of bytes. The <span class=\"code\" >flags</span> argument has the same meaning as for <a href=\"{none|Marshal.to_channel}\" ><span class=\"code\" >Marshal.to_channel</span></a>." },
            "type": "'a -> Marshal.extern_flags list -> string",
            "params": [ 
              { "name": "",
                "type": "'a" }, 
              { "name": "",
                "type": "Marshal.extern_flags list" } ] } }, 
      { "value": 
          { "name": "Marshal.to_buffer",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/marshal.mli|3099" },
            "info": 
              { "description": "<span class=\"code\" >Marshal.to_buffer buff ofs len v flags</span> marshals the value <span class=\"code\" >v</span>, storing its byte representation in the string <span class=\"code\" >buff</span>, starting at character number <span class=\"code\" >ofs</span>, and writing at most <span class=\"code\" >len</span> characters.  It returns the number of characters actually written to the string. If the byte representation of <span class=\"code\" >v</span> does not fit in <span class=\"code\" >len</span> characters, the exception <span class=\"code\" >Failure</span> is raised." },
            "type": "string -> int -> int -> 'a -> Marshal.extern_flags list -> int",
            "params": [ 
              { "name": "",
                "type": "string" }, 
              { "name": "",
                "type": "int" }, 
              { "name": "",
                "type": "int" }, 
              { "name": "",
                "type": "'a" }, 
              { "name": "",
                "type": "Marshal.extern_flags list" } ] } }, 
      { "value": 
          { "name": "Marshal.from_string",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/marshal.mli|3561" },
            "info": 
              { "description": "<span class=\"code\" >Marshal.from_string buff ofs</span> unmarshals a structured value like <a href=\"{none|Marshal.from_channel}\" ><span class=\"code\" >Marshal.from_channel</span></a> does, except that the byte representation is not read from a channel, but taken from the string <span class=\"code\" >buff</span>, starting at position <span class=\"code\" >ofs</span>." },
            "type": "string -> int -> 'a",
            "params": [ 
              { "name": "",
                "type": "string" }, 
              { "name": "",
                "type": "int" } ] } }, 
      { "value": 
          { "name": "Marshal.header_size",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/marshal.mli|3838" },
            "info": 
              { "description": "The bytes representing a marshaled value are composed of a fixed-size header and a variable-sized data part, whose size can be determined from the header. <a href=\"{value|Marshal.header_size}\" ><span class=\"code\" >Marshal.header_size</span></a> is the size, in characters, of the header. <a href=\"{value|Marshal.data_size}\" ><span class=\"code\" >Marshal.data_size</span></a><span class=\"code\" > buff ofs</span> is the size, in characters, of the data part, assuming a valid header is stored in <span class=\"code\" >buff</span> starting at position <span class=\"code\" >ofs</span>. Finally, <a href=\"{value|Marshal.total_size}\" ><span class=\"code\" >Marshal.total_size</span></a><span class=\"code\" > buff ofs</span> is the total size, in characters, of the marshaled value. Both <a href=\"{value|Marshal.data_size}\" ><span class=\"code\" >Marshal.data_size</span></a> and <a href=\"{value|Marshal.total_size}\" ><span class=\"code\" >Marshal.total_size</span></a> raise <span class=\"code\" >Failure</span> if <span class=\"code\" >buff</span>, <span class=\"code\" >ofs</span> does not contain a valid header.<br></br> To read the byte representation of a marshaled value into a string buffer, the program needs to read first <a href=\"{value|Marshal.header_size}\" ><span class=\"code\" >Marshal.header_size</span></a> characters into the buffer, then determine the length of the remainder of the representation using <a href=\"{value|Marshal.data_size}\" ><span class=\"code\" >Marshal.data_size</span></a>, make sure the buffer is large enough to hold the remaining data, then read it, and finally call <a href=\"{value|Marshal.from_string}\" ><span class=\"code\" >Marshal.from_string</span></a> to unmarshal the value." },
            "type": "int",
            "params": [  ] } }, 
      { "value": 
          { "name": "Marshal.data_size",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/marshal.mli|4906" },
            "info": 
              { "description": "See <a href=\"{value|Marshal.header_size}\" ><span class=\"code\" >Marshal.header_size</span></a>." },
            "type": "string -> int -> int",
            "params": [ 
              { "name": "",
                "type": "string" }, 
              { "name": "",
                "type": "int" } ] } }, 
      { "value": 
          { "name": "Marshal.total_size",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/marshal.mli|4978" },
            "info": 
              { "description": "See <a href=\"{value|Marshal.header_size}\" ><span class=\"code\" >Marshal.header_size</span></a>." },
            "type": "string -> int -> int",
            "params": [ 
              { "name": "",
                "type": "string" }, 
              { "name": "",
                "type": "int" } ] } } ],
    "dependencies": 
      { "uses": [  ],
        "used_by": [  ] } } }