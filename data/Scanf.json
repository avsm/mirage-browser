{ "module": 
  { "name": "Scanf",
    "file": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/scanf.mli",
    "location": 
      { "implementation": "unknown",
        "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/scanf.mli|0" },
    "info": 
      { "description": "Formatted input functions." },
    "type": "sig  end",
    "module_structure": [ 
      { "comment": "<h6>Introduction</h6>" }, 
      { "comment": "<h7>Functional input with format strings</h7>" }, 
      { "comment": "The module <span class=\"code\" >Scanf</span> provides formatted input functions or <em>scanners</em>.<br></br> The formatted input functions can read from any kind of input, including strings, files, or anything that can return characters. The more general source of characters is named a <em>formatted input channel</em> (or <em>    scanning buffer</em>) and has type <a href=\"{type|Scanf.Scanning.in_channel}\" ><span class=\"code\" >Scanf.Scanning.in_channel</span></a>. The more general formatted input function reads from any scanning buffer and is named <span class=\"code\" >bscanf</span>.<br></br> Generally speaking, the formatted input functions have 3 arguments:<ul><li>the first argument is a source of characters for the input,</li><li>the second argument is a format string that specifies the values to read,</li><li>the third argument is a <em>receiver function</em> that is applied to the values read.</li></ul> Hence, a typical call to the formatted input function <a href=\"{value|Scanf.bscanf}\" ><span class=\"code\" >Scanf.bscanf</span></a> is <span class=\"code\" >bscanf ic fmt f</span>, where:<br></br><ul><li><span class=\"code\" >ic</span> is a source of characters (typically a <em>    formatted input channel</em> with type <a href=\"{type|Scanf.Scanning.in_channel}\" ><span class=\"code\" >Scanf.Scanning.in_channel</span></a>),</li></ul><ul><li><span class=\"code\" >fmt</span> is a format string (the same format strings as those used to print material with module <a href=\"{module|Printf}\" ><span class=\"code\" >Printf</span></a> or <a href=\"{module|Format}\" ><span class=\"code\" >Format</span></a>),</li></ul><ul><li><span class=\"code\" >f</span> is a function that has as many arguments as the number of values to read in the input.</li></ul>" }, 
      { "comment": "<h7>A simple example</h7>" }, 
      { "comment": "As suggested above, the expression <span class=\"code\" >bscanf ic \"%d\" f</span> reads a decimal integer <span class=\"code\" >n</span> from the source of characters <span class=\"code\" >ic</span> and returns <span class=\"code\" >f n</span>.<br></br> For instance,<br></br><ul><li>if we use <span class=\"code\" >stdin</span> as the source of characters (<a href=\"{value|Scanf.Scanning.stdin}\" ><span class=\"code\" >Scanf.Scanning.stdin</span></a> is the predefined formatted input channel that reads from standard input),</li></ul><ul><li>if we define the receiver <span class=\"code\" >f</span> as <span class=\"code\" >let f x = x + 1</span>,</li></ul> then <span class=\"code\" >bscanf Scanning.stdin \"%d\" f</span> reads an integer <span class=\"code\" >n</span> from the standard input and returns <span class=\"code\" >f n</span> (that is <span class=\"code\" >n + 1</span>). Thus, if we evaluate <span class=\"code\" >bscanf stdin \"%d\" f</span>, and then enter <span class=\"code\" >41</span> at the keyboard, we get <span class=\"code\" >42</span> as the final result." }, 
      { "comment": "<h7>Formatted input as a functional feature</h7>" }, 
      { "comment": "The Caml scanning facility is reminiscent of the corresponding C feature. However, it is also largely different, simpler, and yet more powerful: the formatted input functions are higher-order functionals and the parameter passing mechanism is just the regular function application not the variable assignment based mechanism which is typical for formatted input in imperative languages; the Caml format strings also feature useful additions to easily define complex tokens; as expected within a functional programming language, the formatted input functions also support polymorphism, in particular arbitrary interaction with polymorphic user-defined scanners.  Furthermore, the Caml formatted input facility is fully type-checked at compile time." }, 
      { "module": 
          { "name": "Scanf.Scanning",
            "file": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/scanf.mli",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/scanf.mli|3836" },
            "info": 
              { "description": "<h6>Formatted input channel</h6>" },
            "type": "sig  end",
            "module_structure": [ 
              { "type": 
                  { "name": "Scanf.Scanning.in_channel",
                    "location": 
                      { "implementation": "unknown",
                        "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/scanf.mli|3864" },
                    "info": "",
                    "params": [  ],
                    "kind": 
                      { "type": "abstract" } } }, 
              { "type": 
                  { "name": "Scanf.Scanning.scanbuf",
                    "location": 
                      { "implementation": "unknown",
                        "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/scanf.mli|4251" },
                    "info": 
                      { "description": "The type of scanning buffers. A scanning buffer is the source from which a formatted input function gets characters. The scanning buffer holds the current state of the scan, plus a function to get the next char from the input, and a token buffer to store the string matched so far.<br></br> Note: a scanning action may often require to examine one character in advance; when this ``lookahead'' character does not belong to the token read, it is stored back in the scanning buffer and becomes the next character read." },
                    "params": [  ],
                    "kind": 
                      { "type": "abstract" },
                    "manifest": "Scanf.Scanning.in_channel" } }, 
              { "value": 
                  { "name": "Scanf.Scanning.stdin",
                    "location": 
                      { "implementation": "unknown",
                        "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/scanf.mli|4819" },
                    "info": 
                      { "description": "The standard input notion for the module <span class=\"code\" >Scanf</span>. <span class=\"code\" >stdin</span> is equivalent to <span class=\"code\" >Scanning.from_channel Pervasives.stdin</span>.<br></br> Note: when input is read interactively from <span class=\"code\" >stdin</span>, the newline character that triggers the evaluation is incorporated in the input; thus, scanning specifications must properly skip this character (simply add a <span class=\"code\" >'\\n'</span> as the last character of the format string).",
                        "since": "3.12.0" },
                    "type": "Scanf.Scanning.in_channel",
                    "params": [  ] } }, 
              { "value": 
                  { "name": "Scanf.Scanning.open_in",
                    "location": 
                      { "implementation": "unknown",
                        "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/scanf.mli|5272" },
                    "info": 
                      { "description": "Bufferized file reading in text mode. The efficient and usual way to scan text mode files (in effect, <span class=\"code\" >from_file</span> returns a scanning buffer that reads characters in large chunks, rather than one character at a time as buffers returned by <span class=\"code\" >from_channel</span> below do). <span class=\"code\" >Scanning.from_file fname</span> returns a scanning buffer which reads from the given file <span class=\"code\" >fname</span> in text mode.",
                        "since": "3.12.0" },
                    "type": "string -> Scanf.Scanning.in_channel",
                    "params": [ 
                      { "name": "",
                        "type": "string" } ] } }, 
              { "value": 
                  { "name": "Scanf.Scanning.open_in_bin",
                    "location": 
                      { "implementation": "unknown",
                        "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/scanf.mli|5726" },
                    "info": 
                      { "description": "Bufferized file reading in binary mode.",
                        "since": "3.12.0" },
                    "type": "string -> Scanf.Scanning.in_channel",
                    "params": [ 
                      { "name": "",
                        "type": "string" } ] } }, 
              { "value": 
                  { "name": "Scanf.Scanning.close_in",
                    "location": 
                      { "implementation": "unknown",
                        "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/scanf.mli|5829" },
                    "info": 
                      { "description": "Close the <span class=\"code\" >Pervasives.input_channel</span> associated with the given <span class=\"code\" >Scanning.in_channel</span>.",
                        "since": "3.12.0" },
                    "type": "Scanf.Scanning.in_channel -> unit",
                    "params": [ 
                      { "name": "",
                        "type": "Scanf.Scanning.in_channel" } ] } }, 
              { "value": 
                  { "name": "Scanf.Scanning.from_file",
                    "location": 
                      { "implementation": "unknown",
                        "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/scanf.mli|5977" },
                    "info": 
                      { "description": "An alias for <span class=\"code\" >open_in</span> above." },
                    "type": "string -> Scanf.Scanning.in_channel",
                    "params": [ 
                      { "name": "",
                        "type": "string" } ] } }, 
              { "value": 
                  { "name": "Scanf.Scanning.from_file_bin",
                    "location": 
                      { "implementation": "unknown",
                        "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/scanf.mli|6053" },
                    "info": 
                      { "description": "An alias for <span class=\"code\" >open_in_bin</span> above." },
                    "type": "string -> Scanf.Scanning.in_channel",
                    "params": [ 
                      { "name": "",
                        "type": "string" } ] } }, 
              { "value": 
                  { "name": "Scanf.Scanning.from_string",
                    "location": 
                      { "implementation": "unknown",
                        "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/scanf.mli|6138" },
                    "info": 
                      { "description": "<span class=\"code\" >Scanning.from_string s</span> returns a formatted input channel which reads from the given string. Reading starts from the first character in the string. The end-of-input condition is set when the end of the string is reached." },
                    "type": "string -> Scanf.Scanning.in_channel",
                    "params": [ 
                      { "name": "",
                        "type": "string" } ] } }, 
              { "value": 
                  { "name": "Scanf.Scanning.from_function",
                    "location": 
                      { "implementation": "unknown",
                        "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/scanf.mli|6421" },
                    "info": 
                      { "description": "<span class=\"code\" >Scanning.from_function f</span> returns a scanning buffer with the given function as its reading method.<br></br> When scanning needs one more character, the given function is called.<br></br> When the function has no more character to provide, it <em>must</em> signal an end-of-input condition by raising the exception <span class=\"code\" >End_of_file</span>." },
                    "type": "(unit -> char) -> Scanf.Scanning.in_channel",
                    "params": [ 
                      { "name": "",
                        "type": "unit -> char" } ] } }, 
              { "value": 
                  { "name": "Scanf.Scanning.from_channel",
                    "location": 
                      { "implementation": "unknown",
                        "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/scanf.mli|6805" },
                    "info": 
                      { "description": "<span class=\"code\" >Scanning.from_channel ic</span> returns a formatted input channel which reads from the regular input channel <span class=\"code\" >ic</span> argument, starting at the current reading position." },
                    "type": "Pervasives.in_channel -> Scanf.Scanning.in_channel",
                    "params": [ 
                      { "name": "",
                        "type": "Pervasives.in_channel" } ] } }, 
              { "value": 
                  { "name": "Scanf.Scanning.end_of_input",
                    "location": 
                      { "implementation": "unknown",
                        "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/scanf.mli|7039" },
                    "info": 
                      { "description": "<span class=\"code\" >Scanning.end_of_input ic</span> tests the end-of-input condition of the given formatted input channel." },
                    "type": "Scanf.Scanning.in_channel -> bool",
                    "params": [ 
                      { "name": "",
                        "type": "Scanf.Scanning.in_channel" } ] } }, 
              { "value": 
                  { "name": "Scanf.Scanning.beginning_of_input",
                    "location": 
                      { "implementation": "unknown",
                        "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/scanf.mli|7189" },
                    "info": 
                      { "description": "<span class=\"code\" >Scanning.beginning_of_input ic</span> tests the beginning of input condition of the given formatted input channel." },
                    "type": "Scanf.Scanning.in_channel -> bool",
                    "params": [ 
                      { "name": "",
                        "type": "Scanf.Scanning.in_channel" } ] } }, 
              { "value": 
                  { "name": "Scanf.Scanning.name_of_input",
                    "location": 
                      { "implementation": "unknown",
                        "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/scanf.mli|7357" },
                    "info": 
                      { "description": "<span class=\"code\" >Scanning.file_name_of_input ic</span> returns the name of the character source for the formatted input channel <span class=\"code\" >ic</span>.",
                        "since": "3.09.0" },
                    "type": "Scanf.Scanning.in_channel -> string",
                    "params": [ 
                      { "name": "",
                        "type": "Scanf.Scanning.in_channel" } ] } }, 
              { "value": 
                  { "name": "Scanf.Scanning.stdib",
                    "location": 
                      { "implementation": "unknown",
                        "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/scanf.mli|7542" },
                    "info": 
                      { "description": "A deprecated alias for <span class=\"code\" >Scanning.stdin</span>, the scanning buffer reading from <span class=\"code\" >Pervasives.stdin</span>." },
                    "type": "Scanf.Scanning.in_channel",
                    "params": [  ] } } ],
            "dependencies": 
              { "uses": [  ] } } }, 
      { "comment": "<h6>Type of formatted input functions</h6>" }, 
      { "type": 
          { "name": "Scanf.scanner",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/scanf.mli|7731" },
            "info": 
              { "description": "The type of formatted input scanners: <span class=\"code\" >('a, 'b, 'c, 'd) scanner</span> is the type of a formatted input function that reads from some formatted input channel according to some format string; more precisely, if <span class=\"code\" >scan</span> is some formatted input function, then <span class=\"code\" >scan ic fmt f</span> applies <span class=\"code\" >f</span> to the arguments specified by the format string <span class=\"code\" >fmt</span>, when <span class=\"code\" >scan</span> has read those arguments from the formatted input channel <span class=\"code\" >ic</span>.<br></br> For instance, the <span class=\"code\" >scanf</span> function below has type <span class=\"code\" >('a, 'b, 'c, 'd) scanner</span>, since it is a formatted input function that reads from <span class=\"code\" >Scanning.stdin</span>: <span class=\"code\" >scanf fmt f</span> applies <span class=\"code\" >f</span> to the arguments specified by <span class=\"code\" >fmt</span>, reading those arguments from <span class=\"code\" >Pervasives.stdin</span> as expected.<br></br> If the format <span class=\"code\" >fmt</span> has some <span class=\"code\" >%r</span> indications, the corresponding input functions must be provided before the receiver <span class=\"code\" >f</span> argument. For instance, if <span class=\"code\" >read_elem</span> is an input function for values of type <span class=\"code\" >t</span>, then <span class=\"code\" >bscanf ic \"%r;\" read_elem f</span> reads a value <span class=\"code\" >v</span> of type <span class=\"code\" >t</span> followed by a <span class=\"code\" >';'</span> character, and returns <span class=\"code\" >f v</span>.",
                "since": "3.10.0" },
            "params": [ 
              { "covariant": "true",
                "contravariant": "true",
                "type": "'a" }, 
              { "covariant": "true",
                "contravariant": "true",
                "type": "'b" }, 
              { "covariant": "true",
                "contravariant": "true",
                "type": "'c" }, 
              { "covariant": "true",
                "contravariant": "true",
                "type": "'d" } ],
            "kind": 
              { "type": "abstract" },
            "manifest": "('a, Scanf.Scanning.in_channel, 'b, 'c, 'a -> 'd, 'd) format6 -> 'c" } }, 
      { "exception": 
          { "name": "Scanf.Scan_failure",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/scanf.mli|8916" },
            "info": 
              { "description": "The exception that formatted input functions raise when the input cannot be read according to the given format." },
            "exception_args": [ "string" ] } }, 
      { "comment": "<h6>The general formatted input function</h6>" }, 
      { "value": 
          { "name": "Scanf.bscanf",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/scanf.mli|9124" },
            "info": 
              { "description": "<span class=\"code\" >bscanf ic fmt r1 ... rN f</span> reads arguments for the function <span class=\"code\" >f</span>, from the formatted input channel <span class=\"code\" >ic</span>, according to the format string <span class=\"code\" >fmt</span>, and applies <span class=\"code\" >f</span> to these values. The result of this call to <span class=\"code\" >f</span> is returned as the result of the entire <span class=\"code\" >bscanf</span> call. For instance, if <span class=\"code\" >f</span> is the function <span class=\"code\" >fun s i -&gt; i + 1</span>, then <span class=\"code\" >Scanf.sscanf \"x=  1\" \"%s = %i\" f</span> returns <span class=\"code\" >2</span>.<br></br> Arguments <span class=\"code\" >r1</span> to <span class=\"code\" >rN</span> are user-defined input functions that read the argument corresponding to a <span class=\"code\" >%r</span> conversion." },
            "type": "Scanf.Scanning.in_channel -> ('a, 'b, 'c, 'd) Scanf.scanner",
            "params": [ 
              { "name": "",
                "type": "Scanf.Scanning.in_channel" } ] } }, 
      { "comment": "<h6>Format string description</h6>" }, 
      { "comment": "The format is a character string which contains three types of objects:<ul><li>plain characters, which are simply matched with the characters of the input (with a special case for <a href=\"{section|Scanf.space}\" ><span class=\"code\" >Scanf.space</span></a> and line feed),</li><li>conversion specifications, each of which causes reading and conversion of one argument for the function <span class=\"code\" >f</span> (see <a href=\"{section|Scanf.conversion}\" ><span class=\"code\" >Scanf.conversion</span></a>),</li><li>scanning indications to specify boundaries of tokens (see scanning <a href=\"{section|Scanf.indication}\" ><span class=\"code\" >Scanf.indication</span></a>).</li></ul>" }, 
      { "comment": "<h7>The space character in format strings</h7>" }, 
      { "comment": "As mentioned above, a plain character in the format string is just matched with the next character of the input; however, two characters are special exceptions to this rule: the space character (<span class=\"code\" >' '</span> or ASCII code 32) and the line feed character (<span class=\"code\" >'\\n'</span> or ASCII code 10). A space does not match a single space character, but any amount of ``whitespace'' in the input. More precisely, a space inside the format string matches <em>any number</em> of tab, space, line feed and carriage return characters. Similarly, a line feed character in the format string matches either a single line feed or a carriage return followed by a line feed.<br></br> Matching <em>any</em> amount of whitespace, a space in the format string also matches no amount of whitespace at all; hence, the call <span class=\"code\" >bscanf ib \"Price = %d $\" (fun p -&gt; p)</span> succeeds and returns <span class=\"code\" >1</span> when reading an input with various whitespace in it, such as <span class=\"code\" >Price = 1 $</span>, <span class=\"code\" >Price  =  1    $</span>, or even <span class=\"code\" >Price=1$</span>." }, 
      { "comment": "<h7>Conversion specifications in format strings</h7>" }, 
      { "comment": "Conversion specifications consist in the <span class=\"code\" >%</span> character, followed by an optional flag, an optional field width, and followed by one or two conversion characters. The conversion characters and their meanings are:<br></br><ul><li><span class=\"code\" >d</span>: reads an optionally signed decimal integer.</li><li><span class=\"code\" >i</span>: reads an optionally signed integer (usual input conventions for decimal (<span class=\"code\" >0-9</span>+), hexadecimal (<span class=\"code\" >0x[0-9a-f]+</span> and <span class=\"code\" >0X[0-9A-F]+</span>), octal (<span class=\"code\" >0o[0-7]+</span>), and binary (<span class=\"code\" >0b[0-1]+</span>) notations are understood).</li><li><span class=\"code\" >u</span>: reads an unsigned decimal integer.</li><li><span class=\"code\" >x</span> or <span class=\"code\" >X</span>: reads an unsigned hexadecimal integer (<span class=\"code\" >[0-9a-f]+</span> or <span class=\"code\" >[0-9A-F]+</span>).</li><li><span class=\"code\" >o</span>: reads an unsigned octal integer (<span class=\"code\" >[0-7]+</span>).</li><li><span class=\"code\" >s</span>: reads a string argument that spreads as much as possible, until the following bounding condition holds:</li><li>a whitespace has been found (see <a href=\"{section|Scanf.space}\" ><span class=\"code\" >Scanf.space</span></a>),</li><li>a scanning indication (see scanning <a href=\"{section|Scanf.indication}\" ><span class=\"code\" >Scanf.indication</span></a>) has been encountered,</li><li>the end-of-input has been reached. Hence, this conversion always succeeds: it returns an empty string, if the bounding condition holds when the scan begins.</li><li><span class=\"code\" >S</span>: reads a delimited string argument (delimiters and special escaped characters follow the lexical conventions of Caml).</li><li><span class=\"code\" >c</span>: reads a single character. To test the current input character without reading it, specify a null field width, i.e. use specification <span class=\"code\" >%0c</span>. Raise <span class=\"code\" >Invalid_argument</span>, if the field width specification is greater than 1.</li><li><span class=\"code\" >C</span>: reads a single delimited character (delimiters and special escaped characters follow the lexical conventions of Caml).</li><li><span class=\"code\" >f</span>, <span class=\"code\" >e</span>, <span class=\"code\" >E</span>, <span class=\"code\" >g</span>, <span class=\"code\" >G</span>: reads an optionally signed floating-point number in decimal notation, in the style <span class=\"code\" >dddd.ddd e/E+-dd</span>.</li><li><span class=\"code\" >F</span>: reads a floating point number according to the lexical conventions of Caml (hence the decimal point is mandatory if the exponent part is not mentioned).</li><li><span class=\"code\" >B</span>: reads a boolean argument (<span class=\"code\" >true</span> or <span class=\"code\" >false</span>).</li><li><span class=\"code\" >b</span>: reads a boolean argument (for backward compatibility; do not use in new programs).</li><li><span class=\"code\" >ld</span>, <span class=\"code\" >li</span>, <span class=\"code\" >lu</span>, <span class=\"code\" >lx</span>, <span class=\"code\" >lX</span>, <span class=\"code\" >lo</span>: reads an <span class=\"code\" >int32</span> argument to the format specified by the second letter for regular integers.</li><li><span class=\"code\" >nd</span>, <span class=\"code\" >ni</span>, <span class=\"code\" >nu</span>, <span class=\"code\" >nx</span>, <span class=\"code\" >nX</span>, <span class=\"code\" >no</span>: reads a <span class=\"code\" >nativeint</span> argument to the format specified by the second letter for regular integers.</li><li><span class=\"code\" >Ld</span>, <span class=\"code\" >Li</span>, <span class=\"code\" >Lu</span>, <span class=\"code\" >Lx</span>, <span class=\"code\" >LX</span>, <span class=\"code\" >Lo</span>: reads an <span class=\"code\" >int64</span> argument to the format specified by the second letter for regular integers.</li><li><span class=\"code\" >[ range ]</span>: reads characters that matches one of the characters mentioned in the range of characters <span class=\"code\" >range</span> (or not mentioned in it, if the range starts with <span class=\"code\" >^</span>). Reads a <span class=\"code\" >string</span> that can be empty, if the next input character does not match the range. The set of characters from <span class=\"code\" >c1</span> to <span class=\"code\" >c2</span> (inclusively) is denoted by <span class=\"code\" >c1-c2</span>. Hence, <span class=\"code\" >%[0-9]</span> returns a string representing a decimal number or an empty string if no decimal digit is found; similarly, <span class=\"code\" >%[\\\\048-\\\\057\\\\065-\\\\070]</span> returns a string of hexadecimal digits. If a closing bracket appears in a range, it must occur as the first character of the range (or just after the <span class=\"code\" >^</span> in case of range negation); hence <span class=\"code\" >[]]</span> matches a <span class=\"code\" >]</span> character and <span class=\"code\" >[^]]</span> matches any character that is not <span class=\"code\" >]</span>.</li><li><span class=\"code\" >r</span>: user-defined reader. Takes the next <span class=\"code\" >ri</span> formatted input function and applies it to the scanning buffer <span class=\"code\" >ib</span> to read the next argument. The input function <span class=\"code\" >ri</span> must therefore have type <span class=\"code\" >Scanning.in_channel -&gt; 'a</span> and the argument read has type <span class=\"code\" >'a</span>.</li><li><span class=\"code\" >{ fmt %}</span>: reads a format string argument. The format string read must have the same type as the format string specification <span class=\"code\" >fmt</span>. For instance, <span class=\"code\" >\"%{ %i %}\"</span> reads any format string that can read a value of type <span class=\"code\" >int</span>; hence <span class=\"code\" >Scanf.sscanf \"fmt:\\\"number is %u\\\"\" \"fmt:%{%i%}\"</span> succeeds and returns the format string <span class=\"code\" >\"number is %u\"</span>.</li><li><span class=\"code\" >\\( fmt %\\)</span>: scanning format substitution. Reads a format string to read with it instead of <span class=\"code\" >fmt</span>. The format string read must have the same type as the format string specification <span class=\"code\" >fmt</span> that is replaces. For instance, <span class=\"code\" >\"%( %i %)\"</span> reads any format string that can read a value of type <span class=\"code\" >int</span>. Returns the format string read, and the value read using the format string read. Hence, <span class=\"code\" >Scanf.sscanf \"\\\"%4d\\\"1234.00\" \"%(%i%)\" (fun fmt i -&gt; fmt, i)</span> evaluates to <span class=\"code\" >(\"%4d\", 1234)</span>. If the special flag <span class=\"code\" >_</span> is used, the conversion discards the format string read and only returns the value read with the format string read. Hence, <span class=\"code\" >Scanf.sscanf \"\\\"%4d\\\"1234.00\" \"%_(%i%)\"</span> is simply equivalent to <span class=\"code\" >Scanf.sscanf \"1234.00\" \"%4d\"</span>.</li><li><span class=\"code\" >l</span>: returns the number of lines read so far.</li><li><span class=\"code\" >n</span>: returns the number of characters read so far.</li><li><span class=\"code\" >N</span> or <span class=\"code\" >L</span>: returns the number of tokens read so far.</li><li><span class=\"code\" >!</span>: matches the end of input condition.</li><li><span class=\"code\" >%</span>: matches one <span class=\"code\" >%</span> character in the input.</li><li><span class=\"code\" >,</span>: the no-op delimiter for conversion specifications.</li></ul> Following the <span class=\"code\" >%</span> character that introduces a conversion, there may be the special flag <span class=\"code\" >_</span>: the conversion that follows occurs as usual, but the resulting value is discarded. For instance, if <span class=\"code\" >f</span> is the function <span class=\"code\" >fun i -&gt; i + 1</span>, then <span class=\"code\" >Scanf.sscanf \"x = 1\" \"%_s = %i\" f</span> returns <span class=\"code\" >2</span>.<br></br> The field width is composed of an optional integer literal indicating the maximal width of the token to read. For instance, <span class=\"code\" >%6d</span> reads an integer, having at most 6 decimal digits; <span class=\"code\" >%4f</span> reads a float with at most 4 characters; and <span class=\"code\" >%8[\\\\000-\\\\255]</span> returns the next 8 characters (or all the characters still available, if fewer than 8 characters are available in the input).<br></br> Notes:<br></br><ul><li>as mentioned above, a <span class=\"code\" >%s</span> conversion always succeeds, even if there is nothing to read in the input: in this case, it simply returns <span class=\"code\" >\"\"</span>.</li></ul><ul><li>in addition to the relevant digits, <span class=\"code\" >'_'</span> characters may appear inside numbers (this is reminiscent to the usual Caml lexical conventions). If stricter scanning is desired, use the range conversion facility instead of the number conversions.</li></ul><ul><li>the <span class=\"code\" >scanf</span> facility is not intended for heavy duty lexical analysis and parsing. If it appears not expressive enough for your needs, several alternative exists: regular expressions (module <span class=\"code\" >Str</span>), stream parsers, <span class=\"code\" >ocamllex</span>-generated lexers, <span class=\"code\" >ocamlyacc</span>-generated parsers.</li></ul>" }, 
      { "comment": "<h7>Scanning indications in format strings</h7>" }, 
      { "comment": "Scanning indications appear just after the string conversions <span class=\"code\" >%s</span> and <span class=\"code\" >%[ range ]</span> to delimit the end of the token. A scanning indication is introduced by a <span class=\"code\" >@</span> character, followed by some constant character <span class=\"code\" >c</span>. It means that the string token should end just before the next matching <span class=\"code\" >c</span> (which is skipped). If no <span class=\"code\" >c</span> character is encountered, the string token spreads as much as possible. For instance, <span class=\"code\" >\"%s@\\t\"</span> reads a string up to the next tab character or to the end of input. If a scanning indication <span class=\"code\" >@c</span> does not follow a string conversion, it is treated as a plain <span class=\"code\" >c</span> character.<br></br> Note:<br></br><ul><li>the scanning indications introduce slight differences in the syntax of <span class=\"code\" >Scanf</span> format strings, compared to those used for the <span class=\"code\" >Printf</span> module. However, the scanning indications are similar to those used in the <span class=\"code\" >Format</span> module; hence, when producing formatted text to be scanned by <span class=\"code\" >!Scanf.bscanf</span>, it is wise to use printing functions from the <span class=\"code\" >Format</span> module (or, if you need to use functions from <span class=\"code\" >Printf</span>, banish or carefully double check the format strings that contain <span class=\"code\" >'@'</span> characters).</li></ul>" }, 
      { "comment": "<h7>Exceptions during scanning</h7>" }, 
      { "comment": "Scanners may raise the following exceptions when the input cannot be read according to the format string:<br></br><ul><li>Raise <span class=\"code\" >Scanf.Scan_failure</span> if the input does not match the format.</li></ul><ul><li>Raise <span class=\"code\" >Failure</span> if a conversion to a number is not possible.</li></ul><ul><li>Raise <span class=\"code\" >End_of_file</span> if the end of input is encountered while some more characters are needed to read the current conversion specification.</li></ul><ul><li>Raise <span class=\"code\" >Invalid_argument</span> if the format string is invalid.</li></ul> Note:<br></br><ul><li>as a consequence, scanning a <span class=\"code\" >%s</span> conversion never raises exception <span class=\"code\" >End_of_file</span>: if the end of input is reached the conversion succeeds and simply returns the characters read so far, or <span class=\"code\" >\"\"</span> if none were ever read.</li></ul>" }, 
      { "comment": "<h6>Specialised formatted input functions</h6>" }, 
      { "value": 
          { "name": "Scanf.fscanf",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/scanf.mli|20060" },
            "info": 
              { "description": "Same as <a href=\"{value|Scanf.bscanf}\" ><span class=\"code\" >Scanf.bscanf</span></a>, but reads from the given regular input channel.<br></br> Warning: since all formatted input functions operate from a <em>formatted input channel</em>, be aware that each <span class=\"code\" >fscanf</span> invocation will operate with a formatted input channel reading from the given channel. This extra level of bufferization can lead to strange scanning behaviour if you use low level primitives on the channel (reading characters, seeking the reading position, and so on).<br></br> As a consequence, never mix direct low level reading and high level scanning from the same regular input channel." },
            "type": "Pervasives.in_channel -> ('a, 'b, 'c, 'd) Scanf.scanner",
            "params": [ 
              { "name": "",
                "type": "Pervasives.in_channel" } ] } }, 
      { "value": 
          { "name": "Scanf.sscanf",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/scanf.mli|20741" },
            "info": 
              { "description": "Same as <a href=\"{value|Scanf.bscanf}\" ><span class=\"code\" >Scanf.bscanf</span></a>, but reads from the given string." },
            "type": "string -> ('a, 'b, 'c, 'd) Scanf.scanner",
            "params": [ 
              { "name": "",
                "type": "string" } ] } }, 
      { "value": 
          { "name": "Scanf.scanf",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/scanf.mli|20857" },
            "info": 
              { "description": "Same as <a href=\"{value|Scanf.bscanf}\" ><span class=\"code\" >Scanf.bscanf</span></a>, but reads from the predefined formatted input channel <a href=\"{value|Scanf.Scanning.stdin}\" ><span class=\"code\" >Scanf.Scanning.stdin</span></a> that is connected to <span class=\"code\" >Pervasives.stdin</span>." },
            "type": "('a, 'b, 'c, 'd) Scanf.scanner",
            "params": [  ] } }, 
      { "value": 
          { "name": "Scanf.kscanf",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/scanf.mli|21052" },
            "info": 
              { "description": "Same as <a href=\"{value|Scanf.bscanf}\" ><span class=\"code\" >Scanf.bscanf</span></a>, but takes an additional function argument <span class=\"code\" >ef</span> that is called in case of error: if the scanning process or some conversion fails, the scanning function aborts and calls the error handling function <span class=\"code\" >ef</span> with the scanning buffer and the exception that aborted the scanning process as arguments." },
            "type": "Scanf.Scanning.in_channel ->\n  (Scanf.Scanning.in_channel -> exn -> 'a) -> ('b, 'c, 'd, 'a) Scanf.scanner",
            "params": [ 
              { "name": "",
                "type": "Scanf.Scanning.in_channel" }, 
              { "name": "",
                "type": "Scanf.Scanning.in_channel -> exn -> 'a" } ] } }, 
      { "comment": "<h6>Reading format strings from input</h6>" }, 
      { "value": 
          { "name": "Scanf.bscanf_format",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/scanf.mli|21547" },
            "info": 
              { "description": "<span class=\"code\" >bscanf_format ic fmt f</span> reads a format string token from the formatted input channel <span class=\"code\" >ic</span>, according to the given format string <span class=\"code\" >fmt</span>, and applies <span class=\"code\" >f</span> to the resulting format string value. Raise <span class=\"code\" >Scan_failure</span> if the format string value read does not have the same type as <span class=\"code\" >fmt</span>.",
                "since": "3.09.0" },
            "type": "Scanf.Scanning.in_channel ->\n  ('a, 'b, 'c, 'd, 'e, 'f) format6 ->\n  (('a, 'b, 'c, 'd, 'e, 'f) format6 -> 'g) -> 'g",
            "params": [ 
              { "name": "",
                "type": "Scanf.Scanning.in_channel" }, 
              { "name": "",
                "type": "('a, 'b, 'c, 'd, 'e, 'f) format6" }, 
              { "name": "",
                "type": "('a, 'b, 'c, 'd, 'e, 'f) format6 -> 'g" } ] } }, 
      { "value": 
          { "name": "Scanf.sscanf_format",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/scanf.mli|22004" },
            "info": 
              { "description": "Same as <a href=\"{value|Scanf.bscanf_format}\" ><span class=\"code\" >Scanf.bscanf_format</span></a>, but reads from the given string.",
                "since": "3.09.0" },
            "type": "string ->\n  ('a, 'b, 'c, 'd, 'e, 'f) format6 ->\n  (('a, 'b, 'c, 'd, 'e, 'f) format6 -> 'g) -> 'g",
            "params": [ 
              { "name": "",
                "type": "string" }, 
              { "name": "",
                "type": "('a, 'b, 'c, 'd, 'e, 'f) format6" }, 
              { "name": "",
                "type": "('a, 'b, 'c, 'd, 'e, 'f) format6 -> 'g" } ] } }, 
      { "value": 
          { "name": "Scanf.format_from_string",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/scanf.mli|22216" },
            "info": 
              { "description": "<span class=\"code\" >format_from_string s fmt</span> converts a string argument to a format string, according to the given format string <span class=\"code\" >fmt</span>. Raise <span class=\"code\" >Scan_failure</span> if <span class=\"code\" >s</span>, considered as a format string, does not have the same type as <span class=\"code\" >fmt</span>.",
                "since": "3.10.0" },
            "type": "string ->\n  ('a, 'b, 'c, 'd, 'e, 'f) format6 -> ('a, 'b, 'c, 'd, 'e, 'f) format6",
            "params": [ 
              { "name": "",
                "type": "string" }, 
              { "name": "",
                "type": "('a, 'b, 'c, 'd, 'e, 'f) format6" } ] } } ],
    "dependencies": 
      { "uses": [ "Pervasives" ],
        "used_by": [  ] } } }