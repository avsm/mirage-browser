{ "module": 
  { "name": "Lazy",
    "file": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/lazy.mli",
    "location": 
      { "implementation": "unknown",
        "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/lazy.mli|0" },
    "info": 
      { "description": "Deferred computations." },
    "type": "sig  end",
    "module_structure": [ 
      { "type": 
          { "name": "Lazy.t",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/lazy.mli|982" },
            "info": 
              { "description": "A value of type <span class=\"code\" >'a Lazy.t</span> is a deferred computation, called a suspension, that has a result of type <span class=\"code\" >'a</span>.  The special expression syntax <span class=\"code\" >lazy (expr)</span> makes a suspension of the computation of <span class=\"code\" >expr</span>, without computing <span class=\"code\" >expr</span> itself yet. \"Forcing\" the suspension will then compute <span class=\"code\" >expr</span> and return its result.<br></br> Note: <span class=\"code\" >lazy_t</span> is the built-in type constructor used by the compiler for the <span class=\"code\" >lazy</span> keyword.  You should not use it directly.  Always use <span class=\"code\" >Lazy.t</span> instead.<br></br> Note: <span class=\"code\" >Lazy.force</span> is not thread-safe.  If you use this module in a multi-threaded program, you will need to add some locks.<br></br> Note: if the program is compiled with the <span class=\"code\" >-rectypes</span> option, ill-founded recursive definitions of the form <span class=\"code\" >let rec x = lazy x</span> or <span class=\"code\" >let rec x = lazy(lazy(...(lazy x)))</span> are accepted by the type-checker and lead, when forced, to ill-formed values that trigger infinite loops in the garbage collector and other parts of the run-time system. Without the <span class=\"code\" >-rectypes</span> option, such ill-founded recursive definitions are rejected by the type-checker." },
            "params": [ 
              { "covariant": "true",
                "contravariant": "false",
                "type": "'a" } ],
            "kind": 
              { "type": "abstract" },
            "manifest": "'a lazy_t" } }, 
      { "exception": 
          { "name": "Lazy.Undefined",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/lazy.mli|2103" },
            "info": "" } }, 
      { "value": 
          { "name": "Lazy.force",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/lazy.mli|2126" },
            "info": "",
            "type": "'a Lazy.t -> 'a",
            "params": [ 
              { "name": "",
                "type": "'a Lazy.t" } ] } }, 
      { "comment": "<span class=\"code\" >force x</span> forces the suspension <span class=\"code\" >x</span> and returns its result. If <span class=\"code\" >x</span> has already been forced, <span class=\"code\" >Lazy.force x</span> returns the same value again without recomputing it.  If it raised an exception, the same exception is raised again. Raise <span class=\"code\" >Undefined</span> if the forcing of <span class=\"code\" >x</span> tries to force <span class=\"code\" >x</span> itself recursively." }, 
      { "value": 
          { "name": "Lazy.force_val",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/lazy.mli|2530" },
            "info": 
              { "description": "<span class=\"code\" >force_val x</span> forces the suspension <span class=\"code\" >x</span> and returns its result.  If <span class=\"code\" >x</span> has already been forced, <span class=\"code\" >force_val x</span> returns the same value again without recomputing it. Raise <span class=\"code\" >Undefined</span> if the forcing of <span class=\"code\" >x</span> tries to force <span class=\"code\" >x</span> itself recursively. If the computation of <span class=\"code\" >x</span> raises an exception, it is unspecified whether <span class=\"code\" >force_val x</span> raises the same exception or <span class=\"code\" >Undefined</span>." },
            "type": "'a Lazy.t -> 'a",
            "params": [ 
              { "name": "",
                "type": "'a Lazy.t" } ] } }, 
      { "value": 
          { "name": "Lazy.lazy_from_fun",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/lazy.mli|2963" },
            "info": 
              { "description": "<span class=\"code\" >lazy_from_fun f</span> is the same as <span class=\"code\" >lazy (f ())</span> but slightly more efficient." },
            "type": "(unit -> 'a) -> 'a Lazy.t",
            "params": [ 
              { "name": "",
                "type": "unit -> 'a" } ] } }, 
      { "value": 
          { "name": "Lazy.lazy_from_val",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/lazy.mli|3094" },
            "info": 
              { "description": "<span class=\"code\" >lazy_from_val v</span> returns an already-forced suspension of <span class=\"code\" >v</span> This is for special purposes only and should not be confused with <span class=\"code\" >lazy (v)</span>." },
            "type": "'a -> 'a Lazy.t",
            "params": [ 
              { "name": "",
                "type": "'a" } ] } }, 
      { "value": 
          { "name": "Lazy.lazy_is_val",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/lazy.mli|3283" },
            "info": 
              { "description": "<span class=\"code\" >lazy_is_val x</span> returns <span class=\"code\" >true</span> if <span class=\"code\" >x</span> has already been forced and did not raise an exception." },
            "type": "'a Lazy.t -> bool",
            "params": [ 
              { "name": "",
                "type": "'a Lazy.t" } ] } } ],
    "dependencies": 
      { "uses": [  ],
        "used_by": [  ] } } }