{"tree": ["Base64", "String", "Stack", "Sort", {"data": "Set", "children": ["Set.Make"]}, "Queue", "Printexc", {"data": "Pervasives", "children": ["Pervasives.LargeFile"]}, "Nativeint", "Marshal", {"data": "Map", "children": ["Map.Make"]}, "Lazy", "Stream", "List", "Lexing", "Int64", "Int32", {"data": "Hashtbl", "children": ["Hashtbl.Make"]}, "Gc", "Digest", "Complex", "Char", "CamlinternalLazy", "Callback", "Buffer", "Array", {"data": "Weak", "children": ["Weak.Make"]}, "Sys", {"data": "Scanf", "children": ["Scanf.Scanning"]}, {"data": "Random", "children": ["Random.State"]}, "Obj", "Format", "Printf", "Parsing", "CamlinternalOO", "CamlinternalMod", "Std_exit", "Log", "Oo", {"data": "Bitstring", "children": ["Bitstring.Buffer"]}, "Bitstring_types", "Bitstring_config", "Lwt", "Lwt_util", "Lwt_stream", "Lwt_sequence", "Lwt_mvar", "Lwt_mutex", "Lwt_list", "Lwt_pool", "Lwt_condition", {"data": "Lwt_pqueue", "children": ["Lwt_pqueue.Make"]}, "Lwt_switch", {"data": "Regexp", "children": ["Regexp.Re"]}, {"data": "OS", "children": ["OS.Blkif", "OS.Main", "OS.Netif", "OS.Console", "OS.Time", "OS.Clock", "OS.Activations"]}, {"data": "Net", "children": [{"data": "Net.Channel", "children": ["Net.Channel.Pipe", "Net.Channel.TCPv4"]}, {"data": "Net.Datagram", "children": ["Net.Datagram.UDPv4"]}, {"data": "Net.Flow", "children": ["Net.Flow.Pipe", "Net.Flow.TCPv4"]}, {"data": "Net.Manager", "children": ["Net.Manager.Unix"]}, "Net.Nettypes"]}, {"data": "Block", "children": ["Block.RO", {"data": "Block.Manager", "children": ["Block.Manager.Unix"]}]}, {"data": "Dns", "children": ["Dns.Server", "Dns.Dnsserver", "Dns.Dnsparser", "Dns.Dnsquery", "Dns.Dnspacket", "Dns.Dnsloader", "Dns.Dnstrie", "Dns.Dnsrr", {"data": "Dns.Hashcons", "children": ["Dns.Hashcons.Make"]}]}, {"data": "Http", "children": ["Http.Cookie", "Http.Response", "Http.Request", "Http.Parser", "Http.Message", "Http.Constants", "Http.Common", "Http.Url", "Http.Misc", "Http.Types"]}, "Utf8", "Utf16", "Ulexing", "Dyntype", {"data": "Cow", "children": [{"data": "Cow.Twitter", "children": ["Cow.Twitter.Status", "Cow.Twitter.User"]}, "Cow.Json", "Cow.Markdown", "Cow.Atom", "Cow.Code", "Cow.Css", "Cow.Html", {"data": "Cow.Xml", "children": ["Cow.Xml.Make"]}]}], "info": {"Base64": {"module": {"name": "Base64", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/base64.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/base64.mli|0"}, "info": {"description": "decode a string encoded in base64. Will leave trailing NULLs on the string padding it out to a multiple of 3 characters"}, "type": "sig  end", "module_structure": [{"value": {"name": "Base64.decode", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/base64.mli|715"}, "info": "", "type": "string -> string", "params": [{"name": "", "type": "string"}]}}, {"value": {"name": "Base64.encode", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/base64.mli|780"}, "info": {"description": "encode a string into base64"}, "type": "string -> string", "params": [{"name": "", "type": "string"}]}}], "dependencies": {"uses": [], "used_by": []}}}, "String": {"module": {"name": "String", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/string.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/string.mli|0"}, "info": {"description": "String operations. Given a string <span class=\"code\" >s<\/span> of length <span class=\"code\" >l<\/span>, we call character number in <span class=\"code\" >s<\/span> the index of a character in <span class=\"code\" >s<\/span>.  Indexes start at <span class=\"code\" >0<\/span>, and we will call a character number valid in <span class=\"code\" >s<\/span> if it falls within the range <span class=\"code\" >[0...l-1]<\/span>. A position is the point between two characters or at the beginning or end of the string.  We call a position valid in <span class=\"code\" >s<\/span> if it falls within the range <span class=\"code\" >[0...l]<\/span>. Note that character number <span class=\"code\" >n<\/span> is between positions <span class=\"code\" >n<\/span> and <span class=\"code\" >n+1<\/span>.<br><\/br> Two parameters <span class=\"code\" >start<\/span> and <span class=\"code\" >len<\/span> are said to designate a valid substring of <span class=\"code\" >s<\/span> if <span class=\"code\" >len &gt;= 0<\/span> and <span class=\"code\" >start<\/span> and <span class=\"code\" >start+len<\/span> are valid positions in <span class=\"code\" >s<\/span>."}, "type": "sig  end", "module_structure": [{"value": {"name": "String.length", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/string.mli|1589"}, "info": {"description": "Return the length (number of characters) of the given string."}, "type": "string -> int", "params": [{"name": "", "type": "string"}]}}, {"value": {"name": "String.get", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/string.mli|1710"}, "info": {"description": "<span class=\"code\" >String.get s n<\/span> returns character number <span class=\"code\" >n<\/span> in string <span class=\"code\" >s<\/span>. You can also write <span class=\"code\" >s.[n]<\/span> instead of <span class=\"code\" >String.get s n<\/span>.<br><\/br> Raise <span class=\"code\" >Invalid_argument<\/span> if <span class=\"code\" >n<\/span> not a valid character number in <span class=\"code\" >s<\/span>."}, "type": "string -> int -> char", "params": [{"name": "", "type": "string"}, {"name": "", "type": "int"}]}}, {"value": {"name": "String.set", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/string.mli|1970"}, "info": {"description": "<span class=\"code\" >String.set s n c<\/span> modifies string <span class=\"code\" >s<\/span> in place, replacing the character number <span class=\"code\" >n<\/span> by <span class=\"code\" >c<\/span>. You can also write <span class=\"code\" >s.[n] &lt;- c<\/span> instead of <span class=\"code\" >String.set s n c<\/span>.<br><\/br> Raise <span class=\"code\" >Invalid_argument<\/span> if <span class=\"code\" >n<\/span> is not a valid character number in <span class=\"code\" >s<\/span>."}, "type": "string -> int -> char -> unit", "params": [{"name": "", "type": "string"}, {"name": "", "type": "int"}, {"name": "", "type": "char"}]}}, {"value": {"name": "String.create", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/string.mli|2281"}, "info": {"description": "<span class=\"code\" >String.create n<\/span> returns a fresh string of length <span class=\"code\" >n<\/span>. The string initially contains arbitrary characters.<br><\/br> Raise <span class=\"code\" >Invalid_argument<\/span> if <span class=\"code\" >n &lt; 0<\/span> or <span class=\"code\" >n &gt; <\/span><a href=\"{value|Sys.max_string_length}\" ><span class=\"code\" >Sys.max_string_length<\/span><\/a>."}, "type": "int -> string", "params": [{"name": "", "type": "int"}]}}, {"value": {"name": "String.make", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/string.mli|2530"}, "info": {"description": "<span class=\"code\" >String.make n c<\/span> returns a fresh string of length <span class=\"code\" >n<\/span>, filled with the character <span class=\"code\" >c<\/span>.<br><\/br> Raise <span class=\"code\" >Invalid_argument<\/span> if <span class=\"code\" >n &lt; 0<\/span> or <span class=\"code\" >n &gt; <\/span><a href=\"{value|Sys.max_string_length}\" ><span class=\"code\" >Sys.max_string_length<\/span><\/a>."}, "type": "int -> char -> string", "params": [{"name": "", "type": "int"}, {"name": "", "type": "char"}]}}, {"value": {"name": "String.copy", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/string.mli|2735"}, "info": {"description": "Return a copy of the given string."}, "type": "string -> string", "params": [{"name": "", "type": "string"}]}}, {"value": {"name": "String.sub", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/string.mli|2806"}, "info": {"description": "<span class=\"code\" >String.sub s start len<\/span> returns a fresh string of length <span class=\"code\" >len<\/span>, containing the substring of <span class=\"code\" >s<\/span> that starts at position <span class=\"code\" >start<\/span> and has length <span class=\"code\" >len<\/span>.<br><\/br> Raise <span class=\"code\" >Invalid_argument<\/span> if <span class=\"code\" >start<\/span> and <span class=\"code\" >len<\/span> do not designate a valid substring of <span class=\"code\" >s<\/span>."}, "type": "string -> int -> int -> string", "params": [{"name": "", "type": "string"}, {"name": "", "type": "int"}, {"name": "", "type": "int"}]}}, {"value": {"name": "String.fill", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/string.mli|3108"}, "info": {"description": "<span class=\"code\" >String.fill s start len c<\/span> modifies string <span class=\"code\" >s<\/span> in place, replacing <span class=\"code\" >len<\/span> characters by <span class=\"code\" >c<\/span>, starting at <span class=\"code\" >start<\/span>.<br><\/br> Raise <span class=\"code\" >Invalid_argument<\/span> if <span class=\"code\" >start<\/span> and <span class=\"code\" >len<\/span> do not designate a valid substring of <span class=\"code\" >s<\/span>."}, "type": "string -> int -> int -> char -> unit", "params": [{"name": "", "type": "string"}, {"name": "", "type": "int"}, {"name": "", "type": "int"}, {"name": "", "type": "char"}]}}, {"value": {"name": "String.blit", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/string.mli|3377"}, "info": {"description": "<span class=\"code\" >String.blit src srcoff dst dstoff len<\/span> copies <span class=\"code\" >len<\/span> characters from string <span class=\"code\" >src<\/span>, starting at character number <span class=\"code\" >srcoff<\/span>, to string <span class=\"code\" >dst<\/span>, starting at character number <span class=\"code\" >dstoff<\/span>. It works correctly even if <span class=\"code\" >src<\/span> and <span class=\"code\" >dst<\/span> are the same string, and the source and destination intervals overlap.<br><\/br> Raise <span class=\"code\" >Invalid_argument<\/span> if <span class=\"code\" >srcoff<\/span> and <span class=\"code\" >len<\/span> do not designate a valid substring of <span class=\"code\" >src<\/span>, or if <span class=\"code\" >dstoff<\/span> and <span class=\"code\" >len<\/span> do not designate a valid substring of <span class=\"code\" >dst<\/span>."}, "type": "string -> int -> string -> int -> int -> unit", "params": [{"name": "", "type": "string"}, {"name": "", "type": "int"}, {"name": "", "type": "string"}, {"name": "", "type": "int"}, {"name": "", "type": "int"}]}}, {"value": {"name": "String.concat", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/string.mli|3918"}, "info": {"description": "<span class=\"code\" >String.concat sep sl<\/span> concatenates the list of strings <span class=\"code\" >sl<\/span>, inserting the separator string <span class=\"code\" >sep<\/span> between each."}, "type": "string -> string list -> string", "params": [{"name": "", "type": "string"}, {"name": "", "type": "string list"}]}}, {"value": {"name": "String.iter", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/string.mli|4087"}, "info": {"description": "<span class=\"code\" >String.iter f s<\/span> applies function <span class=\"code\" >f<\/span> in turn to all the characters of <span class=\"code\" >s<\/span>.  It is equivalent to <span class=\"code\" >f s.[0]; f s.[1]; ...; f s.[String.length s - 1]; ()<\/span>."}, "type": "(char -> unit) -> string -> unit", "params": [{"name": "", "type": "char -> unit"}, {"name": "", "type": "string"}]}}, {"value": {"name": "String.escaped", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/string.mli|4299"}, "info": {"description": "Return a copy of the argument, with special characters represented by escape sequences, following the lexical conventions of Objective Caml.  If there is no special character in the argument, return the original string itself, not a copy."}, "type": "string -> string", "params": [{"name": "", "type": "string"}]}}, {"value": {"name": "String.index", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/string.mli|4589"}, "info": {"description": "<span class=\"code\" >String.index s c<\/span> returns the character number of the first occurrence of character <span class=\"code\" >c<\/span> in string <span class=\"code\" >s<\/span>.<br><\/br> Raise <span class=\"code\" >Not_found<\/span> if <span class=\"code\" >c<\/span> does not occur in <span class=\"code\" >s<\/span>."}, "type": "string -> char -> int", "params": [{"name": "", "type": "string"}, {"name": "", "type": "char"}]}}, {"value": {"name": "String.rindex", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/string.mli|4790"}, "info": {"description": "<span class=\"code\" >String.rindex s c<\/span> returns the character number of the last occurrence of character <span class=\"code\" >c<\/span> in string <span class=\"code\" >s<\/span>.<br><\/br> Raise <span class=\"code\" >Not_found<\/span> if <span class=\"code\" >c<\/span> does not occur in <span class=\"code\" >s<\/span>."}, "type": "string -> char -> int", "params": [{"name": "", "type": "string"}, {"name": "", "type": "char"}]}}, {"value": {"name": "String.index_from", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/string.mli|4992"}, "info": {"description": "<span class=\"code\" >String.index_from s i c<\/span> returns the character number of the first occurrence of character <span class=\"code\" >c<\/span> in string <span class=\"code\" >s<\/span> after position <span class=\"code\" >i<\/span>. <span class=\"code\" >String.index s c<\/span> is equivalent to <span class=\"code\" >String.index_from s 0 c<\/span>.<br><\/br> Raise <span class=\"code\" >Invalid_argument<\/span> if <span class=\"code\" >i<\/span> is not a valid position in <span class=\"code\" >s<\/span>. Raise <span class=\"code\" >Not_found<\/span> if <span class=\"code\" >c<\/span> does not occur in <span class=\"code\" >s<\/span> after position <span class=\"code\" >i<\/span>."}, "type": "string -> int -> char -> int", "params": [{"name": "", "type": "string"}, {"name": "", "type": "int"}, {"name": "", "type": "char"}]}}, {"value": {"name": "String.rindex_from", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/string.mli|5383"}, "info": {"description": "<span class=\"code\" >String.rindex_from s i c<\/span> returns the character number of the last occurrence of character <span class=\"code\" >c<\/span> in string <span class=\"code\" >s<\/span> before position <span class=\"code\" >i+1<\/span>. <span class=\"code\" >String.rindex s c<\/span> is equivalent to <span class=\"code\" >String.rindex_from s (String.length s - 1) c<\/span>.<br><\/br> Raise <span class=\"code\" >Invalid_argument<\/span> if <span class=\"code\" >i+1<\/span> is not a valid position in <span class=\"code\" >s<\/span>. Raise <span class=\"code\" >Not_found<\/span> if <span class=\"code\" >c<\/span> does not occur in <span class=\"code\" >s<\/span> before position <span class=\"code\" >i+1<\/span>."}, "type": "string -> int -> char -> int", "params": [{"name": "", "type": "string"}, {"name": "", "type": "int"}, {"name": "", "type": "char"}]}}, {"value": {"name": "String.contains", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/string.mli|5808"}, "info": {"description": "<span class=\"code\" >String.contains s c<\/span> tests if character <span class=\"code\" >c<\/span> appears in the string <span class=\"code\" >s<\/span>."}, "type": "string -> char -> bool", "params": [{"name": "", "type": "string"}, {"name": "", "type": "char"}]}}, {"value": {"name": "String.contains_from", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/string.mli|5929"}, "info": {"description": "<span class=\"code\" >String.contains_from s start c<\/span> tests if character <span class=\"code\" >c<\/span> appears in <span class=\"code\" >s<\/span> after position <span class=\"code\" >start<\/span>. <span class=\"code\" >String.contains s c<\/span> is equivalent to <span class=\"code\" >String.contains_from s 0 c<\/span>.<br><\/br> Raise <span class=\"code\" >Invalid_argument<\/span> if <span class=\"code\" >start<\/span> is not a valid position in <span class=\"code\" >s<\/span>."}, "type": "string -> int -> char -> bool", "params": [{"name": "", "type": "string"}, {"name": "", "type": "int"}, {"name": "", "type": "char"}]}}, {"value": {"name": "String.rcontains_from", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/string.mli|6232"}, "info": {"description": "<span class=\"code\" >String.rcontains_from s stop c<\/span> tests if character <span class=\"code\" >c<\/span> appears in <span class=\"code\" >s<\/span> before position <span class=\"code\" >stop+1<\/span>.<br><\/br> Raise <span class=\"code\" >Invalid_argument<\/span> if <span class=\"code\" >stop &lt; 0<\/span> or <span class=\"code\" >stop+1<\/span> is not a valid position in <span class=\"code\" >s<\/span>."}, "type": "string -> int -> char -> bool", "params": [{"name": "", "type": "string"}, {"name": "", "type": "int"}, {"name": "", "type": "char"}]}}, {"value": {"name": "String.uppercase", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/string.mli|6481"}, "info": {"description": "Return a copy of the argument, with all lowercase letters translated to uppercase, including accented letters of the ISO Latin-1 (8859-1) character set."}, "type": "string -> string", "params": [{"name": "", "type": "string"}]}}, {"value": {"name": "String.lowercase", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/string.mli|6681"}, "info": {"description": "Return a copy of the argument, with all uppercase letters translated to lowercase, including accented letters of the ISO Latin-1 (8859-1) character set."}, "type": "string -> string", "params": [{"name": "", "type": "string"}]}}, {"value": {"name": "String.capitalize", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/string.mli|6881"}, "info": {"description": "Return a copy of the argument, with the first character set to uppercase."}, "type": "string -> string", "params": [{"name": "", "type": "string"}]}}, {"value": {"name": "String.uncapitalize", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/string.mli|6997"}, "info": {"description": "Return a copy of the argument, with the first character set to lowercase."}, "type": "string -> string", "params": [{"name": "", "type": "string"}]}}, {"type": {"name": "String.t", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/string.mli|7120"}, "info": {"description": "An alias for the type of strings."}, "params": [], "kind": {"type": "abstract"}, "manifest": "string"}}, {"value": {"name": "String.compare", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/string.mli|7173"}, "info": {"description": "The comparison function for strings, with the same specification as <a href=\"{value|Pervasives.compare}\" ><span class=\"code\" >Pervasives.compare<\/span><\/a>.  Along with the type <span class=\"code\" >t<\/span>, this function <span class=\"code\" >compare<\/span> allows the module <span class=\"code\" >String<\/span> to be passed as argument to the functors <a href=\"{module|Set.Make}\" ><span class=\"code\" >Set.Make<\/span><\/a> and <a href=\"{module|Map.Make}\" ><span class=\"code\" >Map.Make<\/span><\/a>."}, "type": "String.t -> String.t -> int", "params": [{"name": "", "type": "String.t"}, {"name": "", "type": "String.t"}]}}], "dependencies": {"uses": [], "used_by": []}}}, "Stack": {"module": {"name": "Stack", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/stack.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/stack.mli|0"}, "info": {"description": "Last-in first-out stacks.<br><\/br> This module implements stacks (LIFOs), with in-place modification."}, "type": "sig  end", "module_structure": [{"type": {"name": "Stack.t", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/stack.mli|1056"}, "info": {"description": "The type of stacks containing elements of type <span class=\"code\" >'a<\/span>."}, "params": [{"covariant": "true", "contravariant": "true", "type": "'a"}], "kind": {"type": "abstract"}}}, {"exception": {"name": "Stack.Empty", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/stack.mli|1123"}, "info": {"description": "Raised when <a href=\"{value|Stack.pop}\" ><span class=\"code\" >Stack.pop<\/span><\/a> or <a href=\"{value|Stack.top}\" ><span class=\"code\" >Stack.top<\/span><\/a> is applied to an empty stack."}}}, {"value": {"name": "Stack.create", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/stack.mli|1219"}, "info": {"description": "Return a new stack, initially empty."}, "type": "unit -> 'a Stack.t", "params": [{"name": "", "type": "unit"}]}}, {"value": {"name": "Stack.push", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/stack.mli|1290"}, "info": {"description": "<span class=\"code\" >push x s<\/span> adds the element <span class=\"code\" >x<\/span> at the top of stack <span class=\"code\" >s<\/span>."}, "type": "'a -> 'a Stack.t -> unit", "params": [{"name": "", "type": "'a"}, {"name": "", "type": "'a Stack.t"}]}}, {"value": {"name": "Stack.pop", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/stack.mli|1385"}, "info": {"description": "<span class=\"code\" >pop s<\/span> removes and returns the topmost element in stack <span class=\"code\" >s<\/span>, or raises <span class=\"code\" >Empty<\/span> if the stack is empty."}, "type": "'a Stack.t -> 'a", "params": [{"name": "", "type": "'a Stack.t"}]}}, {"value": {"name": "Stack.top", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/stack.mli|1520"}, "info": {"description": "<span class=\"code\" >top s<\/span> returns the topmost element in stack <span class=\"code\" >s<\/span>, or raises <span class=\"code\" >Empty<\/span> if the stack is empty."}, "type": "'a Stack.t -> 'a", "params": [{"name": "", "type": "'a Stack.t"}]}}, {"value": {"name": "Stack.clear", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/stack.mli|1643"}, "info": {"description": "Discard all elements from a stack."}, "type": "'a Stack.t -> unit", "params": [{"name": "", "type": "'a Stack.t"}]}}, {"value": {"name": "Stack.copy", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/stack.mli|1711"}, "info": {"description": "Return a copy of the given stack."}, "type": "'a Stack.t -> 'a Stack.t", "params": [{"name": "", "type": "'a Stack.t"}]}}, {"value": {"name": "Stack.is_empty", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/stack.mli|1777"}, "info": {"description": "Return <span class=\"code\" >true<\/span> if the given stack is empty, <span class=\"code\" >false<\/span> otherwise."}, "type": "'a Stack.t -> bool", "params": [{"name": "", "type": "'a Stack.t"}]}}, {"value": {"name": "Stack.length", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/stack.mli|1875"}, "info": {"description": "Return the number of elements in a stack."}, "type": "'a Stack.t -> int", "params": [{"name": "", "type": "'a Stack.t"}]}}, {"value": {"name": "Stack.iter", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/stack.mli|1950"}, "info": {"description": "<span class=\"code\" >iter f s<\/span> applies <span class=\"code\" >f<\/span> in turn to all elements of <span class=\"code\" >s<\/span>, from the element at the top of the stack to the element at the bottom of the stack. The stack itself is unchanged."}, "type": "('a -> unit) -> 'a Stack.t -> unit", "params": [{"name": "", "type": "'a -> unit"}, {"name": "", "type": "'a Stack.t"}]}}], "dependencies": {"uses": [], "used_by": []}}}, "Sort": {"module": {"name": "Sort", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/sort.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/sort.mli|0"}, "info": {"description": "Sorting and merging lists.", "deprecated": "This module is obsolete and exists only for backward compatibility. The sorting functions in <a href=\"{module|Array}\" ><span class=\"code\" >Array<\/span><\/a> and <a href=\"{module|List}\" ><span class=\"code\" >List<\/span><\/a> should be used instead. The new functions are faster and use less memory."}, "type": "sig  end", "module_structure": [{"value": {"name": "Sort.list", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/sort.mli|1194"}, "info": {"description": "Sort a list in increasing order according to an ordering predicate. The predicate should return <span class=\"code\" >true<\/span> if its first argument is less than or equal to its second argument."}, "type": "('a -> 'a -> bool) -> 'a list -> 'a list", "params": [{"name": "", "type": "'a -> 'a -> bool"}, {"name": "", "type": "'a list"}]}}, {"value": {"name": "Sort.array", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/sort.mli|1431"}, "info": {"description": "Sort an array in increasing order according to an ordering predicate. The predicate should return <span class=\"code\" >true<\/span> if its first argument is less than or equal to its second argument. The array is sorted in place."}, "type": "('a -> 'a -> bool) -> 'a array -> unit", "params": [{"name": "", "type": "'a -> 'a -> bool"}, {"name": "", "type": "'a array"}]}}, {"value": {"name": "Sort.merge", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/sort.mli|1705"}, "info": {"description": "Merge two lists according to the given predicate. Assuming the two argument lists are sorted according to the predicate, <span class=\"code\" >merge<\/span> returns a sorted list containing the elements from the two lists. The behavior is undefined if the two argument lists were not sorted."}, "type": "('a -> 'a -> bool) -> 'a list -> 'a list -> 'a list", "params": [{"name": "", "type": "'a -> 'a -> bool"}, {"name": "", "type": "'a list"}, {"name": "", "type": "'a list"}]}}], "dependencies": {"uses": [], "used_by": []}}}, "Set": {"module": {"name": "Set", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/set.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/set.mli|0"}, "info": {"description": "Sets over ordered types.<br><\/br> This module implements the set data structure, given a total ordering function over the set elements. All operations over sets are purely applicative (no side-effects). The implementation uses balanced binary trees, and is therefore reasonably efficient: insertion and membership take time logarithmic in the size of the set, for instance."}, "type": "sig  end", "module_structure": [{"module_type": {"name": "Set.OrderedType", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/set.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/set.mli|1337"}, "info": {"description": "Input signature of the functor <a href=\"{module|Set.Make}\" ><span class=\"code\" >Set.Make<\/span><\/a>."}, "type": "sig  end", "kind": ""}}, {"module_type": {"name": "Set.S", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/set.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/set.mli|1973"}, "info": {"description": "Output signature of the functor <a href=\"{module|Set.Make}\" ><span class=\"code\" >Set.Make<\/span><\/a>."}, "type": "sig  end", "kind": ""}}, {"module": {"name": "Set.Make", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/set.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/set.mli|5783"}, "info": {"description": "Functor building an implementation of the set structure given a totally ordered type."}, "type": "functor (Ord : OrderedType) -> sig  end", "module_functor": {"parameter": {"name": "Ord"}, "module_with": "unavailable"}, "dependencies": {"uses": []}}}], "dependencies": {"uses": [], "used_by": []}}}, "Queue": {"module": {"name": "Queue", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/queue.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/queue.mli|0"}, "info": {"description": "First-in first-out queues.<br><\/br> This module implements queues (FIFOs), with in-place modification."}, "type": "sig  end", "module_structure": [{"type": {"name": "Queue.t", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/queue.mli|1056"}, "info": {"description": "The type of queues containing elements of type <span class=\"code\" >'a<\/span>."}, "params": [{"covariant": "true", "contravariant": "true", "type": "'b"}], "kind": {"type": "abstract"}}}, {"exception": {"name": "Queue.Empty", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/queue.mli|1124"}, "info": {"description": "Raised when <a href=\"{value|Queue.take}\" ><span class=\"code\" >Queue.take<\/span><\/a> or <a href=\"{value|Queue.peek}\" ><span class=\"code\" >Queue.peek<\/span><\/a> is applied to an empty queue."}}}, {"value": {"name": "Queue.create", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/queue.mli|1222"}, "info": {"description": "Return a new queue, initially empty."}, "type": "unit -> 'a Queue.t", "params": [{"name": "", "type": "unit"}]}}, {"value": {"name": "Queue.add", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/queue.mli|1293"}, "info": {"description": "<span class=\"code\" >add x q<\/span> adds the element <span class=\"code\" >x<\/span> at the end of the queue <span class=\"code\" >q<\/span>."}, "type": "'a -> 'a Queue.t -> unit", "params": [{"name": "", "type": "'a"}, {"name": "", "type": "'a Queue.t"}]}}, {"value": {"name": "Queue.push", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/queue.mli|1390"}, "info": {"description": "<span class=\"code\" >push<\/span> is a synonym for <span class=\"code\" >add<\/span>."}, "type": "'a -> 'a Queue.t -> unit", "params": [{"name": "", "type": "'a"}, {"name": "", "type": "'a Queue.t"}]}}, {"value": {"name": "Queue.take", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/queue.mli|1459"}, "info": {"description": "<span class=\"code\" >take q<\/span> removes and returns the first element in queue <span class=\"code\" >q<\/span>, or raises <span class=\"code\" >Empty<\/span> if the queue is empty."}, "type": "'a Queue.t -> 'a", "params": [{"name": "", "type": "'a Queue.t"}]}}, {"value": {"name": "Queue.pop", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/queue.mli|1594"}, "info": {"description": "<span class=\"code\" >pop<\/span> is a synonym for <span class=\"code\" >take<\/span>."}, "type": "'a Queue.t -> 'a", "params": [{"name": "", "type": "'a Queue.t"}]}}, {"value": {"name": "Queue.peek", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/queue.mli|1654"}, "info": {"description": "<span class=\"code\" >peek q<\/span> returns the first element in queue <span class=\"code\" >q<\/span>, without removing it from the queue, or raises <span class=\"code\" >Empty<\/span> if the queue is empty."}, "type": "'a Queue.t -> 'a", "params": [{"name": "", "type": "'a Queue.t"}]}}, {"value": {"name": "Queue.top", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/queue.mli|1813"}, "info": {"description": "<span class=\"code\" >top<\/span> is a synonym for <span class=\"code\" >peek<\/span>."}, "type": "'a Queue.t -> 'a", "params": [{"name": "", "type": "'a Queue.t"}]}}, {"value": {"name": "Queue.clear", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/queue.mli|1873"}, "info": {"description": "Discard all elements from a queue."}, "type": "'a Queue.t -> unit", "params": [{"name": "", "type": "'a Queue.t"}]}}, {"value": {"name": "Queue.copy", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/queue.mli|1941"}, "info": {"description": "Return a copy of the given queue."}, "type": "'a Queue.t -> 'a Queue.t", "params": [{"name": "", "type": "'a Queue.t"}]}}, {"value": {"name": "Queue.is_empty", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/queue.mli|2007"}, "info": {"description": "Return <span class=\"code\" >true<\/span> if the given queue is empty, <span class=\"code\" >false<\/span> otherwise."}, "type": "'a Queue.t -> bool", "params": [{"name": "", "type": "'a Queue.t"}]}}, {"value": {"name": "Queue.length", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/queue.mli|2105"}, "info": {"description": "Return the number of elements in a queue."}, "type": "'a Queue.t -> int", "params": [{"name": "", "type": "'a Queue.t"}]}}, {"value": {"name": "Queue.iter", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/queue.mli|2180"}, "info": {"description": "<span class=\"code\" >iter f q<\/span> applies <span class=\"code\" >f<\/span> in turn to all elements of <span class=\"code\" >q<\/span>, from the least recently entered to the most recently entered. The queue itself is unchanged."}, "type": "('a -> unit) -> 'a Queue.t -> unit", "params": [{"name": "", "type": "'a -> unit"}, {"name": "", "type": "'a Queue.t"}]}}, {"value": {"name": "Queue.fold", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/queue.mli|2382"}, "info": {"description": "<span class=\"code\" >fold f accu q<\/span> is equivalent to <span class=\"code\" >List.fold_left f accu l<\/span>, where <span class=\"code\" >l<\/span> is the list of <span class=\"code\" >q<\/span>'s elements. The queue remains unchanged."}, "type": "('a -> 'b -> 'a) -> 'a -> 'b Queue.t -> 'a", "params": [{"name": "", "type": "'a -> 'b -> 'a"}, {"name": "", "type": "'a"}, {"name": "", "type": "'a Queue.t"}]}}, {"value": {"name": "Queue.transfer", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/queue.mli|2574"}, "info": {"description": "<span class=\"code\" >transfer q1 q2<\/span> adds all of <span class=\"code\" >q1<\/span>'s elements at the end of the queue <span class=\"code\" >q2<\/span>, then clears <span class=\"code\" >q1<\/span>. It is equivalent to the sequence <span class=\"code\" >iter (fun x -&gt; add x q2) q1; clear q1<\/span>, but runs in constant time."}, "type": "'a Queue.t -> 'a Queue.t -> unit", "params": [{"name": "", "type": "'a Queue.t"}, {"name": "", "type": "'a Queue.t"}]}}], "dependencies": {"uses": [], "used_by": []}}}, "Printexc": {"module": {"name": "Printexc", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/printexc.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/printexc.mli|0"}, "info": {"description": "Facilities for printing exceptions."}, "type": "sig  end", "module_structure": [{"value": {"name": "Printexc.to_string", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/printexc.mli|995"}, "info": {"description": "<span class=\"code\" >Printexc.to_string e<\/span> returns a string representation of the exception <span class=\"code\" >e<\/span>."}, "type": "exn -> string", "params": [{"name": "", "type": "exn"}]}}, {"value": {"name": "Printexc.print", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/printexc.mli|1112"}, "info": {"description": "<span class=\"code\" >Printexc.print fn x<\/span> applies <span class=\"code\" >fn<\/span> to <span class=\"code\" >x<\/span> and returns the result. If the evaluation of <span class=\"code\" >fn x<\/span> raises any exception, the name of the exception is printed on standard error output, and the exception is raised again. The typical use is to catch and report exceptions that escape a function application."}, "type": "('a -> 'b) -> 'a -> 'b", "params": [{"name": "", "type": "'a -> 'b"}, {"name": "", "type": "'a"}]}}, {"value": {"name": "Printexc.catch", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/printexc.mli|1469"}, "info": {"description": "<span class=\"code\" >Printexc.catch fn x<\/span> is similar to <a href=\"{value|Printexc.print}\" ><span class=\"code\" >Printexc.print<\/span><\/a>, but aborts the program with exit code 2 after printing the uncaught exception.  This function is deprecated: the runtime system is now able to print uncaught exceptions as precisely as <span class=\"code\" >Printexc.catch<\/span> does.  Moreover, calling <span class=\"code\" >Printexc.catch<\/span> makes it harder to track the location of the exception using the debugger or the stack backtrace facility. So, do not use <span class=\"code\" >Printexc.catch<\/span> in new code."}, "type": "('a -> 'b) -> 'a -> 'b", "params": [{"name": "", "type": "'a -> 'b"}, {"name": "", "type": "'a"}]}}, {"value": {"name": "Printexc.get_backtrace", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/printexc.mli|1984"}, "info": {"description": "<span class=\"code\" >Printexc.get_backtrace ()<\/span> returns a string containing the same exception backtrace that <span class=\"code\" >Printexc.print_backtrace<\/span> would print.", "since": "3.11.0"}, "type": "unit -> string", "params": [{"name": "", "type": "unit"}]}}, {"value": {"name": "Printexc.record_backtrace", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/printexc.mli|2182"}, "info": {"description": "<span class=\"code\" >Printexc.record_backtrace b<\/span> turns recording of exception backtraces on (if <span class=\"code\" >b = true<\/span>) or off (if <span class=\"code\" >b = false<\/span>).  Initially, backtraces are not recorded, unless the <span class=\"code\" >b<\/span> flag is given to the program through the <span class=\"code\" >OCAMLRUNPARAM<\/span> variable.", "since": "3.11.0"}, "type": "bool -> unit", "params": [{"name": "", "type": "bool"}]}}, {"value": {"name": "Printexc.backtrace_status", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/printexc.mli|2492"}, "info": {"description": "<span class=\"code\" >Printexc.backtrace_status()<\/span> returns <span class=\"code\" >true<\/span> if exception backtraces are currently recorded, <span class=\"code\" >false<\/span> if not.", "since": "3.11.0"}, "type": "unit -> bool", "params": [{"name": "", "type": "unit"}]}}, {"value": {"name": "Printexc.register_printer", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/printexc.mli|2666"}, "info": {"description": "<span class=\"code\" >Printexc.register_printer fn<\/span> registers <span class=\"code\" >fn<\/span> as an exception printer.  The printer should return <span class=\"code\" >None<\/span> or raise an exception if it does not know how to convert the passed exception, and <span class=\"code\" >Some s<\/span> with <span class=\"code\" >s<\/span> the resulting string if it can convert the passed exception. Exceptions raised by the printer are ignored.<br><\/br> When converting an exception into a string, the printers will be invoked in the reverse order of their registrations, until a printer returns a <span class=\"code\" >Some s<\/span> value (if no such printer exists, the runtime will use a generic printer).", "since": "3.11.2"}, "type": "(exn -> string option) -> unit", "params": [{"name": "", "type": "exn -> string option"}]}}], "dependencies": {"uses": [], "used_by": []}}}, "Pervasives": {"module": {"name": "Pervasives", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|0"}, "info": {"description": "The initially opened module.<br><\/br> This module provides the basic operations over the built-in types (numbers, booleans, strings, exceptions, references, lists, arrays, input-output channels, ...).<br><\/br> This module is automatically opened at the beginning of each compilation. All components of this module can therefore be referred by their short name, without prefixing them by <span class=\"code\" >Pervasives<\/span>."}, "type": "sig  end", "module_structure": [{"comment": "<h6>Exceptions<\/h6>"}, {"value": {"name": "Pervasives.raise", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|1385"}, "info": {"description": "Raise the given exception value"}, "type": "exn -> 'a", "params": [{"name": "", "type": "exn"}]}}, {"value": {"name": "Pervasives.invalid_arg", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|1463"}, "info": {"description": "Raise exception <span class=\"code\" >Invalid_argument<\/span> with the given string."}, "type": "string -> 'a", "params": [{"name": "", "type": "string"}]}}, {"value": {"name": "Pervasives.failwith", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|1560"}, "info": {"description": "Raise exception <span class=\"code\" >Failure<\/span> with the given string."}, "type": "string -> 'a", "params": [{"name": "", "type": "string"}]}}, {"exception": {"name": "Pervasives.Exit", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|1645"}, "info": {"description": "The <span class=\"code\" >Exit<\/span> exception is not raised by any library function.  It is provided for use in your programs."}}}, {"comment": "<h6>Comparisons<\/h6>"}, {"value": {"name": "Pervasives.(=)", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|1798"}, "info": {"description": "<span class=\"code\" >e1 = e2<\/span> tests for structural equality of <span class=\"code\" >e1<\/span> and <span class=\"code\" >e2<\/span>. Mutable structures (e.g. references and arrays) are equal if and only if their current contents are structurally equal, even if the two mutable objects are not the same physical object. Equality between functional values raises <span class=\"code\" >Invalid_argument<\/span>. Equality between cyclic data structures may not terminate."}, "type": "'a -> 'a -> bool", "params": [{"name": "", "type": "'a"}, {"name": "", "type": "'a"}]}}, {"value": {"name": "Pervasives.(<>)", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|2231"}, "info": {"description": "Negation of <a href=\"{value|Pervasives.(=)}\" ><span class=\"code\" >Pervasives.(=)<\/span><\/a>."}, "type": "'a -> 'a -> bool", "params": [{"name": "", "type": "'a"}, {"name": "", "type": "'a"}]}}, {"value": {"name": "Pervasives.(<)", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|2319"}, "info": {"description": "See <a href=\"{value|Pervasives.(&gt;=)}\" ><span class=\"code\" >Pervasives.(&gt;=)<\/span><\/a>."}, "type": "'a -> 'a -> bool", "params": [{"name": "", "type": "'a"}, {"name": "", "type": "'a"}]}}, {"value": {"name": "Pervasives.(>)", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|2399"}, "info": {"description": "See <a href=\"{value|Pervasives.(&gt;=)}\" ><span class=\"code\" >Pervasives.(&gt;=)<\/span><\/a>."}, "type": "'a -> 'a -> bool", "params": [{"name": "", "type": "'a"}, {"name": "", "type": "'a"}]}}, {"value": {"name": "Pervasives.(<=)", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|2482"}, "info": {"description": "See <a href=\"{value|Pervasives.(&gt;=)}\" ><span class=\"code\" >Pervasives.(&gt;=)<\/span><\/a>."}, "type": "'a -> 'a -> bool", "params": [{"name": "", "type": "'a"}, {"name": "", "type": "'a"}]}}, {"value": {"name": "Pervasives.(>=)", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|2564"}, "info": {"description": "Structural ordering functions. These functions coincide with the usual orderings over integers, characters, strings and floating-point numbers, and extend them to a total ordering over all types. The ordering is compatible with <span class=\"code\" >(=)<\/span>. As in the case of <span class=\"code\" >(=)<\/span>, mutable structures are compared by contents. Comparison between functional values raises <span class=\"code\" >Invalid_argument<\/span>. Comparison between cyclic structures may not terminate."}, "type": "'a -> 'a -> bool", "params": [{"name": "", "type": "'a"}, {"name": "", "type": "'a"}]}}, {"value": {"name": "Pervasives.compare", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|3071"}, "info": {"description": "<span class=\"code\" >compare x y<\/span> returns <span class=\"code\" >0<\/span> if <span class=\"code\" >x<\/span> is equal to <span class=\"code\" >y<\/span>, a negative integer if <span class=\"code\" >x<\/span> is less than <span class=\"code\" >y<\/span>, and a positive integer if <span class=\"code\" >x<\/span> is greater than <span class=\"code\" >y<\/span>.  The ordering implemented by <span class=\"code\" >compare<\/span> is compatible with the comparison predicates <span class=\"code\" >=<\/span>, <span class=\"code\" >&lt;<\/span> and <span class=\"code\" >&gt;<\/span> defined above,  with one difference on the treatment of the float value <a href=\"{value|Pervasives.nan}\" ><span class=\"code\" >Pervasives.nan<\/span><\/a>.  Namely, the comparison predicates treat <span class=\"code\" >nan<\/span> as different from any other float value, including itself; while <span class=\"code\" >compare<\/span> treats <span class=\"code\" >nan<\/span> as equal to itself and less than any other float value.  This treatment of <span class=\"code\" >nan<\/span> ensures that <span class=\"code\" >compare<\/span> defines a total ordering relation.<br><\/br> <span class=\"code\" >compare<\/span> applied to functional values may raise <span class=\"code\" >Invalid_argument<\/span>. <span class=\"code\" >compare<\/span> applied to cyclic structures may not terminate.<br><\/br> The <span class=\"code\" >compare<\/span> function can be used as the comparison function required by the <a href=\"{module|Set.Make}\" ><span class=\"code\" >Set.Make<\/span><\/a> and <a href=\"{module|Map.Make}\" ><span class=\"code\" >Map.Make<\/span><\/a> functors, as well as the <a href=\"{value|List.sort}\" ><span class=\"code\" >List.sort<\/span><\/a> and <a href=\"{value|Array.sort}\" ><span class=\"code\" >Array.sort<\/span><\/a> functions."}, "type": "'a -> 'a -> int", "params": [{"name": "", "type": "'a"}, {"name": "", "type": "'a"}]}}, {"value": {"name": "Pervasives.min", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|4082"}, "info": {"description": "Return the smaller of the two arguments. The result is unspecified if one of the arguments contains the float value <span class=\"code\" >nan<\/span>."}, "type": "'a -> 'a -> 'a", "params": [{"name": "", "type": "'a"}, {"name": "", "type": "'a"}]}}, {"value": {"name": "Pervasives.max", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|4246"}, "info": {"description": "Return the greater of the two arguments. The result is unspecified if one of the arguments contains the float value <span class=\"code\" >nan<\/span>."}, "type": "'a -> 'a -> 'a", "params": [{"name": "", "type": "'a"}, {"name": "", "type": "'a"}]}}, {"value": {"name": "Pervasives.(==)", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|4410"}, "info": {"description": "<span class=\"code\" >e1 == e2<\/span> tests for physical equality of <span class=\"code\" >e1<\/span> and <span class=\"code\" >e2<\/span>. On mutable types such as references, arrays, strings, records with mutable fields and objects with mutable instance variables, <span class=\"code\" >e1 == e2<\/span> is true if and only if physical modification of <span class=\"code\" >e1<\/span> also affects <span class=\"code\" >e2<\/span>. On non-mutable types, the behavior of <span class=\"code\" >(==)<\/span> is implementation-dependent; however, it is guaranteed that <span class=\"code\" >e1 == e2<\/span> implies <span class=\"code\" >compare e1 e2 = 0<\/span>."}, "type": "'a -> 'a -> bool", "params": [{"name": "", "type": "'a"}, {"name": "", "type": "'a"}]}}, {"value": {"name": "Pervasives.(!=)", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|4894"}, "info": {"description": "Negation of <a href=\"{value|Pervasives.(==)}\" ><span class=\"code\" >Pervasives.(==)<\/span><\/a>."}, "type": "'a -> 'a -> bool", "params": [{"name": "", "type": "'a"}, {"name": "", "type": "'a"}]}}, {"comment": "<h6>Boolean operations<\/h6>"}, {"value": {"name": "Pervasives.not", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|5012"}, "info": {"description": "The boolean negation."}, "type": "bool -> bool", "params": [{"name": "", "type": "bool"}]}}, {"value": {"name": "Pervasives.(&&)", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|5083"}, "info": {"description": "The boolean ``and''. Evaluation is sequential, left-to-right: in <span class=\"code\" >e1 &amp;&amp; e2<\/span>, <span class=\"code\" >e1<\/span> is evaluated first, and if it returns <span class=\"code\" >false<\/span>, <span class=\"code\" >e2<\/span> is not evaluated at all."}, "type": "bool -> bool -> bool", "params": [{"name": "", "type": "bool"}, {"name": "", "type": "bool"}]}}, {"value": {"name": "Pervasives.(&)", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|5308"}, "info": {"deprecated": "<a href=\"{value|Pervasives.(&amp;&amp;)}\" ><span class=\"code\" >Pervasives.(&amp;&amp;)<\/span><\/a> should be used instead."}, "type": "bool -> bool -> bool", "params": [{"name": "", "type": "bool"}, {"name": "", "type": "bool"}]}}, {"value": {"name": "Pervasives.(||)", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|5424"}, "info": {"description": "The boolean ``or''. Evaluation is sequential, left-to-right: in <span class=\"code\" >e1 || e2<\/span>, <span class=\"code\" >e1<\/span> is evaluated first, and if it returns <span class=\"code\" >true<\/span>, <span class=\"code\" >e2<\/span> is not evaluated at all."}, "type": "bool -> bool -> bool", "params": [{"name": "", "type": "bool"}, {"name": "", "type": "bool"}]}}, {"value": {"name": "Pervasives.(or)", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|5646"}, "info": {"deprecated": "<a href=\"{value|Pervasives.(||)}\" ><span class=\"code\" >Pervasives.(||)<\/span><\/a> should be used instead."}, "type": "bool -> bool -> bool", "params": [{"name": "", "type": "bool"}, {"name": "", "type": "bool"}]}}, {"comment": "<h6>Integer arithmetic<\/h6>"}, {"comment": "Integers are 31 bits wide (or 63 bits on 64-bit processors). All operations are taken modulo 2<sup>31<\/sup> (or 2<sup>63<\/sup>). They do not fail on overflow."}, {"value": {"name": "Pervasives.(~-)", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|5950"}, "info": {"description": "Unary negation. You can also write <span class=\"code\" >- e<\/span> instead of <span class=\"code\" >~- e<\/span>."}, "type": "int -> int", "params": [{"name": "", "type": "int"}]}}, {"value": {"name": "Pervasives.(~+)", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|6059"}, "info": {"description": "Unary addition. You can also write <span class=\"code\" >+ e<\/span> instead of <span class=\"code\" >~+ e<\/span>.", "since": "3.12.0"}, "type": "int -> int", "params": [{"name": "", "type": "int"}]}}, {"value": {"name": "Pervasives.succ", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|6188"}, "info": {"description": "<span class=\"code\" >succ x<\/span> is <span class=\"code\" >x + 1<\/span>."}, "type": "int -> int", "params": [{"name": "", "type": "int"}]}}, {"value": {"name": "Pervasives.pred", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|6257"}, "info": {"description": "<span class=\"code\" >pred x<\/span> is <span class=\"code\" >x - 1<\/span>."}, "type": "int -> int", "params": [{"name": "", "type": "int"}]}}, {"value": {"name": "Pervasives.(+)", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|6326"}, "info": {"description": "Integer addition."}, "type": "int -> int -> int", "params": [{"name": "", "type": "int"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Pervasives.(-)", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|6399"}, "info": {"description": "Integer subtraction."}, "type": "int -> int -> int", "params": [{"name": "", "type": "int"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Pervasives.( * )", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|6475"}, "info": {"description": "Integer multiplication."}, "type": "int -> int -> int", "params": [{"name": "", "type": "int"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Pervasives.(\/)", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|6554"}, "info": {"description": "Integer division. Raise <span class=\"code\" >Division_by_zero<\/span> if the second argument is 0. Integer division rounds the real quotient of its arguments towards zero. More precisely, if <span class=\"code\" >x &gt;= 0<\/span> and <span class=\"code\" >y &gt; 0<\/span>, <span class=\"code\" >x \/ y<\/span> is the greatest integer less than or equal to the real quotient of <span class=\"code\" >x<\/span> by <span class=\"code\" >y<\/span>.  Moreover, <span class=\"code\" >(- x) \/ y = x \/ (- y) = - (x \/ y)<\/span>."}, "type": "int -> int -> int", "params": [{"name": "", "type": "int"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Pervasives.(mod)", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|6946"}, "info": {"description": "Integer remainder.  If <span class=\"code\" >y<\/span> is not zero, the result of <span class=\"code\" >x mod y<\/span> satisfies the following properties: <span class=\"code\" >x = (x \/ y) * y + x mod y<\/span> and <span class=\"code\" >abs(x mod y) &lt;= abs(y) - 1<\/span>. If <span class=\"code\" >y = 0<\/span>, <span class=\"code\" >x mod y<\/span> raises <span class=\"code\" >Division_by_zero<\/span>. Note that <span class=\"code\" >x mod y<\/span> is negative only if <span class=\"code\" >x &lt; 0<\/span>. Raise <span class=\"code\" >Division_by_zero<\/span> if <span class=\"code\" >y<\/span> is zero."}, "type": "int -> int -> int", "params": [{"name": "", "type": "int"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Pervasives.abs", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|7322"}, "info": {"description": "Return the absolute value of the argument.  Note that this may be negative if the argument is <span class=\"code\" >min_int<\/span>."}, "type": "int -> int", "params": [{"name": "", "type": "int"}]}}, {"value": {"name": "Pervasives.max_int", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|7458"}, "info": {"description": "The greatest representable integer."}, "type": "int", "params": []}}, {"value": {"name": "Pervasives.min_int", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|7520"}, "info": {"description": "The smallest representable integer."}, "type": "int", "params": []}}, {"comment": "<h7>Bitwise operations<\/h7>"}, {"value": {"name": "Pervasives.(land)", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|7614"}, "info": {"description": "Bitwise logical and."}, "type": "int -> int -> int", "params": [{"name": "", "type": "int"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Pervasives.(lor)", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|7693"}, "info": {"description": "Bitwise logical or."}, "type": "int -> int -> int", "params": [{"name": "", "type": "int"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Pervasives.(lxor)", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|7769"}, "info": {"description": "Bitwise logical exclusive or."}, "type": "int -> int -> int", "params": [{"name": "", "type": "int"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Pervasives.lnot", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|7857"}, "info": {"description": "Bitwise logical negation."}, "type": "int -> int", "params": [{"name": "", "type": "int"}]}}, {"value": {"name": "Pervasives.(lsl)", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|7913"}, "info": {"description": "<span class=\"code\" >n lsl m<\/span> shifts <span class=\"code\" >n<\/span> to the left by <span class=\"code\" >m<\/span> bits. The result is unspecified if <span class=\"code\" >m &lt; 0<\/span> or <span class=\"code\" >m &gt;= bitsize<\/span>, where <span class=\"code\" >bitsize<\/span> is <span class=\"code\" >32<\/span> on a 32-bit platform and <span class=\"code\" >64<\/span> on a 64-bit platform."}, "type": "int -> int -> int", "params": [{"name": "", "type": "int"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Pervasives.(lsr)", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|8157"}, "info": {"description": "<span class=\"code\" >n lsr m<\/span> shifts <span class=\"code\" >n<\/span> to the right by <span class=\"code\" >m<\/span> bits. This is a logical shift: zeroes are inserted regardless of the sign of <span class=\"code\" >n<\/span>. The result is unspecified if <span class=\"code\" >m &lt; 0<\/span> or <span class=\"code\" >m &gt;= bitsize<\/span>."}, "type": "int -> int -> int", "params": [{"name": "", "type": "int"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Pervasives.(asr)", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|8402"}, "info": {"description": "<span class=\"code\" >n asr m<\/span> shifts <span class=\"code\" >n<\/span> to the right by <span class=\"code\" >m<\/span> bits. This is an arithmetic shift: the sign bit of <span class=\"code\" >n<\/span> is replicated. The result is unspecified if <span class=\"code\" >m &lt; 0<\/span> or <span class=\"code\" >m &gt;= bitsize<\/span>."}, "type": "int -> int -> int", "params": [{"name": "", "type": "int"}, {"name": "", "type": "int"}]}}, {"comment": "<h6>Floating-point arithmetic<\/h6><br><\/br> Caml's floating-point numbers follow the IEEE 754 standard, using double precision (64 bits) numbers. Floating-point operations never raise an exception on overflow, underflow, division by zero, etc.  Instead, special IEEE numbers are returned as appropriate, such as <span class=\"code\" >infinity<\/span> for <span class=\"code\" >1.0 \/. 0.0<\/span>, <span class=\"code\" >neg_infinity<\/span> for <span class=\"code\" >-1.0 \/. 0.0<\/span>, and <span class=\"code\" >nan<\/span> (``not a number'') for <span class=\"code\" >0.0 \/. 0.0<\/span>.  These special numbers then propagate through floating-point computations as expected: for instance, <span class=\"code\" >1.0 \/. infinity<\/span> is <span class=\"code\" >0.0<\/span>, and any arithmetic operation with <span class=\"code\" >nan<\/span> as argument returns <span class=\"code\" >nan<\/span> as result."}, {"value": {"name": "Pervasives.(~-.)", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|9286"}, "info": {"description": "Unary negation. You can also write <span class=\"code\" >-. e<\/span> instead of <span class=\"code\" >~-. e<\/span>."}, "type": "float -> float", "params": [{"name": "", "type": "float"}]}}, {"value": {"name": "Pervasives.(~+.)", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|9404"}, "info": {"description": "Unary addition. You can also write <span class=\"code\" >+. e<\/span> instead of <span class=\"code\" >~+. e<\/span>.", "since": "3.12.0"}, "type": "float -> float", "params": [{"name": "", "type": "float"}]}}, {"value": {"name": "Pervasives.(+.)", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|9540"}, "info": {"description": "Floating-point addition"}, "type": "float -> float -> float", "params": [{"name": "", "type": "float"}, {"name": "", "type": "float"}]}}, {"value": {"name": "Pervasives.(-.)", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|9628"}, "info": {"description": "Floating-point subtraction"}, "type": "float -> float -> float", "params": [{"name": "", "type": "float"}, {"name": "", "type": "float"}]}}, {"value": {"name": "Pervasives.( *. )", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|9719"}, "info": {"description": "Floating-point multiplication"}, "type": "float -> float -> float", "params": [{"name": "", "type": "float"}, {"name": "", "type": "float"}]}}, {"value": {"name": "Pervasives.(\/.)", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|9813"}, "info": {"description": "Floating-point division."}, "type": "float -> float -> float", "params": [{"name": "", "type": "float"}, {"name": "", "type": "float"}]}}, {"value": {"name": "Pervasives.( ** )", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|9902"}, "info": {"description": "Exponentiation."}, "type": "float -> float -> float", "params": [{"name": "", "type": "float"}, {"name": "", "type": "float"}]}}, {"value": {"name": "Pervasives.sqrt", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|10003"}, "info": {"description": "Square root."}, "type": "float -> float", "params": [{"name": "", "type": "float"}]}}, {"value": {"name": "Pervasives.exp", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|10090"}, "info": {"description": "Exponential."}, "type": "float -> float", "params": [{"name": "", "type": "float"}]}}, {"value": {"name": "Pervasives.log", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|10174"}, "info": {"description": "Natural logarithm."}, "type": "float -> float", "params": [{"name": "", "type": "float"}]}}, {"value": {"name": "Pervasives.log10", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|10264"}, "info": {"description": "Base 10 logarithm."}, "type": "float -> float", "params": [{"name": "", "type": "float"}]}}, {"value": {"name": "Pervasives.expm1", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|10360"}, "info": {"description": "<span class=\"code\" >expm1 x<\/span> computes <span class=\"code\" >exp x -. 1.0<\/span>, giving numerically-accurate results even if <span class=\"code\" >x<\/span> is close to <span class=\"code\" >0.0<\/span>.", "since": "3.12.0"}, "type": "float -> float", "params": [{"name": "", "type": "float"}]}}, {"value": {"name": "Pervasives.log1p", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|10566"}, "info": {"description": "<span class=\"code\" >log1p x<\/span> computes <span class=\"code\" >log(1.0 +. x)<\/span> (natural logarithm), giving numerically-accurate results even if <span class=\"code\" >x<\/span> is close to <span class=\"code\" >0.0<\/span>.", "since": "3.12.0"}, "type": "float -> float", "params": [{"name": "", "type": "float"}]}}, {"value": {"name": "Pervasives.cos", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|10793"}, "info": {"description": "Cosine.  Argument is in radians."}, "type": "float -> float", "params": [{"name": "", "type": "float"}]}}, {"value": {"name": "Pervasives.sin", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|10897"}, "info": {"description": "Sine.  Argument is in radians."}, "type": "float -> float", "params": [{"name": "", "type": "float"}]}}, {"value": {"name": "Pervasives.tan", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|10999"}, "info": {"description": "Tangent.  Argument is in radians."}, "type": "float -> float", "params": [{"name": "", "type": "float"}]}}, {"value": {"name": "Pervasives.acos", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|11104"}, "info": {"description": "Arc cosine.  The argument must fall within the range <span class=\"code\" >[-1.0, 1.0]<\/span>. Result is in radians and is between <span class=\"code\" >0.0<\/span> and <span class=\"code\" >pi<\/span>."}, "type": "float -> float", "params": [{"name": "", "type": "float"}]}}, {"value": {"name": "Pervasives.asin", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|11302"}, "info": {"description": "Arc sine.  The argument must fall within the range <span class=\"code\" >[-1.0, 1.0]<\/span>. Result is in radians and is between <span class=\"code\" >-pi\/2<\/span> and <span class=\"code\" >pi\/2<\/span>."}, "type": "float -> float", "params": [{"name": "", "type": "float"}]}}, {"value": {"name": "Pervasives.atan", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|11502"}, "info": {"description": "Arc tangent. Result is in radians and is between <span class=\"code\" >-pi\/2<\/span> and <span class=\"code\" >pi\/2<\/span>."}, "type": "float -> float", "params": [{"name": "", "type": "float"}]}}, {"value": {"name": "Pervasives.atan2", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|11649"}, "info": {"description": "<span class=\"code\" >atan x y<\/span> returns the arc tangent of <span class=\"code\" >y \/. x<\/span>.  The signs of <span class=\"code\" >x<\/span> and <span class=\"code\" >y<\/span> are used to determine the quadrant of the result. Result is in radians and is between <span class=\"code\" >-pi<\/span> and <span class=\"code\" >pi<\/span>."}, "type": "float -> float -> float", "params": [{"name": "", "type": "float"}, {"name": "", "type": "float"}]}}, {"value": {"name": "Pervasives.cosh", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|11919"}, "info": {"description": "Hyperbolic cosine.  Argument is in radians."}, "type": "float -> float", "params": [{"name": "", "type": "float"}]}}, {"value": {"name": "Pervasives.sinh", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|12037"}, "info": {"description": "Hyperbolic sine.  Argument is in radians."}, "type": "float -> float", "params": [{"name": "", "type": "float"}]}}, {"value": {"name": "Pervasives.tanh", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|12153"}, "info": {"description": "Hyperbolic tangent.  Argument is in radians."}, "type": "float -> float", "params": [{"name": "", "type": "float"}]}}, {"value": {"name": "Pervasives.ceil", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|12272"}, "info": {"description": "Round above to an integer value. <span class=\"code\" >ceil f<\/span> returns the least integer value greater than or equal to <span class=\"code\" >f<\/span>. The result is returned as a float."}, "type": "float -> float", "params": [{"name": "", "type": "float"}]}}, {"value": {"name": "Pervasives.floor", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|12493"}, "info": {"description": "Round below to an integer value. <span class=\"code\" >floor f<\/span> returns the greatest integer value less than or equal to <span class=\"code\" >f<\/span>. The result is returned as a float."}, "type": "float -> float", "params": [{"name": "", "type": "float"}]}}, {"value": {"name": "Pervasives.abs_float", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|12722"}, "info": {"description": "<span class=\"code\" >abs_float f<\/span> returns the absolute value of <span class=\"code\" >f<\/span>."}, "type": "float -> float", "params": [{"name": "", "type": "float"}]}}, {"value": {"name": "Pervasives.mod_float", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|12829"}, "info": {"description": "<span class=\"code\" >mod_float a b<\/span> returns the remainder of <span class=\"code\" >a<\/span> with respect to <span class=\"code\" >b<\/span>.  The returned value is <span class=\"code\" >a -. n *. b<\/span>, where <span class=\"code\" >n<\/span> is the quotient <span class=\"code\" >a \/. b<\/span> rounded towards zero to an integer."}, "type": "float -> float -> float", "params": [{"name": "", "type": "float"}, {"name": "", "type": "float"}]}}, {"value": {"name": "Pervasives.frexp", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|13098"}, "info": {"description": "<span class=\"code\" >frexp f<\/span> returns the pair of the significant and the exponent of <span class=\"code\" >f<\/span>.  When <span class=\"code\" >f<\/span> is zero, the significant <span class=\"code\" >x<\/span> and the exponent <span class=\"code\" >n<\/span> of <span class=\"code\" >f<\/span> are equal to zero.  When <span class=\"code\" >f<\/span> is non-zero, they are defined by <span class=\"code\" >f = x *. 2 ** n<\/span> and <span class=\"code\" >0.5 &lt;= x &lt; 1.0<\/span>."}, "type": "float -> float * int", "params": [{"name": "", "type": "float"}]}}, {"value": {"name": "Pervasives.ldexp", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|13417"}, "info": {"description": "<span class=\"code\" >ldexp x n<\/span> returns <span class=\"code\" >x *. 2 ** n<\/span>."}, "type": "float -> int -> float", "params": [{"name": "", "type": "float"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Pervasives.modf", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|13520"}, "info": {"description": "<span class=\"code\" >modf f<\/span> returns the pair of the fractional and integral part of <span class=\"code\" >f<\/span>."}, "type": "float -> float * float", "params": [{"name": "", "type": "float"}]}}, {"value": {"name": "Pervasives.float", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|13660"}, "info": {"description": "Same as <a href=\"{value|Pervasives.float_of_int}\" ><span class=\"code\" >Pervasives.float_of_int<\/span><\/a>."}, "type": "int -> float", "params": [{"name": "", "type": "int"}]}}, {"value": {"name": "Pervasives.float_of_int", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|13750"}, "info": {"description": "Convert an integer to floating-point."}, "type": "int -> float", "params": [{"name": "", "type": "int"}]}}, {"value": {"name": "Pervasives.truncate", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|13849"}, "info": {"description": "Same as <a href=\"{value|Pervasives.int_of_float}\" ><span class=\"code\" >Pervasives.int_of_float<\/span><\/a>."}, "type": "float -> int", "params": [{"name": "", "type": "float"}]}}, {"value": {"name": "Pervasives.int_of_float", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|13942"}, "info": {"description": "Truncate the given floating-point number to an integer. The result is unspecified if the argument is <span class=\"code\" >nan<\/span> or falls outside the range of representable integers."}, "type": "float -> int", "params": [{"name": "", "type": "float"}]}}, {"value": {"name": "Pervasives.infinity", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|14170"}, "info": {"description": "Positive infinity."}, "type": "float", "params": []}}, {"value": {"name": "Pervasives.neg_infinity", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|14218"}, "info": {"description": "Negative infinity."}, "type": "float", "params": []}}, {"value": {"name": "Pervasives.nan", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|14270"}, "info": {"description": "A special floating-point value denoting the result of an undefined operation such as <span class=\"code\" >0.0 \/. 0.0<\/span>.  Stands for ``not a number''.  Any floating-point operation with <span class=\"code\" >nan<\/span> as argument returns <span class=\"code\" >nan<\/span> as result.  As for floating-point comparisons, <span class=\"code\" >=<\/span>, <span class=\"code\" >&lt;<\/span>, <span class=\"code\" >&lt;=<\/span>, <span class=\"code\" >&gt;<\/span> and <span class=\"code\" >&gt;=<\/span> return <span class=\"code\" >false<\/span> and <span class=\"code\" >&lt;&gt;<\/span> returns <span class=\"code\" >true<\/span> if one or both of their arguments is <span class=\"code\" >nan<\/span>."}, "type": "float", "params": []}}, {"value": {"name": "Pervasives.max_float", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|14664"}, "info": {"description": "The largest positive finite value of type <span class=\"code\" >float<\/span>."}, "type": "float", "params": []}}, {"value": {"name": "Pervasives.min_float", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|14745"}, "info": {"description": "The smallest positive, non-zero, non-denormalized value of type <span class=\"code\" >float<\/span>."}, "type": "float", "params": []}}, {"value": {"name": "Pervasives.epsilon_float", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|14848"}, "info": {"description": "The difference between <span class=\"code\" >1.0<\/span> and the smallest exactly representable floating-point number greater than <span class=\"code\" >1.0<\/span>."}, "type": "float", "params": []}}, {"type": {"name": "Pervasives.fpclass", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|15001"}, "info": {"description": "The five classes of floating-point numbers, as determined by the <a href=\"{value|Pervasives.classify_float}\" ><span class=\"code\" >Pervasives.classify_float<\/span><\/a> function."}, "params": [], "kind": {"type": "variant", "private": "false", "constructors": [{"name": "FP_normal", "description": "Normal number, none of the below", "type": []}, {"name": "FP_subnormal", "description": "Number very close to 0.0, has reduced precision", "type": []}, {"name": "FP_zero", "description": "Number is 0.0 or -0.0", "type": []}, {"name": "FP_infinite", "description": "Number is positive or negative infinity", "type": []}, {"name": "FP_nan", "description": "Not a number: result of an undefined operation", "type": []}]}}}, {"value": {"name": "Pervasives.classify_float", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|15471"}, "info": {"description": "Return the class of the given floating-point number: normal, subnormal, zero, infinite, or not a number."}, "type": "float -> Pervasives.fpclass", "params": [{"name": "", "type": "float"}]}}, {"comment": "<h6>String operations<\/h6><br><\/br> More string operations are provided in module <a href=\"{module|String}\" ><span class=\"code\" >String<\/span><\/a>."}, {"value": {"name": "Pervasives.(^)", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|15746"}, "info": {"description": "String concatenation."}, "type": "string -> string -> string", "params": [{"name": "", "type": "string"}, {"name": "", "type": "string"}]}}, {"comment": "<h6>Character operations<\/h6><br><\/br> More character operations are provided in module <a href=\"{module|Char}\" ><span class=\"code\" >Char<\/span><\/a>."}, {"value": {"name": "Pervasives.int_of_char", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|15911"}, "info": {"description": "Return the ASCII code of the argument."}, "type": "char -> int", "params": [{"name": "", "type": "char"}]}}, {"value": {"name": "Pervasives.char_of_int", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|16007"}, "info": {"description": "Return the character with the given ASCII code. Raise <span class=\"code\" >Invalid_argument \"char_of_int\"<\/span> if the argument is outside the range 0--255."}, "type": "int -> char", "params": [{"name": "", "type": "int"}]}}, {"comment": "<h6>Unit operations<\/h6>"}, {"value": {"name": "Pervasives.ignore", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|16212"}, "info": {"description": "Discard the value of its argument and return <span class=\"code\" >()<\/span>. For instance, <span class=\"code\" >ignore(f x)<\/span> discards the result of the side-effecting function <span class=\"code\" >f<\/span>.  It is equivalent to <span class=\"code\" >f x; ()<\/span>, except that the latter may generate a compiler warning; writing <span class=\"code\" >ignore(f x)<\/span> instead avoids the warning."}, "type": "'a -> unit", "params": [{"name": "", "type": "'a"}]}}, {"comment": "<h6>String conversion functions<\/h6>"}, {"value": {"name": "Pervasives.string_of_bool", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|16590"}, "info": {"description": "Return the string representation of a boolean."}, "type": "bool -> string", "params": [{"name": "", "type": "bool"}]}}, {"value": {"name": "Pervasives.bool_of_string", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|16681"}, "info": {"description": "Convert the given string to a boolean. Raise <span class=\"code\" >Invalid_argument \"bool_of_string\"<\/span> if the string is not <span class=\"code\" >\"true\"<\/span> or <span class=\"code\" >\"false\"<\/span>."}, "type": "string -> bool", "params": [{"name": "", "type": "string"}]}}, {"value": {"name": "Pervasives.string_of_int", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|16856"}, "info": {"description": "Return the string representation of an integer, in decimal."}, "type": "int -> string", "params": [{"name": "", "type": "int"}]}}, {"value": {"name": "Pervasives.int_of_string", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|16958"}, "info": {"description": "Convert the given string to an integer. The string is read in decimal (by default) or in hexadecimal (if it begins with <span class=\"code\" >0x<\/span> or <span class=\"code\" >0X<\/span>), octal (if it begins with <span class=\"code\" >0o<\/span> or <span class=\"code\" >0O<\/span>), or binary (if it begins with <span class=\"code\" >0b<\/span> or <span class=\"code\" >0B<\/span>). Raise <span class=\"code\" >Failure \"int_of_string\"<\/span> if the given string is not a valid representation of an integer, or if the integer represented exceeds the range of integers representable in type <span class=\"code\" >int<\/span>."}, "type": "string -> int", "params": [{"name": "", "type": "string"}]}}, {"value": {"name": "Pervasives.string_of_float", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|17451"}, "info": {"description": "Return the string representation of a floating-point number."}, "type": "float -> string", "params": [{"name": "", "type": "float"}]}}, {"value": {"name": "Pervasives.float_of_string", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|17558"}, "info": {"description": "Convert the given string to a float.  Raise <span class=\"code\" >Failure \"float_of_string\"<\/span> if the given string is not a valid representation of a float."}, "type": "string -> float", "params": [{"name": "", "type": "string"}]}}, {"comment": "<h6>Pair operations<\/h6>"}, {"value": {"name": "Pervasives.fst", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|17800"}, "info": {"description": "Return the first component of a pair."}, "type": "'a * 'b -> 'a", "params": [{"tuple": {"type": "'a * 'b", "contents": [{"name": "", "type": "'a"}, {"name": "", "type": "'a"}]}}]}}, {"value": {"name": "Pervasives.snd", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|17887"}, "info": {"description": "Return the second component of a pair."}, "type": "'a * 'b -> 'b", "params": [{"tuple": {"type": "'a * 'b", "contents": [{"name": "", "type": "'a"}, {"name": "", "type": "'a"}]}}]}}, {"comment": "<h6>List operations<\/h6><br><\/br> More list operations are provided in module <a href=\"{module|List}\" ><span class=\"code\" >List<\/span><\/a>."}, {"value": {"name": "Pervasives.(@)", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|18061"}, "info": {"description": "List concatenation."}, "type": "'a list -> 'a list -> 'a list", "params": [{"name": "", "type": "'a list"}, {"name": "", "type": "'a list"}]}}, {"comment": "<h6>Input\/output<\/h6>"}, {"type": {"name": "Pervasives.in_channel", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|18162"}, "info": {"description": "The type of input channel."}, "params": [], "kind": {"type": "abstract"}}}, {"type": {"name": "Pervasives.out_channel", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|18213"}, "info": {"description": "The type of output channel."}, "params": [], "kind": {"type": "abstract"}}}, {"value": {"name": "Pervasives.stdin", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|18261"}, "info": {"description": "The standard input for the process."}, "type": "Pervasives.in_channel", "params": []}}, {"value": {"name": "Pervasives.stdout", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|18328"}, "info": {"description": "The standard output for the process."}, "type": "Pervasives.out_channel", "params": []}}, {"value": {"name": "Pervasives.stderr", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|18398"}, "info": {"description": "The standard error ouput for the process."}, "type": "Pervasives.out_channel", "params": []}}, {"comment": "<h7>Output functions on standard output<\/h7>"}, {"value": {"name": "Pervasives.print_char", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|18522"}, "info": {"description": "Print a character on standard output."}, "type": "char -> unit", "params": [{"name": "", "type": "char"}]}}, {"value": {"name": "Pervasives.print_string", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|18598"}, "info": {"description": "Print a string on standard output."}, "type": "string -> unit", "params": [{"name": "", "type": "string"}]}}, {"value": {"name": "Pervasives.print_int", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|18675"}, "info": {"description": "Print an integer, in decimal, on standard output."}, "type": "int -> unit", "params": [{"name": "", "type": "int"}]}}, {"value": {"name": "Pervasives.print_float", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|18761"}, "info": {"description": "Print a floating-point number, in decimal, on standard output."}, "type": "float -> unit", "params": [{"name": "", "type": "float"}]}}, {"value": {"name": "Pervasives.print_endline", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|18864"}, "info": {"description": "Print a string, followed by a newline character, on standard output and flush standard output."}, "type": "string -> unit", "params": [{"name": "", "type": "string"}]}}, {"value": {"name": "Pervasives.print_newline", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|19005"}, "info": {"description": "Print a newline character on standard output, and flush standard output. This can be used to simulate line buffering of standard output."}, "type": "unit -> unit", "params": [{"name": "", "type": "unit"}]}}, {"comment": "<h7>Output functions on standard error<\/h7>"}, {"value": {"name": "Pervasives.prerr_char", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|19237"}, "info": {"description": "Print a character on standard error."}, "type": "char -> unit", "params": [{"name": "", "type": "char"}]}}, {"value": {"name": "Pervasives.prerr_string", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|19312"}, "info": {"description": "Print a string on standard error."}, "type": "string -> unit", "params": [{"name": "", "type": "string"}]}}, {"value": {"name": "Pervasives.prerr_int", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|19388"}, "info": {"description": "Print an integer, in decimal, on standard error."}, "type": "int -> unit", "params": [{"name": "", "type": "int"}]}}, {"value": {"name": "Pervasives.prerr_float", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|19473"}, "info": {"description": "Print a floating-point number, in decimal, on standard error."}, "type": "float -> unit", "params": [{"name": "", "type": "float"}]}}, {"value": {"name": "Pervasives.prerr_endline", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|19575"}, "info": {"description": "Print a string, followed by a newline character on standard error and flush standard error."}, "type": "string -> unit", "params": [{"name": "", "type": "string"}]}}, {"value": {"name": "Pervasives.prerr_newline", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|19713"}, "info": {"description": "Print a newline character on standard error, and flush standard error."}, "type": "unit -> unit", "params": [{"name": "", "type": "unit"}]}}, {"comment": "<h7>Input functions on standard input<\/h7>"}, {"value": {"name": "Pervasives.read_line", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|19875"}, "info": {"description": "Flush standard output, then read characters from standard input until a newline character is encountered. Return the string of all characters read, without the newline character at the end."}, "type": "unit -> string", "params": [{"name": "", "type": "unit"}]}}, {"value": {"name": "Pervasives.read_int", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|20110"}, "info": {"description": "Flush standard output, then read one line from standard input and convert it to an integer. Raise <span class=\"code\" >Failure \"int_of_string\"<\/span> if the line read is not a valid representation of an integer."}, "type": "unit -> int", "params": [{"name": "", "type": "unit"}]}}, {"value": {"name": "Pervasives.read_float", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|20337"}, "info": {"description": "Flush standard output, then read one line from standard input and convert it to a floating-point number. The result is unspecified if the line read is not a valid representation of a floating-point number."}, "type": "unit -> float", "params": [{"name": "", "type": "unit"}]}}, {"comment": "<h7>General output functions<\/h7>"}, {"type": {"name": "Pervasives.open_flag", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|20634"}, "info": {"description": "Opening modes for <a href=\"{value|Pervasives.open_out_gen}\" ><span class=\"code\" >Pervasives.open_out_gen<\/span><\/a> and <a href=\"{value|Pervasives.open_in_gen}\" ><span class=\"code\" >Pervasives.open_in_gen<\/span><\/a>."}, "params": [], "kind": {"type": "variant", "private": "false", "constructors": [{"name": "Open_rdonly", "description": "open for reading.", "type": []}, {"name": "Open_wronly", "description": "open for writing.", "type": []}, {"name": "Open_append", "description": "open for appending: always write at end of file.", "type": []}, {"name": "Open_creat", "description": "create the file if it does not exist.", "type": []}, {"name": "Open_trunc", "description": "empty the file if it already exists.", "type": []}, {"name": "Open_excl", "description": "fail if Open_creat and the file already exists.", "type": []}, {"name": "Open_binary", "description": "open in binary mode (no conversion).", "type": []}, {"name": "Open_text", "description": "open in text mode (may perform conversions).", "type": []}, {"name": "Open_nonblock", "description": "open in non-blocking mode.", "type": []}]}}}, {"value": {"name": "Pervasives.open_out", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|21301"}, "info": {"description": "Open the named file for writing, and return a new output channel on that file, positionned at the beginning of the file. The file is truncated to zero length if it already exists. It is created if it does not already exists. Raise <span class=\"code\" >Sys_error<\/span> if the file could not be opened."}, "type": "string -> Pervasives.out_channel", "params": [{"name": "", "type": "string"}]}}, {"value": {"name": "Pervasives.open_out_bin", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|21634"}, "info": {"description": "Same as <a href=\"{value|Pervasives.open_out}\" ><span class=\"code\" >Pervasives.open_out<\/span><\/a>, but the file is opened in binary mode, so that no translation takes place during writes. On operating systems that do not distinguish between text mode and binary mode, this function behaves like <a href=\"{value|Pervasives.open_out}\" ><span class=\"code\" >Pervasives.open_out<\/span><\/a>."}, "type": "string -> Pervasives.out_channel", "params": [{"name": "", "type": "string"}]}}, {"value": {"name": "Pervasives.open_out_gen", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|21944"}, "info": {"description": "<span class=\"code\" >open_out_gen mode perm filename<\/span> opens the named file for writing, as described above. The extra argument <span class=\"code\" >mode<\/span> specify the opening mode. The extra argument <span class=\"code\" >perm<\/span> specifies the file permissions, in case the file must be created. <a href=\"{value|Pervasives.open_out}\" ><span class=\"code\" >Pervasives.open_out<\/span><\/a> and <a href=\"{value|Pervasives.open_out_bin}\" ><span class=\"code\" >Pervasives.open_out_bin<\/span><\/a> are special cases of this function."}, "type": "Pervasives.open_flag list -> int -> string -> Pervasives.out_channel", "params": [{"name": "", "type": "Pervasives.open_flag list"}, {"name": "", "type": "int"}, {"name": "", "type": "string"}]}}, {"value": {"name": "Pervasives.flush", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|22355"}, "info": {"description": "Flush the buffer associated with the given output channel, performing all pending writes on that channel. Interactive programs must be careful about flushing standard output and standard error at the right time."}, "type": "Pervasives.out_channel -> unit", "params": [{"name": "", "type": "Pervasives.out_channel"}]}}, {"value": {"name": "Pervasives.flush_all", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|22616"}, "info": {"description": "Flush all open output channels; ignore errors."}, "type": "unit -> unit", "params": [{"name": "", "type": "unit"}]}}, {"value": {"name": "Pervasives.output_char", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|22700"}, "info": {"description": "Write the character on the given output channel."}, "type": "Pervasives.out_channel -> char -> unit", "params": [{"name": "", "type": "Pervasives.out_channel"}, {"name": "", "type": "char"}]}}, {"value": {"name": "Pervasives.output_string", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|22803"}, "info": {"description": "Write the string on the given output channel."}, "type": "Pervasives.out_channel -> string -> unit", "params": [{"name": "", "type": "Pervasives.out_channel"}, {"name": "", "type": "string"}]}}, {"value": {"name": "Pervasives.output", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|22907"}, "info": {"description": "<span class=\"code\" >output oc buf pos len<\/span> writes <span class=\"code\" >len<\/span> characters from string <span class=\"code\" >buf<\/span>, starting at offset <span class=\"code\" >pos<\/span>, to the given output channel <span class=\"code\" >oc<\/span>. Raise <span class=\"code\" >Invalid_argument \"output\"<\/span> if <span class=\"code\" >pos<\/span> and <span class=\"code\" >len<\/span> do not designate a valid substring of <span class=\"code\" >buf<\/span>."}, "type": "Pervasives.out_channel -> string -> int -> int -> unit", "params": [{"name": "", "type": "Pervasives.out_channel"}, {"name": "", "type": "string"}, {"name": "", "type": "int"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Pervasives.output_byte", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|23206"}, "info": {"description": "Write one 8-bit integer (as the single character with that code) on the given output channel. The given integer is taken modulo 256."}, "type": "Pervasives.out_channel -> int -> unit", "params": [{"name": "", "type": "Pervasives.out_channel"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Pervasives.output_binary_int", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|23398"}, "info": {"description": "Write one integer in binary format (4 bytes, big-endian) on the given output channel. The given integer is taken modulo 2<sup>32<\/sup>. The only reliable way to read it back is through the <a href=\"{value|Pervasives.input_binary_int}\" ><span class=\"code\" >Pervasives.input_binary_int<\/span><\/a> function. The format is compatible across all machines for a given version of Objective Caml."}, "type": "Pervasives.out_channel -> int -> unit", "params": [{"name": "", "type": "Pervasives.out_channel"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Pervasives.output_value", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|23778"}, "info": {"description": "Write the representation of a structured value of any type to a channel. Circularities and sharing inside the value are detected and preserved. The object can be read back, by the function <a href=\"{value|Pervasives.input_value}\" ><span class=\"code\" >Pervasives.input_value<\/span><\/a>. See the description of module <a href=\"{module|Marshal}\" ><span class=\"code\" >Marshal<\/span><\/a> for more information. <a href=\"{value|Pervasives.output_value}\" ><span class=\"code\" >Pervasives.output_value<\/span><\/a> is equivalent to <a href=\"{none|Marshal.to_channel}\" ><span class=\"code\" >Marshal.to_channel<\/span><\/a> with an empty list of flags."}, "type": "Pervasives.out_channel -> 'a -> unit", "params": [{"name": "", "type": "Pervasives.out_channel"}, {"name": "", "type": "'a"}]}}, {"value": {"name": "Pervasives.seek_out", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|24220"}, "info": {"description": "<span class=\"code\" >seek_out chan pos<\/span> sets the current writing position to <span class=\"code\" >pos<\/span> for channel <span class=\"code\" >chan<\/span>. This works only for regular files. On files of other kinds (such as terminals, pipes and sockets), the behavior is unspecified."}, "type": "Pervasives.out_channel -> int -> unit", "params": [{"name": "", "type": "Pervasives.out_channel"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Pervasives.pos_out", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|24490"}, "info": {"description": "Return the current writing position for the given channel.  Does not work on channels opened with the <span class=\"code\" >Open_append<\/span> flag (returns unspecified results)."}, "type": "Pervasives.out_channel -> int", "params": [{"name": "", "type": "Pervasives.out_channel"}]}}, {"value": {"name": "Pervasives.out_channel_length", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|24691"}, "info": {"description": "Return the size (number of characters) of the regular file on which the given channel is opened.  If the channel is opened on a file that is not a regular file, the result is meaningless."}, "type": "Pervasives.out_channel -> int", "params": [{"name": "", "type": "Pervasives.out_channel"}]}}, {"value": {"name": "Pervasives.close_out", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|24938"}, "info": {"description": "Close the given channel, flushing all buffered write operations. Output functions raise a <span class=\"code\" >Sys_error<\/span> exception when they are applied to a closed output channel, except <span class=\"code\" >close_out<\/span> and <span class=\"code\" >flush<\/span>, which do nothing when applied to an already closed channel. Note that <span class=\"code\" >close_out<\/span> may raise <span class=\"code\" >Sys_error<\/span> if the operating system signals an error when flushing or closing."}, "type": "Pervasives.out_channel -> unit", "params": [{"name": "", "type": "Pervasives.out_channel"}]}}, {"value": {"name": "Pervasives.close_out_noerr", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|25362"}, "info": {"description": "Same as <span class=\"code\" >close_out<\/span>, but ignore all errors."}, "type": "Pervasives.out_channel -> unit", "params": [{"name": "", "type": "Pervasives.out_channel"}]}}, {"value": {"name": "Pervasives.set_binary_mode_out", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|25456"}, "info": {"description": "<span class=\"code\" >set_binary_mode_out oc true<\/span> sets the channel <span class=\"code\" >oc<\/span> to binary mode: no translations take place during output. <span class=\"code\" >set_binary_mode_out oc false<\/span> sets the channel <span class=\"code\" >oc<\/span> to text mode: depending on the operating system, some translations may take place during output.  For instance, under Windows, end-of-lines will be translated from <span class=\"code\" >\\n<\/span> to <span class=\"code\" >\\r\\n<\/span>. This function has no effect under operating systems that do not distinguish between text mode and binary mode."}, "type": "Pervasives.out_channel -> bool -> unit", "params": [{"name": "", "type": "Pervasives.out_channel"}, {"name": "", "type": "bool"}]}}, {"comment": "<h7>General input functions<\/h7>"}, {"value": {"name": "Pervasives.open_in", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|26030"}, "info": {"description": "Open the named file for reading, and return a new input channel on that file, positionned at the beginning of the file. Raise <span class=\"code\" >Sys_error<\/span> if the file could not be opened."}, "type": "string -> Pervasives.in_channel", "params": [{"name": "", "type": "string"}]}}, {"value": {"name": "Pervasives.open_in_bin", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|26250"}, "info": {"description": "Same as <a href=\"{value|Pervasives.open_in}\" ><span class=\"code\" >Pervasives.open_in<\/span><\/a>, but the file is opened in binary mode, so that no translation takes place during reads. On operating systems that do not distinguish between text mode and binary mode, this function behaves like <a href=\"{value|Pervasives.open_in}\" ><span class=\"code\" >Pervasives.open_in<\/span><\/a>."}, "type": "string -> Pervasives.in_channel", "params": [{"name": "", "type": "string"}]}}, {"value": {"name": "Pervasives.open_in_gen", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|26555"}, "info": {"description": "<span class=\"code\" >open_in_gen mode perm filename<\/span> opens the named file for reading, as described above. The extra arguments <span class=\"code\" >mode<\/span> and <span class=\"code\" >perm<\/span> specify the opening mode and file permissions. <a href=\"{value|Pervasives.open_in}\" ><span class=\"code\" >Pervasives.open_in<\/span><\/a> and <a href=\"{value|Pervasives.open_in_bin}\" ><span class=\"code\" >Pervasives.open_in_bin<\/span><\/a> are special cases of this function."}, "type": "Pervasives.open_flag list -> int -> string -> Pervasives.in_channel", "params": [{"name": "", "type": "Pervasives.open_flag list"}, {"name": "", "type": "int"}, {"name": "", "type": "string"}]}}, {"value": {"name": "Pervasives.input_char", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|26899"}, "info": {"description": "Read one character from the given input channel. Raise <span class=\"code\" >End_of_file<\/span> if there are no more characters to read."}, "type": "Pervasives.in_channel -> char", "params": [{"name": "", "type": "Pervasives.in_channel"}]}}, {"value": {"name": "Pervasives.input_line", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|27056"}, "info": {"description": "Read characters from the given input channel, until a newline character is encountered. Return the string of all characters read, without the newline character at the end. Raise <span class=\"code\" >End_of_file<\/span> if the end of the file is reached at the beginning of line."}, "type": "Pervasives.in_channel -> string", "params": [{"name": "", "type": "Pervasives.in_channel"}]}}, {"value": {"name": "Pervasives.input", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|27366"}, "info": {"description": "<span class=\"code\" >input ic buf pos len<\/span> reads up to <span class=\"code\" >len<\/span> characters from the given channel <span class=\"code\" >ic<\/span>, storing them in string <span class=\"code\" >buf<\/span>, starting at character number <span class=\"code\" >pos<\/span>. It returns the actual number of characters read, between 0 and <span class=\"code\" >len<\/span> (inclusive). A return value of 0 means that the end of file was reached. A return value between 0 and <span class=\"code\" >len<\/span> exclusive means that not all requested <span class=\"code\" >len<\/span> characters were read, either because no more characters were available at that time, or because the implementation found it convenient to do a partial read; <span class=\"code\" >input<\/span> must be called again to read the remaining characters, if desired.  (See also <a href=\"{value|Pervasives.really_input}\" ><span class=\"code\" >Pervasives.really_input<\/span><\/a> for reading exactly <span class=\"code\" >len<\/span> characters.) Exception <span class=\"code\" >Invalid_argument \"input\"<\/span> is raised if <span class=\"code\" >pos<\/span> and <span class=\"code\" >len<\/span> do not designate a valid substring of <span class=\"code\" >buf<\/span>."}, "type": "Pervasives.in_channel -> string -> int -> int -> int", "params": [{"name": "", "type": "Pervasives.in_channel"}, {"name": "", "type": "string"}, {"name": "", "type": "int"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Pervasives.really_input", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|28259"}, "info": {"description": "<span class=\"code\" >really_input ic buf pos len<\/span> reads <span class=\"code\" >len<\/span> characters from channel <span class=\"code\" >ic<\/span>, storing them in string <span class=\"code\" >buf<\/span>, starting at character number <span class=\"code\" >pos<\/span>. Raise <span class=\"code\" >End_of_file<\/span> if the end of file is reached before <span class=\"code\" >len<\/span> characters have been read. Raise <span class=\"code\" >Invalid_argument \"really_input\"<\/span> if <span class=\"code\" >pos<\/span> and <span class=\"code\" >len<\/span> do not designate a valid substring of <span class=\"code\" >buf<\/span>."}, "type": "Pervasives.in_channel -> string -> int -> int -> unit", "params": [{"name": "", "type": "Pervasives.in_channel"}, {"name": "", "type": "string"}, {"name": "", "type": "int"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Pervasives.input_byte", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|28676"}, "info": {"description": "Same as <a href=\"{value|Pervasives.input_char}\" ><span class=\"code\" >Pervasives.input_char<\/span><\/a>, but return the 8-bit integer representing the character. Raise <span class=\"code\" >End_of_file<\/span> if an end of file was reached."}, "type": "Pervasives.in_channel -> int", "params": [{"name": "", "type": "Pervasives.in_channel"}]}}, {"value": {"name": "Pervasives.input_binary_int", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|28867"}, "info": {"description": "Read an integer encoded in binary format (4 bytes, big-endian) from the given input channel. See <a href=\"{value|Pervasives.output_binary_int}\" ><span class=\"code\" >Pervasives.output_binary_int<\/span><\/a>. Raise <span class=\"code\" >End_of_file<\/span> if an end of file was reached while reading the integer."}, "type": "Pervasives.in_channel -> int", "params": [{"name": "", "type": "Pervasives.in_channel"}]}}, {"value": {"name": "Pervasives.input_value", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|29132"}, "info": {"description": "Read the representation of a structured value, as produced by <a href=\"{value|Pervasives.output_value}\" ><span class=\"code\" >Pervasives.output_value<\/span><\/a>, and return the corresponding value. This function is identical to <a href=\"{none|Marshal.from_channel}\" ><span class=\"code\" >Marshal.from_channel<\/span><\/a>; see the description of module <a href=\"{module|Marshal}\" ><span class=\"code\" >Marshal<\/span><\/a> for more information, in particular concerning the lack of type safety."}, "type": "Pervasives.in_channel -> 'a", "params": [{"name": "", "type": "Pervasives.in_channel"}]}}, {"value": {"name": "Pervasives.seek_in", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|29481"}, "info": {"description": "<span class=\"code\" >seek_in chan pos<\/span> sets the current reading position to <span class=\"code\" >pos<\/span> for channel <span class=\"code\" >chan<\/span>. This works only for regular files. On files of other kinds, the behavior is unspecified."}, "type": "Pervasives.in_channel -> int -> unit", "params": [{"name": "", "type": "Pervasives.in_channel"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Pervasives.pos_in", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|29706"}, "info": {"description": "Return the current reading position for the given channel."}, "type": "Pervasives.in_channel -> int", "params": [{"name": "", "type": "Pervasives.in_channel"}]}}, {"value": {"name": "Pervasives.in_channel_length", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|29804"}, "info": {"description": "Return the size (number of characters) of the regular file on which the given channel is opened.  If the channel is opened on a file that is not a regular file, the result is meaningless. The returned size does not take into account the end-of-line translations that can be performed when reading from a channel opened in text mode."}, "type": "Pervasives.in_channel -> int", "params": [{"name": "", "type": "Pervasives.in_channel"}]}}, {"value": {"name": "Pervasives.close_in", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|30207"}, "info": {"description": "Close the given channel.  Input functions raise a <span class=\"code\" >Sys_error<\/span> exception when they are applied to a closed input channel, except <span class=\"code\" >close_in<\/span>, which does nothing when applied to an already closed channel.  Note that <span class=\"code\" >close_in<\/span> may raise <span class=\"code\" >Sys_error<\/span> if the operating system signals an error."}, "type": "Pervasives.in_channel -> unit", "params": [{"name": "", "type": "Pervasives.in_channel"}]}}, {"value": {"name": "Pervasives.close_in_noerr", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|30545"}, "info": {"description": "Same as <span class=\"code\" >close_in<\/span>, but ignore all errors."}, "type": "Pervasives.in_channel -> unit", "params": [{"name": "", "type": "Pervasives.in_channel"}]}}, {"value": {"name": "Pervasives.set_binary_mode_in", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|30636"}, "info": {"description": "<span class=\"code\" >set_binary_mode_in ic true<\/span> sets the channel <span class=\"code\" >ic<\/span> to binary mode: no translations take place during input. <span class=\"code\" >set_binary_mode_out ic false<\/span> sets the channel <span class=\"code\" >ic<\/span> to text mode: depending on the operating system, some translations may take place during input.  For instance, under Windows, end-of-lines will be translated from <span class=\"code\" >\\r\\n<\/span> to <span class=\"code\" >\\n<\/span>. This function has no effect under operating systems that do not distinguish between text mode and binary mode."}, "type": "Pervasives.in_channel -> bool -> unit", "params": [{"name": "", "type": "Pervasives.in_channel"}, {"name": "", "type": "bool"}]}}, {"comment": "<h7>Operations on large files<\/h7>"}, {"module": {"name": "Pervasives.LargeFile", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|31207"}, "info": {"description": "Operations on large files. This sub-module provides 64-bit variants of the channel functions that manipulate file positions and file sizes.  By representing positions and sizes by 64-bit integers (type <span class=\"code\" >int64<\/span>) instead of regular integers (type <span class=\"code\" >int<\/span>), these alternate functions allow operating on files whose sizes are greater than <span class=\"code\" >max_int<\/span>."}, "type": "sig  end", "module_structure": [{"value": {"name": "Pervasives.LargeFile.seek_out", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|31236"}, "info": "", "type": "Pervasives.out_channel -> int64 -> unit", "params": [{"name": "", "type": "Pervasives.out_channel"}, {"name": "", "type": "int64"}]}}, {"value": {"name": "Pervasives.LargeFile.pos_out", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|31284"}, "info": "", "type": "Pervasives.out_channel -> int64", "params": [{"name": "", "type": "Pervasives.out_channel"}]}}, {"value": {"name": "Pervasives.LargeFile.out_channel_length", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|31323"}, "info": "", "type": "Pervasives.out_channel -> int64", "params": [{"name": "", "type": "Pervasives.out_channel"}]}}, {"value": {"name": "Pervasives.LargeFile.seek_in", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|31373"}, "info": "", "type": "Pervasives.in_channel -> int64 -> unit", "params": [{"name": "", "type": "Pervasives.in_channel"}, {"name": "", "type": "int64"}]}}, {"value": {"name": "Pervasives.LargeFile.pos_in", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|31419"}, "info": "", "type": "Pervasives.in_channel -> int64", "params": [{"name": "", "type": "Pervasives.in_channel"}]}}, {"value": {"name": "Pervasives.LargeFile.in_channel_length", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|31456"}, "info": "", "type": "Pervasives.in_channel -> int64", "params": [{"name": "", "type": "Pervasives.in_channel"}]}}], "dependencies": {"uses": []}}}, {"comment": "<h6>References<\/h6>"}, {"type": {"name": "Pervasives.ref", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|31896"}, "info": {"description": "The type of references (mutable indirection cells) containing a value of type <span class=\"code\" >'a<\/span>."}, "params": [{"covariant": "true", "contravariant": "true", "type": "'a"}], "kind": {"type": "record", "private": "false", "fields": [{"name": "contents", "mutable": true, "type": "'a"}]}}}, {"value": {"name": "Pervasives.ref", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|32027"}, "info": {"description": "Return a fresh reference containing the given value."}, "type": "'a -> 'a Pervasives.ref", "params": [{"name": "", "type": "'a"}]}}, {"value": {"name": "Pervasives.(!)", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|32133"}, "info": {"description": "<span class=\"code\" >!r<\/span> returns the current contents of reference <span class=\"code\" >r<\/span>. Equivalent to <span class=\"code\" >fun r -&gt; r.contents<\/span>."}, "type": "'a Pervasives.ref -> 'a", "params": [{"name": "", "type": "'a Pervasives.ref"}]}}, {"value": {"name": "Pervasives.(:=)", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|32275"}, "info": {"description": "<span class=\"code\" >r := a<\/span> stores the value of <span class=\"code\" >a<\/span> in reference <span class=\"code\" >r<\/span>. Equivalent to <span class=\"code\" >fun r v -&gt; r.contents &lt;- v<\/span>."}, "type": "'a Pervasives.ref -> 'a -> unit", "params": [{"name": "", "type": "'a Pervasives.ref"}, {"name": "", "type": "'a"}]}}, {"value": {"name": "Pervasives.incr", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|32435"}, "info": {"description": "Increment the integer contained in the given reference. Equivalent to <span class=\"code\" >fun r -&gt; r := succ !r<\/span>."}, "type": "int Pervasives.ref -> unit", "params": [{"name": "", "type": "int Pervasives.ref"}]}}, {"value": {"name": "Pervasives.decr", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|32583"}, "info": {"description": "Decrement the integer contained in the given reference. Equivalent to <span class=\"code\" >fun r -&gt; r := pred !r<\/span>."}, "type": "int Pervasives.ref -> unit", "params": [{"name": "", "type": "int Pervasives.ref"}]}}, {"comment": "<h6>Operations on format strings<\/h6>"}, {"comment": "Format strings are used to read and print data using formatted input functions in module <a href=\"{module|Scanf}\" ><span class=\"code\" >Scanf<\/span><\/a> and formatted output in modules <a href=\"{module|Printf}\" ><span class=\"code\" >Printf<\/span><\/a> and <a href=\"{module|Format}\" ><span class=\"code\" >Format<\/span><\/a>."}, {"type": {"name": "Pervasives.format4", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|33439"}, "info": {"description": "Format strings have a general and highly polymorphic type <span class=\"code\" >('a, 'b, 'c, 'd, 'e, 'f) format6<\/span>. Type <span class=\"code\" >format6<\/span> is built in. The two simplified types, <span class=\"code\" >format<\/span> and <span class=\"code\" >format4<\/span> below are included for backward compatibility with earlier releases of Objective Caml. <span class=\"code\" >'a<\/span> is the type of the parameters of the format, <span class=\"code\" >'c<\/span> is the result type for the \"printf\"-style function, and <span class=\"code\" >'b<\/span> is the type of the first argument given to <span class=\"code\" >%a<\/span> and <span class=\"code\" >%t<\/span> printing functions."}, "params": [{"covariant": "true", "contravariant": "true", "type": "'a"}, {"covariant": "true", "contravariant": "true", "type": "'b"}, {"covariant": "true", "contravariant": "true", "type": "'c"}, {"covariant": "true", "contravariant": "true", "type": "'d"}], "kind": {"type": "abstract"}, "manifest": "('a, 'b, 'c, 'c, 'c, 'd) format6"}}, {"type": {"name": "Pervasives.format", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|33505"}, "info": "", "params": [{"covariant": "true", "contravariant": "true", "type": "'e"}, {"covariant": "true", "contravariant": "true", "type": "'f"}, {"covariant": "true", "contravariant": "true", "type": "'g"}], "kind": {"type": "abstract"}, "manifest": "('a, 'b, 'c, 'c) Pervasives.format4"}}, {"value": {"name": "Pervasives.string_of_format", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|33553"}, "info": {"description": "Converts a format string into a string."}, "type": "('a, 'b, 'c, 'd, 'e, 'f) format6 -> string", "params": [{"name": "", "type": "('a, 'b, 'c, 'd, 'e, 'f) format6"}]}}, {"value": {"name": "Pervasives.format_of_string", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|33667"}, "info": {"description": "<span class=\"code\" >format_of_string s<\/span> returns a format string read from the string literal <span class=\"code\" >s<\/span>."}, "type": "('a, 'b, 'c, 'd, 'e, 'f) format6 -> ('a, 'b, 'c, 'd, 'e, 'f) format6", "params": [{"name": "", "type": "('a, 'b, 'c, 'd, 'e, 'f) format6"}]}}, {"value": {"name": "Pervasives.(^^)", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|33873"}, "info": {"description": "<span class=\"code\" >f1 ^^ f2<\/span> catenates formats <span class=\"code\" >f1<\/span> and <span class=\"code\" >f2<\/span>.  The result is a format that accepts arguments from <span class=\"code\" >f1<\/span>, then arguments from <span class=\"code\" >f2<\/span>."}, "type": "('a, 'b, 'c, 'd, 'e, 'f) format6 ->\n  ('f, 'b, 'c, 'e, 'g, 'h) format6 -> ('a, 'b, 'c, 'd, 'g, 'h) format6", "params": [{"name": "", "type": "('a, 'b, 'c, 'd, 'e, 'f) format6"}, {"name": "", "type": "('a, 'b, 'c, 'd, 'e, 'f) format6"}]}}, {"comment": "<h6>Program termination<\/h6>"}, {"value": {"name": "Pervasives.exit", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|34180"}, "info": {"description": "Terminate the process, returning the given status code to the operating system: usually 0 to indicate no errors, and a small positive integer to indicate failure. All open output channels are flushed with flush_all. An implicit <span class=\"code\" >exit 0<\/span> is performed each time a program terminates normally.  An implicit <span class=\"code\" >exit 2<\/span> is performed if the program terminates early because of an uncaught exception."}, "type": "int -> 'a", "params": [{"name": "", "type": "int"}]}}, {"value": {"name": "Pervasives.at_exit", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/pervasives.mli|34619"}, "info": {"description": "Register the given function to be called at program termination time. The functions registered with <span class=\"code\" >at_exit<\/span> will be called when the program executes <a href=\"{value|Pervasives.exit}\" ><span class=\"code\" >Pervasives.exit<\/span><\/a>, or terminates, either normally or because of an uncaught exception. The functions are called in ``last in, first out'' order: the function most recently added with <span class=\"code\" >at_exit<\/span> is called first."}, "type": "(unit -> unit) -> unit", "params": [{"name": "", "type": "unit -> unit"}]}}], "dependencies": {"uses": [], "used_by": ["Sys", "Scanf", "Format", "Printf"]}}}, "Nativeint": {"module": {"name": "Nativeint", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/nativeint.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/nativeint.mli|0"}, "info": {"description": "Processor-native integers.<br><\/br> This module provides operations on the type <span class=\"code\" >nativeint<\/span> of signed 32-bit integers (on 32-bit platforms) or signed 64-bit integers (on 64-bit platforms). This integer type has exactly the same width as that of a <span class=\"code\" >long<\/span> integer type in the C compiler.  All arithmetic operations over <span class=\"code\" >nativeint<\/span> are taken modulo 2<sup>32<\/sup> or 2<sup>64<\/sup> depending on the word size of the architecture.<br><\/br> Performance notice: values of type <span class=\"code\" >nativeint<\/span> occupy more memory space than values of type <span class=\"code\" >int<\/span>, and arithmetic operations on <span class=\"code\" >nativeint<\/span> are generally slower than those on <span class=\"code\" >int<\/span>.  Use <span class=\"code\" >nativeint<\/span> only when the application requires the extra bit of precision over the <span class=\"code\" >int<\/span> type."}, "type": "sig  end", "module_structure": [{"value": {"name": "Nativeint.zero", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/nativeint.mli|1682"}, "info": {"description": "The native integer 0."}, "type": "nativeint", "params": []}}, {"value": {"name": "Nativeint.one", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/nativeint.mli|1732"}, "info": {"description": "The native integer 1."}, "type": "nativeint", "params": []}}, {"value": {"name": "Nativeint.minus_one", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/nativeint.mli|1781"}, "info": {"description": "The native integer -1."}, "type": "nativeint", "params": []}}, {"value": {"name": "Nativeint.neg", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/nativeint.mli|1837"}, "info": {"description": "Unary negation."}, "type": "nativeint -> nativeint", "params": [{"name": "", "type": "nativeint"}]}}, {"value": {"name": "Nativeint.add", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/nativeint.mli|1918"}, "info": {"description": "Addition."}, "type": "nativeint -> nativeint -> nativeint", "params": [{"name": "", "type": "nativeint"}, {"name": "", "type": "nativeint"}]}}, {"value": {"name": "Nativeint.sub", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/nativeint.mli|2006"}, "info": {"description": "Subtraction."}, "type": "nativeint -> nativeint -> nativeint", "params": [{"name": "", "type": "nativeint"}, {"name": "", "type": "nativeint"}]}}, {"value": {"name": "Nativeint.mul", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/nativeint.mli|2097"}, "info": {"description": "Multiplication."}, "type": "nativeint -> nativeint -> nativeint", "params": [{"name": "", "type": "nativeint"}, {"name": "", "type": "nativeint"}]}}, {"value": {"name": "Nativeint.div", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/nativeint.mli|2191"}, "info": {"description": "Integer division.  Raise <span class=\"code\" >Division_by_zero<\/span> if the second argument is zero.  This division rounds the real quotient of its arguments towards zero, as specified for <a href=\"{value|Pervasives.(\/)}\" ><span class=\"code\" >Pervasives.(\/)<\/span><\/a>."}, "type": "nativeint -> nativeint -> nativeint", "params": [{"name": "", "type": "nativeint"}, {"name": "", "type": "nativeint"}]}}, {"value": {"name": "Nativeint.rem", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/nativeint.mli|2458"}, "info": {"description": "Integer remainder.  If <span class=\"code\" >y<\/span> is not zero, the result of <span class=\"code\" >Nativeint.rem x y<\/span> satisfies the following properties: <span class=\"code\" >Nativeint.zero &lt;= Nativeint.rem x y &lt; Nativeint.abs y<\/span> and <span class=\"code\" >x = Nativeint.add (Nativeint.mul (Nativeint.div x y) y) (Nativeint.rem x y)<\/span>. If <span class=\"code\" >y = 0<\/span>, <span class=\"code\" >Nativeint.rem x y<\/span> raises <span class=\"code\" >Division_by_zero<\/span>."}, "type": "nativeint -> nativeint -> nativeint", "params": [{"name": "", "type": "nativeint"}, {"name": "", "type": "nativeint"}]}}, {"value": {"name": "Nativeint.succ", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/nativeint.mli|2856"}, "info": {"description": "Successor. <span class=\"code\" >Nativeint.succ x<\/span> is <span class=\"code\" >Nativeint.add x Nativeint.one<\/span>."}, "type": "nativeint -> nativeint", "params": [{"name": "", "type": "nativeint"}]}}, {"value": {"name": "Nativeint.pred", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/nativeint.mli|2967"}, "info": {"description": "Predecessor. <span class=\"code\" >Nativeint.pred x<\/span> is <span class=\"code\" >Nativeint.sub x Nativeint.one<\/span>."}, "type": "nativeint -> nativeint", "params": [{"name": "", "type": "nativeint"}]}}, {"value": {"name": "Nativeint.abs", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/nativeint.mli|3080"}, "info": {"description": "Return the absolute value of its argument."}, "type": "nativeint -> nativeint", "params": [{"name": "", "type": "nativeint"}]}}, {"value": {"name": "Nativeint.size", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/nativeint.mli|3164"}, "info": {"description": "The size in bits of a native integer.  This is equal to <span class=\"code\" >32<\/span> on a 32-bit platform and to <span class=\"code\" >64<\/span> on a 64-bit platform."}, "type": "int", "params": []}}, {"value": {"name": "Nativeint.max_int", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/nativeint.mli|3306"}, "info": {"description": "The greatest representable native integer, either 2<sup>31<\/sup> - 1 on a 32-bit platform, or 2<sup>63<\/sup> - 1 on a 64-bit platform."}, "type": "nativeint", "params": []}}, {"value": {"name": "Nativeint.min_int", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/nativeint.mli|3463"}, "info": {"description": "The greatest representable native integer, either -2<sup>31<\/sup> on a 32-bit platform, or -2<sup>63<\/sup> on a 64-bit platform."}, "type": "nativeint", "params": []}}, {"value": {"name": "Nativeint.logand", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/nativeint.mli|3614"}, "info": {"description": "Bitwise logical and."}, "type": "nativeint -> nativeint -> nativeint", "params": [{"name": "", "type": "nativeint"}, {"name": "", "type": "nativeint"}]}}, {"value": {"name": "Nativeint.logor", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/nativeint.mli|3716"}, "info": {"description": "Bitwise logical or."}, "type": "nativeint -> nativeint -> nativeint", "params": [{"name": "", "type": "nativeint"}, {"name": "", "type": "nativeint"}]}}, {"value": {"name": "Nativeint.logxor", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/nativeint.mli|3815"}, "info": {"description": "Bitwise logical exclusive or."}, "type": "nativeint -> nativeint -> nativeint", "params": [{"name": "", "type": "nativeint"}, {"name": "", "type": "nativeint"}]}}, {"value": {"name": "Nativeint.lognot", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/nativeint.mli|3926"}, "info": {"description": "Bitwise logical negation"}, "type": "nativeint -> nativeint", "params": [{"name": "", "type": "nativeint"}]}}, {"value": {"name": "Nativeint.shift_left", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/nativeint.mli|3995"}, "info": {"description": "<span class=\"code\" >Nativeint.shift_left x y<\/span> shifts <span class=\"code\" >x<\/span> to the left by <span class=\"code\" >y<\/span> bits. The result is unspecified if <span class=\"code\" >y &lt; 0<\/span> or <span class=\"code\" >y &gt;= bitsize<\/span>, where <span class=\"code\" >bitsize<\/span> is <span class=\"code\" >32<\/span> on a 32-bit platform and <span class=\"code\" >64<\/span> on a 64-bit platform."}, "type": "nativeint -> int -> nativeint", "params": [{"name": "", "type": "nativeint"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Nativeint.shift_right", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/nativeint.mli|4278"}, "info": {"description": "<span class=\"code\" >Nativeint.shift_right x y<\/span> shifts <span class=\"code\" >x<\/span> to the right by <span class=\"code\" >y<\/span> bits. This is an arithmetic shift: the sign bit of <span class=\"code\" >x<\/span> is replicated and inserted in the vacated bits. The result is unspecified if <span class=\"code\" >y &lt; 0<\/span> or <span class=\"code\" >y &gt;= bitsize<\/span>."}, "type": "nativeint -> int -> nativeint", "params": [{"name": "", "type": "nativeint"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Nativeint.shift_right_logical", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/nativeint.mli|4585"}, "info": {"description": "<span class=\"code\" >Nativeint.shift_right_logical x y<\/span> shifts <span class=\"code\" >x<\/span> to the right by <span class=\"code\" >y<\/span> bits. This is a logical shift: zeroes are inserted in the vacated bits regardless of the sign of <span class=\"code\" >x<\/span>. The result is unspecified if <span class=\"code\" >y &lt; 0<\/span> or <span class=\"code\" >y &gt;= bitsize<\/span>."}, "type": "nativeint -> int -> nativeint", "params": [{"name": "", "type": "nativeint"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Nativeint.of_int", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/nativeint.mli|4913"}, "info": {"description": "Convert the given integer (type <span class=\"code\" >int<\/span>) to a native integer (type <span class=\"code\" >nativeint<\/span>)."}, "type": "int -> nativeint", "params": [{"name": "", "type": "int"}]}}, {"value": {"name": "Nativeint.to_int", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/nativeint.mli|5060"}, "info": {"description": "Convert the given native integer (type <span class=\"code\" >nativeint<\/span>) to an integer (type <span class=\"code\" >int<\/span>).  The high-order bit is lost during the conversion."}, "type": "nativeint -> int", "params": [{"name": "", "type": "nativeint"}]}}, {"value": {"name": "Nativeint.of_float", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/nativeint.mli|5262"}, "info": {"description": "Convert the given floating-point number to a native integer, discarding the fractional part (truncate towards 0). The result of the conversion is undefined if, after truncation, the number is outside the range [<a href=\"{value|Nativeint.min_int}\" ><span class=\"code\" >Nativeint.min_int<\/span><\/a>, <a href=\"{value|Nativeint.max_int}\" ><span class=\"code\" >Nativeint.max_int<\/span><\/a>]."}, "type": "float -> nativeint", "params": [{"name": "", "type": "float"}]}}, {"value": {"name": "Nativeint.to_float", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/nativeint.mli|5607"}, "info": {"description": "Convert the given native integer to a floating-point number."}, "type": "nativeint -> float", "params": [{"name": "", "type": "nativeint"}]}}, {"value": {"name": "Nativeint.of_int32", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/nativeint.mli|5743"}, "info": {"description": "Convert the given 32-bit integer (type <span class=\"code\" >int32<\/span>) to a native integer."}, "type": "int32 -> nativeint", "params": [{"name": "", "type": "int32"}]}}, {"value": {"name": "Nativeint.to_int32", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/nativeint.mli|5886"}, "info": {"description": "Convert the given native integer to a 32-bit integer (type <span class=\"code\" >int32<\/span>).  On 64-bit platforms, the 64-bit native integer is taken modulo 2<sup>32<\/sup>, i.e. the top 32 bits are lost.  On 32-bit platforms, the conversion is exact."}, "type": "nativeint -> int32", "params": [{"name": "", "type": "nativeint"}]}}, {"value": {"name": "Nativeint.of_string", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/nativeint.mli|6188"}, "info": {"description": "Convert the given string to a native integer. The string is read in decimal (by default) or in hexadecimal, octal or binary if the string begins with <span class=\"code\" >0x<\/span>, <span class=\"code\" >0o<\/span> or <span class=\"code\" >0b<\/span> respectively. Raise <span class=\"code\" >Failure \"int_of_string\"<\/span> if the given string is not a valid representation of an integer, or if the integer represented exceeds the range of integers representable in type <span class=\"code\" >nativeint<\/span>."}, "type": "string -> nativeint", "params": [{"name": "", "type": "string"}]}}, {"value": {"name": "Nativeint.to_string", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/nativeint.mli|6659"}, "info": {"description": "Return the string representation of its argument, in decimal."}, "type": "nativeint -> string", "params": [{"name": "", "type": "nativeint"}]}}, {"type": {"name": "Nativeint.t", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/nativeint.mli|6770"}, "info": {"description": "An alias for the type of native integers."}, "params": [], "kind": {"type": "abstract"}, "manifest": "nativeint"}}, {"value": {"name": "Nativeint.compare", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/nativeint.mli|6834"}, "info": {"description": "The comparison function for native integers, with the same specification as <a href=\"{value|Pervasives.compare}\" ><span class=\"code\" >Pervasives.compare<\/span><\/a>.  Along with the type <span class=\"code\" >t<\/span>, this function <span class=\"code\" >compare<\/span> allows the module <span class=\"code\" >Nativeint<\/span> to be passed as argument to the functors <a href=\"{module|Set.Make}\" ><span class=\"code\" >Set.Make<\/span><\/a> and <a href=\"{module|Map.Make}\" ><span class=\"code\" >Map.Make<\/span><\/a>."}, "type": "Nativeint.t -> Nativeint.t -> int", "params": [{"name": "", "type": "Nativeint.t"}, {"name": "", "type": "Nativeint.t"}]}}], "dependencies": {"uses": [], "used_by": ["Random"]}}}, "Marshal": {"module": {"name": "Marshal", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/marshal.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/marshal.mli|0"}, "info": {"description": "Marshaling of data structures.<br><\/br> This module provides functions to encode arbitrary data structures as sequences of bytes, which can then be written on a file or sent over a pipe or network connection.  The bytes can then be read back later, possibly in another process, and decoded back into a data structure. The format for the byte sequences is compatible across all machines for a given version of Objective Caml.<br><\/br> Warning: marshaling is currently not type-safe. The type of marshaled data is not transmitted along the value of the data, making it impossible to check that the data read back possesses the type expected by the context. In particular, the result type of the <span class=\"code\" >Marshal.from_*<\/span> functions is given as <span class=\"code\" >'a<\/span>, but this is misleading: the returned Caml value does not possess type <span class=\"code\" >'a<\/span> for all <span class=\"code\" >'a<\/span>; it has one, unique type which cannot be determined at compile-type.  The programmer should explicitly give the expected type of the returned value, using the following syntax:<ul><li><span class=\"code\" >(Marshal.from_channel chan : type)<\/span>. Anything can happen at run-time if the object in the file does not belong to the given type.<\/li><\/ul> The representation of marshaled values is not human-readable, and uses bytes that are not printable characters. Therefore, input and output channels used in conjunction with <span class=\"code\" >Marshal.to_channel<\/span> and <span class=\"code\" >Marshal.from_channel<\/span> must be opened in binary mode, using e.g. <span class=\"code\" >open_out_bin<\/span> or <span class=\"code\" >open_in_bin<\/span>; channels opened in text mode will cause unmarshaling errors on platforms where text channels behave differently than binary channels, e.g. Windows."}, "type": "sig  end", "module_structure": [{"type": {"name": "Marshal.extern_flags", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/marshal.mli|2603"}, "info": {"description": "The flags to the <span class=\"code\" >Marshal.to_*<\/span> functions below."}, "params": [], "kind": {"type": "variant", "private": "false", "constructors": [{"name": "No_sharing", "description": "Don't preserve sharing", "type": []}, {"name": "Closures", "description": "Send function closures", "type": []}]}}}, {"value": {"name": "Marshal.to_string", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/marshal.mli|2815"}, "info": {"description": "<span class=\"code\" >Marshal.to_string v flags<\/span> returns a string containing the representation of <span class=\"code\" >v<\/span> as a sequence of bytes. The <span class=\"code\" >flags<\/span> argument has the same meaning as for <a href=\"{none|Marshal.to_channel}\" ><span class=\"code\" >Marshal.to_channel<\/span><\/a>."}, "type": "'a -> Marshal.extern_flags list -> string", "params": [{"name": "", "type": "'a"}, {"name": "", "type": "Marshal.extern_flags list"}]}}, {"value": {"name": "Marshal.to_buffer", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/marshal.mli|3099"}, "info": {"description": "<span class=\"code\" >Marshal.to_buffer buff ofs len v flags<\/span> marshals the value <span class=\"code\" >v<\/span>, storing its byte representation in the string <span class=\"code\" >buff<\/span>, starting at character number <span class=\"code\" >ofs<\/span>, and writing at most <span class=\"code\" >len<\/span> characters.  It returns the number of characters actually written to the string. If the byte representation of <span class=\"code\" >v<\/span> does not fit in <span class=\"code\" >len<\/span> characters, the exception <span class=\"code\" >Failure<\/span> is raised."}, "type": "string -> int -> int -> 'a -> Marshal.extern_flags list -> int", "params": [{"name": "", "type": "string"}, {"name": "", "type": "int"}, {"name": "", "type": "int"}, {"name": "", "type": "'a"}, {"name": "", "type": "Marshal.extern_flags list"}]}}, {"value": {"name": "Marshal.from_string", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/marshal.mli|3561"}, "info": {"description": "<span class=\"code\" >Marshal.from_string buff ofs<\/span> unmarshals a structured value like <a href=\"{none|Marshal.from_channel}\" ><span class=\"code\" >Marshal.from_channel<\/span><\/a> does, except that the byte representation is not read from a channel, but taken from the string <span class=\"code\" >buff<\/span>, starting at position <span class=\"code\" >ofs<\/span>."}, "type": "string -> int -> 'a", "params": [{"name": "", "type": "string"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Marshal.header_size", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/marshal.mli|3838"}, "info": {"description": "The bytes representing a marshaled value are composed of a fixed-size header and a variable-sized data part, whose size can be determined from the header. <a href=\"{value|Marshal.header_size}\" ><span class=\"code\" >Marshal.header_size<\/span><\/a> is the size, in characters, of the header. <a href=\"{value|Marshal.data_size}\" ><span class=\"code\" >Marshal.data_size<\/span><\/a><span class=\"code\" > buff ofs<\/span> is the size, in characters, of the data part, assuming a valid header is stored in <span class=\"code\" >buff<\/span> starting at position <span class=\"code\" >ofs<\/span>. Finally, <a href=\"{value|Marshal.total_size}\" ><span class=\"code\" >Marshal.total_size<\/span><\/a><span class=\"code\" > buff ofs<\/span> is the total size, in characters, of the marshaled value. Both <a href=\"{value|Marshal.data_size}\" ><span class=\"code\" >Marshal.data_size<\/span><\/a> and <a href=\"{value|Marshal.total_size}\" ><span class=\"code\" >Marshal.total_size<\/span><\/a> raise <span class=\"code\" >Failure<\/span> if <span class=\"code\" >buff<\/span>, <span class=\"code\" >ofs<\/span> does not contain a valid header.<br><\/br> To read the byte representation of a marshaled value into a string buffer, the program needs to read first <a href=\"{value|Marshal.header_size}\" ><span class=\"code\" >Marshal.header_size<\/span><\/a> characters into the buffer, then determine the length of the remainder of the representation using <a href=\"{value|Marshal.data_size}\" ><span class=\"code\" >Marshal.data_size<\/span><\/a>, make sure the buffer is large enough to hold the remaining data, then read it, and finally call <a href=\"{value|Marshal.from_string}\" ><span class=\"code\" >Marshal.from_string<\/span><\/a> to unmarshal the value."}, "type": "int", "params": []}}, {"value": {"name": "Marshal.data_size", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/marshal.mli|4906"}, "info": {"description": "See <a href=\"{value|Marshal.header_size}\" ><span class=\"code\" >Marshal.header_size<\/span><\/a>."}, "type": "string -> int -> int", "params": [{"name": "", "type": "string"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Marshal.total_size", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/marshal.mli|4978"}, "info": {"description": "See <a href=\"{value|Marshal.header_size}\" ><span class=\"code\" >Marshal.header_size<\/span><\/a>."}, "type": "string -> int -> int", "params": [{"name": "", "type": "string"}, {"name": "", "type": "int"}]}}], "dependencies": {"uses": [], "used_by": []}}}, "Map": {"module": {"name": "Map", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/map.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/map.mli|0"}, "info": {"description": "Association tables over ordered types.<br><\/br> This module implements applicative association tables, also known as finite maps or dictionaries, given a total ordering function over the keys. All operations over maps are purely applicative (no side-effects). The implementation uses balanced binary trees, and therefore searching and insertion take time logarithmic in the size of the map."}, "type": "sig  end", "module_structure": [{"module_type": {"name": "Map.OrderedType", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/map.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/map.mli|1356"}, "info": {"description": "Input signature of the functor <a href=\"{module|Map.Make}\" ><span class=\"code\" >Map.Make<\/span><\/a>."}, "type": "sig  end", "kind": ""}}, {"module_type": {"name": "Map.S", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/map.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/map.mli|1976"}, "info": {"description": "Output signature of the functor <a href=\"{module|Map.Make}\" ><span class=\"code\" >Map.Make<\/span><\/a>."}, "type": "sig  end", "kind": ""}}, {"module": {"name": "Map.Make", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/map.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/map.mli|7523"}, "info": {"description": "Functor building an implementation of the map structure given a totally ordered type."}, "type": "functor (Ord : OrderedType) -> sig  end", "module_functor": {"parameter": {"name": "Ord"}, "module_with": "unavailable"}, "dependencies": {"uses": []}}}], "dependencies": {"uses": [], "used_by": []}}}, "Lazy": {"module": {"name": "Lazy", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lazy.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lazy.mli|0"}, "info": {"description": "Deferred computations."}, "type": "sig  end", "module_structure": [{"type": {"name": "Lazy.t", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lazy.mli|982"}, "info": {"description": "A value of type <span class=\"code\" >'a Lazy.t<\/span> is a deferred computation, called a suspension, that has a result of type <span class=\"code\" >'a<\/span>.  The special expression syntax <span class=\"code\" >lazy (expr)<\/span> makes a suspension of the computation of <span class=\"code\" >expr<\/span>, without computing <span class=\"code\" >expr<\/span> itself yet. \"Forcing\" the suspension will then compute <span class=\"code\" >expr<\/span> and return its result.<br><\/br> Note: <span class=\"code\" >lazy_t<\/span> is the built-in type constructor used by the compiler for the <span class=\"code\" >lazy<\/span> keyword.  You should not use it directly.  Always use <span class=\"code\" >Lazy.t<\/span> instead.<br><\/br> Note: <span class=\"code\" >Lazy.force<\/span> is not thread-safe.  If you use this module in a multi-threaded program, you will need to add some locks.<br><\/br> Note: if the program is compiled with the <span class=\"code\" >-rectypes<\/span> option, ill-founded recursive definitions of the form <span class=\"code\" >let rec x = lazy x<\/span> or <span class=\"code\" >let rec x = lazy(lazy(...(lazy x)))<\/span> are accepted by the type-checker and lead, when forced, to ill-formed values that trigger infinite loops in the garbage collector and other parts of the run-time system. Without the <span class=\"code\" >-rectypes<\/span> option, such ill-founded recursive definitions are rejected by the type-checker."}, "params": [{"covariant": "true", "contravariant": "false", "type": "'a"}], "kind": {"type": "abstract"}, "manifest": "'a lazy_t"}}, {"exception": {"name": "Lazy.Undefined", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lazy.mli|2103"}, "info": ""}}, {"value": {"name": "Lazy.force", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lazy.mli|2126"}, "info": "", "type": "'a Lazy.t -> 'a", "params": [{"name": "", "type": "'a Lazy.t"}]}}, {"comment": "<span class=\"code\" >force x<\/span> forces the suspension <span class=\"code\" >x<\/span> and returns its result. If <span class=\"code\" >x<\/span> has already been forced, <span class=\"code\" >Lazy.force x<\/span> returns the same value again without recomputing it.  If it raised an exception, the same exception is raised again. Raise <span class=\"code\" >Undefined<\/span> if the forcing of <span class=\"code\" >x<\/span> tries to force <span class=\"code\" >x<\/span> itself recursively."}, {"value": {"name": "Lazy.force_val", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lazy.mli|2530"}, "info": {"description": "<span class=\"code\" >force_val x<\/span> forces the suspension <span class=\"code\" >x<\/span> and returns its result.  If <span class=\"code\" >x<\/span> has already been forced, <span class=\"code\" >force_val x<\/span> returns the same value again without recomputing it. Raise <span class=\"code\" >Undefined<\/span> if the forcing of <span class=\"code\" >x<\/span> tries to force <span class=\"code\" >x<\/span> itself recursively. If the computation of <span class=\"code\" >x<\/span> raises an exception, it is unspecified whether <span class=\"code\" >force_val x<\/span> raises the same exception or <span class=\"code\" >Undefined<\/span>."}, "type": "'a Lazy.t -> 'a", "params": [{"name": "", "type": "'a Lazy.t"}]}}, {"value": {"name": "Lazy.lazy_from_fun", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lazy.mli|2963"}, "info": {"description": "<span class=\"code\" >lazy_from_fun f<\/span> is the same as <span class=\"code\" >lazy (f ())<\/span> but slightly more efficient."}, "type": "(unit -> 'a) -> 'a Lazy.t", "params": [{"name": "", "type": "unit -> 'a"}]}}, {"value": {"name": "Lazy.lazy_from_val", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lazy.mli|3094"}, "info": {"description": "<span class=\"code\" >lazy_from_val v<\/span> returns an already-forced suspension of <span class=\"code\" >v<\/span> This is for special purposes only and should not be confused with <span class=\"code\" >lazy (v)<\/span>."}, "type": "'a -> 'a Lazy.t", "params": [{"name": "", "type": "'a"}]}}, {"value": {"name": "Lazy.lazy_is_val", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lazy.mli|3283"}, "info": {"description": "<span class=\"code\" >lazy_is_val x<\/span> returns <span class=\"code\" >true<\/span> if <span class=\"code\" >x<\/span> has already been forced and did not raise an exception."}, "type": "'a Lazy.t -> bool", "params": [{"name": "", "type": "'a Lazy.t"}]}}], "dependencies": {"uses": [], "used_by": []}}}, "Stream": {"module": {"name": "Stream", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/stream.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/stream.mli|0"}, "info": {"description": "Streams and parsers."}, "type": "sig  end", "module_structure": [{"type": {"name": "Stream.t", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/stream.mli|981"}, "info": {"description": "The type of streams holding values of type <span class=\"code\" >'a<\/span>."}, "params": [{"covariant": "true", "contravariant": "true", "type": "'b"}], "kind": {"type": "abstract"}}}, {"exception": {"name": "Stream.Failure", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/stream.mli|1044"}, "info": {"description": "Raised by parsers when none of the first components of the stream patterns is accepted."}}}, {"exception": {"name": "Stream.Error", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/stream.mli|1161"}, "info": {"description": "Raised by parsers when the first component of a stream pattern is accepted, but one of the following components is rejected."}, "exception_args": ["string"]}}, {"comment": "<h6>Stream builders<\/h6><br><\/br> Warning: these functions create streams with fast access; it is illegal to mix them with streams built with <span class=\"code\" >[&lt; &gt;]<\/span>; would raise <span class=\"code\" >Failure<\/span> when accessing such mixed streams."}, {"value": {"name": "Stream.from", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/stream.mli|1536"}, "info": {"description": "<span class=\"code\" >Stream.from f<\/span> returns a stream built from the function <span class=\"code\" >f<\/span>. To create a new stream element, the function <span class=\"code\" >f<\/span> is called with the current stream count. The user function <span class=\"code\" >f<\/span> must return either <span class=\"code\" >Some &lt;value&gt;<\/span> for a value or <span class=\"code\" >None<\/span> to specify the end of the stream."}, "type": "(int -> 'a option) -> 'a Stream.t", "params": [{"name": "", "type": "int -> 'a option"}]}}, {"value": {"name": "Stream.of_list", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/stream.mli|1858"}, "info": {"description": "Return the stream holding the elements of the list in the same order."}, "type": "'a list -> 'a Stream.t", "params": [{"name": "", "type": "'a list"}]}}, {"value": {"name": "Stream.of_string", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/stream.mli|1969"}, "info": {"description": "Return the stream of the characters of the string parameter."}, "type": "string -> char Stream.t", "params": [{"name": "", "type": "string"}]}}, {"value": {"name": "Stream.of_channel", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/stream.mli|2071"}, "info": {"description": "Return the stream of the characters read from the input channel."}, "type": "Pervasives.in_channel -> char Stream.t", "params": [{"name": "", "type": "Pervasives.in_channel"}]}}, {"comment": "<h6>Stream iterator<\/h6>"}, {"value": {"name": "Stream.iter", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/stream.mli|2211"}, "info": {"description": "<span class=\"code\" >Stream.iter f s<\/span> scans the whole stream s, applying function <span class=\"code\" >f<\/span> in turn to each stream element encountered."}, "type": "('a -> unit) -> 'a Stream.t -> unit", "params": [{"name": "", "type": "'a -> unit"}, {"name": "", "type": "'a Stream.t"}]}}, {"comment": "<h6>Predefined parsers<\/h6>"}, {"value": {"name": "Stream.next", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/stream.mli|2404"}, "info": {"description": "Return the first element of the stream and remove it from the stream. Raise Stream.Failure if the stream is empty."}, "type": "'a Stream.t -> 'a", "params": [{"name": "", "type": "'a Stream.t"}]}}, {"value": {"name": "Stream.empty", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/stream.mli|2552"}, "info": {"description": "Return <span class=\"code\" >()<\/span> if the stream is empty, else raise <span class=\"code\" >Stream.Failure<\/span>."}, "type": "'a Stream.t -> unit", "params": [{"name": "", "type": "'a Stream.t"}]}}, {"comment": "<h6>Useful functions<\/h6>"}, {"value": {"name": "Stream.peek", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/stream.mli|2680"}, "info": {"description": "Return <span class=\"code\" >Some<\/span> of \"the first element\" of the stream, or <span class=\"code\" >None<\/span> if the stream is empty."}, "type": "'a Stream.t -> 'a option", "params": [{"name": "", "type": "'a Stream.t"}]}}, {"value": {"name": "Stream.junk", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/stream.mli|2806"}, "info": {"description": "Remove the first element of the stream, possibly unfreezing it before."}, "type": "'a Stream.t -> unit", "params": [{"name": "", "type": "'a Stream.t"}]}}, {"value": {"name": "Stream.count", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/stream.mli|2912"}, "info": {"description": "Return the current count of the stream elements, i.e. the number of the stream elements discarded."}, "type": "'a Stream.t -> int", "params": [{"name": "", "type": "'a Stream.t"}]}}, {"value": {"name": "Stream.npeek", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/stream.mli|3046"}, "info": {"description": "<span class=\"code\" >npeek n<\/span> returns the list of the <span class=\"code\" >n<\/span> first elements of the stream, or all its remaining elements if less than <span class=\"code\" >n<\/span> elements are available."}, "type": "int -> 'a Stream.t -> 'a list", "params": [{"name": "", "type": "int"}, {"name": "", "type": "'a Stream.t"}]}}], "dependencies": {"uses": [], "used_by": ["Utf8", "Utf16", "Ulexing"]}}}, "List": {"module": {"name": "List", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/list.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/list.mli|0"}, "info": {"description": "List operations.<br><\/br> Some functions are flagged as not tail-recursive.  A tail-recursive function uses constant stack space, while a non-tail-recursive function uses stack space proportional to the length of its list argument, which can be a problem with very long lists.  When the function takes several list arguments, an approximate formula giving stack usage (in some unspecified constant unit) is shown in parentheses.<br><\/br> The above considerations can usually be ignored if your lists are not longer than about 10000 elements."}, "type": "sig  end", "module_structure": [{"value": {"name": "List.length", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/list.mli|1504"}, "info": {"description": "Return the length (number of elements) of the given list."}, "type": "'a list -> int", "params": [{"name": "", "type": "'a list"}]}}, {"value": {"name": "List.hd", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/list.mli|1598"}, "info": {"description": "Return the first element of the given list. Raise <span class=\"code\" >Failure \"hd\"<\/span> if the list is empty."}, "type": "'a list -> 'a", "params": [{"name": "", "type": "'a list"}]}}, {"value": {"name": "List.tl", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/list.mli|1719"}, "info": {"description": "Return the given list without its first element. Raise <span class=\"code\" >Failure \"tl\"<\/span> if the list is empty."}, "type": "'a list -> 'a list", "params": [{"name": "", "type": "'a list"}]}}, {"value": {"name": "List.nth", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/list.mli|1850"}, "info": {"description": "Return the <span class=\"code\" >n<\/span>-th element of the given list. The first element (head of the list) is at position 0. Raise <span class=\"code\" >Failure \"nth\"<\/span> if the list is too short. Raise <span class=\"code\" >Invalid_argument \"List.nth\"<\/span> if <span class=\"code\" >n<\/span> is negative."}, "type": "'a list -> int -> 'a", "params": [{"name": "", "type": "'a list"}, {"name": "", "type": "int"}]}}, {"value": {"name": "List.rev", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/list.mli|2102"}, "info": {"description": "List reversal."}, "type": "'a list -> 'a list", "params": [{"name": "", "type": "'a list"}]}}, {"value": {"name": "List.append", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/list.mli|2154"}, "info": {"description": "Catenate two lists.  Same function as the infix operator <span class=\"code\" >@<\/span>. Not tail-recursive (length of the first argument).  The <span class=\"code\" >@<\/span> operator is not tail-recursive either."}, "type": "'a list -> 'a list -> 'a list", "params": [{"name": "", "type": "'a list"}, {"name": "", "type": "'a list"}]}}, {"value": {"name": "List.rev_append", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/list.mli|2372"}, "info": {"description": "<span class=\"code\" >List.rev_append l1 l2<\/span> reverses <span class=\"code\" >l1<\/span> and concatenates it to <span class=\"code\" >l2<\/span>. This is equivalent to <a href=\"{value|List.rev}\" ><span class=\"code\" >List.rev<\/span><\/a><span class=\"code\" > l1 @ l2<\/span>, but <span class=\"code\" >rev_append<\/span> is tail-recursive and more efficient."}, "type": "'a list -> 'a list -> 'a list", "params": [{"name": "", "type": "'a list"}, {"name": "", "type": "'a list"}]}}, {"value": {"name": "List.concat", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/list.mli|2600"}, "info": {"description": "Concatenate a list of lists.  The elements of the argument are all concatenated together (in the same order) to give the result. Not tail-recursive (length of the argument + length of the longest sub-list)."}, "type": "'a list list -> 'a list", "params": [{"name": "", "type": "'a list list"}]}}, {"value": {"name": "List.flatten", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/list.mli|2861"}, "info": {"description": "Same as <span class=\"code\" >concat<\/span>.  Not tail-recursive (length of the argument + length of the longest sub-list)."}, "type": "'a list list -> 'a list", "params": [{"name": "", "type": "'a list list"}]}}, {"comment": "<h6>Iterators<\/h6>"}, {"value": {"name": "List.iter", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/list.mli|3031"}, "info": {"description": "<span class=\"code\" >List.iter f [a1; ...; an]<\/span> applies function <span class=\"code\" >f<\/span> in turn to <span class=\"code\" >a1; ...; an<\/span>. It is equivalent to <span class=\"code\" >begin f a1; f a2; ...; f an; () end<\/span>."}, "type": "('a -> unit) -> 'a list -> unit", "params": [{"name": "", "type": "'a -> unit"}, {"name": "", "type": "'a list"}]}}, {"value": {"name": "List.map", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/list.mli|3222"}, "info": {"description": "<span class=\"code\" >List.map f [a1; ...; an]<\/span> applies function <span class=\"code\" >f<\/span> to <span class=\"code\" >a1, ..., an<\/span>, and builds the list <span class=\"code\" >[f a1; ...; f an]<\/span> with the results returned by <span class=\"code\" >f<\/span>.  Not tail-recursive."}, "type": "('a -> 'b) -> 'a list -> 'b list", "params": [{"name": "", "type": "'a -> 'b"}, {"name": "", "type": "'a list"}]}}, {"value": {"name": "List.rev_map", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/list.mli|3440"}, "info": {"description": "<span class=\"code\" >List.rev_map f l<\/span> gives the same result as <a href=\"{value|List.rev}\" ><span class=\"code\" >List.rev<\/span><\/a><span class=\"code\" > (<\/span><a href=\"{value|List.map}\" ><span class=\"code\" >List.map<\/span><\/a><span class=\"code\" > f l)<\/span>, but is tail-recursive and more efficient."}, "type": "('a -> 'b) -> 'a list -> 'b list", "params": [{"name": "", "type": "'a -> 'b"}, {"name": "", "type": "'a list"}]}}, {"value": {"name": "List.fold_left", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/list.mli|3622"}, "info": {"description": "<span class=\"code\" >List.fold_left f a [b1; ...; bn]<\/span> is <span class=\"code\" >f (... (f (f a b1) b2) ...) bn<\/span>."}, "type": "('a -> 'b -> 'a) -> 'a -> 'b list -> 'a", "params": [{"name": "", "type": "'a -> 'b -> 'a"}, {"name": "", "type": "'a"}, {"name": "", "type": "'a list"}]}}, {"value": {"name": "List.fold_right", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/list.mli|3761"}, "info": {"description": "<span class=\"code\" >List.fold_right f [a1; ...; an] b<\/span> is <span class=\"code\" >f a1 (f a2 (... (f an b) ...))<\/span>.  Not tail-recursive."}, "type": "('a -> 'b -> 'b) -> 'a list -> 'b -> 'b", "params": [{"name": "", "type": "'a -> 'b -> 'b"}, {"name": "", "type": "'a list"}, {"name": "", "type": "'a"}]}}, {"comment": "<h6>Iterators on two lists<\/h6>"}, {"value": {"name": "List.iter2", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/list.mli|3960"}, "info": {"description": "<span class=\"code\" >List.iter2 f [a1; ...; an] [b1; ...; bn]<\/span> calls in turn <span class=\"code\" >f a1 b1; ...; f an bn<\/span>. Raise <span class=\"code\" >Invalid_argument<\/span> if the two lists have different lengths."}, "type": "('a -> 'b -> unit) -> 'a list -> 'b list -> unit", "params": [{"name": "", "type": "'a -> 'b -> unit"}, {"name": "", "type": "'a list"}, {"name": "", "type": "'a list"}]}}, {"value": {"name": "List.map2", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/list.mli|4186"}, "info": {"description": "<span class=\"code\" >List.map2 f [a1; ...; an] [b1; ...; bn]<\/span> is <span class=\"code\" >[f a1 b1; ...; f an bn]<\/span>. Raise <span class=\"code\" >Invalid_argument<\/span> if the two lists have different lengths.  Not tail-recursive."}, "type": "('a -> 'b -> 'c) -> 'a list -> 'b list -> 'c list", "params": [{"name": "", "type": "'a -> 'b -> 'c"}, {"name": "", "type": "'a list"}, {"name": "", "type": "'a list"}]}}, {"value": {"name": "List.rev_map2", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/list.mli|4423"}, "info": {"description": "<span class=\"code\" >List.rev_map2 f l1 l2<\/span> gives the same result as <a href=\"{value|List.rev}\" ><span class=\"code\" >List.rev<\/span><\/a><span class=\"code\" > (<\/span><a href=\"{value|List.map2}\" ><span class=\"code\" >List.map2<\/span><\/a><span class=\"code\" > f l1 l2)<\/span>, but is tail-recursive and more efficient."}, "type": "('a -> 'b -> 'c) -> 'a list -> 'b list -> 'c list", "params": [{"name": "", "type": "'a -> 'b -> 'c"}, {"name": "", "type": "'a list"}, {"name": "", "type": "'a list"}]}}, {"value": {"name": "List.fold_left2", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/list.mli|4633"}, "info": {"description": "<span class=\"code\" >List.fold_left2 f a [b1; ...; bn] [c1; ...; cn]<\/span> is <span class=\"code\" >f (... (f (f a b1 c1) b2 c2) ...) bn cn<\/span>. Raise <span class=\"code\" >Invalid_argument<\/span> if the two lists have different lengths."}, "type": "('a -> 'b -> 'c -> 'a) -> 'a -> 'b list -> 'c list -> 'a", "params": [{"name": "", "type": "'a -> 'b -> 'c -> 'a"}, {"name": "", "type": "'a"}, {"name": "", "type": "'a list"}, {"name": "", "type": "'a list"}]}}, {"value": {"name": "List.fold_right2", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/list.mli|4886"}, "info": {"description": "<span class=\"code\" >List.fold_right2 f [a1; ...; an] [b1; ...; bn] c<\/span> is <span class=\"code\" >f a1 b1 (f a2 b2 (... (f an bn c) ...))<\/span>. Raise <span class=\"code\" >Invalid_argument<\/span> if the two lists have different lengths.  Not tail-recursive."}, "type": "('a -> 'b -> 'c -> 'c) -> 'a list -> 'b list -> 'c -> 'c", "params": [{"name": "", "type": "'a -> 'b -> 'c -> 'c"}, {"name": "", "type": "'a list"}, {"name": "", "type": "'a list"}, {"name": "", "type": "'a"}]}}, {"comment": "<h6>List scanning<\/h6>"}, {"value": {"name": "List.for_all", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/list.mli|5190"}, "info": {"description": "<span class=\"code\" >for_all p [a1; ...; an]<\/span> checks if all elements of the list satisfy the predicate <span class=\"code\" >p<\/span>. That is, it returns <span class=\"code\" >(p a1) &amp;&amp; (p a2) &amp;&amp; ... &amp;&amp; (p an)<\/span>."}, "type": "('a -> bool) -> 'a list -> bool", "params": [{"name": "", "type": "'a -> bool"}, {"name": "", "type": "'a list"}]}}, {"value": {"name": "List.exists", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/list.mli|5395"}, "info": {"description": "<span class=\"code\" >exists p [a1; ...; an]<\/span> checks if at least one element of the list satisfies the predicate <span class=\"code\" >p<\/span>. That is, it returns <span class=\"code\" >(p a1) || (p a2) || ... || (p an)<\/span>."}, "type": "('a -> bool) -> 'a list -> bool", "params": [{"name": "", "type": "'a -> bool"}, {"name": "", "type": "'a list"}]}}, {"value": {"name": "List.for_all2", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/list.mli|5608"}, "info": {"description": "Same as <a href=\"{value|List.for_all}\" ><span class=\"code\" >List.for_all<\/span><\/a>, but for a two-argument predicate. Raise <span class=\"code\" >Invalid_argument<\/span> if the two lists have different lengths."}, "type": "('a -> 'b -> bool) -> 'a list -> 'b list -> bool", "params": [{"name": "", "type": "'a -> 'b -> bool"}, {"name": "", "type": "'a list"}, {"name": "", "type": "'a list"}]}}, {"value": {"name": "List.exists2", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/list.mli|5811"}, "info": {"description": "Same as <a href=\"{value|List.exists}\" ><span class=\"code\" >List.exists<\/span><\/a>, but for a two-argument predicate. Raise <span class=\"code\" >Invalid_argument<\/span> if the two lists have different lengths."}, "type": "('a -> 'b -> bool) -> 'a list -> 'b list -> bool", "params": [{"name": "", "type": "'a -> 'b -> bool"}, {"name": "", "type": "'a list"}, {"name": "", "type": "'a list"}]}}, {"value": {"name": "List.mem", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/list.mli|6012"}, "info": {"description": "<span class=\"code\" >mem a l<\/span> is true if and only if <span class=\"code\" >a<\/span> is equal to an element of <span class=\"code\" >l<\/span>."}, "type": "'a -> 'a list -> bool", "params": [{"name": "", "type": "'a"}, {"name": "", "type": "'a list"}]}}, {"value": {"name": "List.memq", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/list.mli|6123"}, "info": {"description": "Same as <a href=\"{value|List.mem}\" ><span class=\"code\" >List.mem<\/span><\/a>, but uses physical equality instead of structural equality to compare list elements."}, "type": "'a -> 'a list -> bool", "params": [{"name": "", "type": "'a"}, {"name": "", "type": "'a list"}]}}, {"comment": "<h6>List searching<\/h6>"}, {"value": {"name": "List.find", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/list.mli|6301"}, "info": {"description": "<span class=\"code\" >find p l<\/span> returns the first element of the list <span class=\"code\" >l<\/span> that satisfies the predicate <span class=\"code\" >p<\/span>. Raise <span class=\"code\" >Not_found<\/span> if there is no value that satisfies <span class=\"code\" >p<\/span> in the list <span class=\"code\" >l<\/span>."}, "type": "('a -> bool) -> 'a list -> 'a", "params": [{"name": "", "type": "'a -> bool"}, {"name": "", "type": "'a list"}]}}, {"value": {"name": "List.filter", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/list.mli|6521"}, "info": {"description": "<span class=\"code\" >filter p l<\/span> returns all the elements of the list <span class=\"code\" >l<\/span> that satisfy the predicate <span class=\"code\" >p<\/span>.  The order of the elements in the input list is preserved."}, "type": "('a -> bool) -> 'a list -> 'a list", "params": [{"name": "", "type": "'a -> bool"}, {"name": "", "type": "'a list"}]}}, {"value": {"name": "List.find_all", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/list.mli|6729"}, "info": {"description": "<span class=\"code\" >find_all<\/span> is another name for <a href=\"{value|List.filter}\" ><span class=\"code\" >List.filter<\/span><\/a>."}, "type": "('a -> bool) -> 'a list -> 'a list", "params": [{"name": "", "type": "'a -> bool"}, {"name": "", "type": "'a list"}]}}, {"value": {"name": "List.partition", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/list.mli|6834"}, "info": {"description": "<span class=\"code\" >partition p l<\/span> returns a pair of lists <span class=\"code\" >(l1, l2)<\/span>, where <span class=\"code\" >l1<\/span> is the list of all the elements of <span class=\"code\" >l<\/span> that satisfy the predicate <span class=\"code\" >p<\/span>, and <span class=\"code\" >l2<\/span> is the list of all the elements of <span class=\"code\" >l<\/span> that do not satisfy <span class=\"code\" >p<\/span>. The order of the elements in the input list is preserved."}, "type": "('a -> bool) -> 'a list -> 'a list * 'a list", "params": [{"name": "", "type": "'a -> bool"}, {"name": "", "type": "'a list"}]}}, {"comment": "<h6>Association lists<\/h6>"}, {"value": {"name": "List.assoc", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/list.mli|7212"}, "info": {"description": "<span class=\"code\" >assoc a l<\/span> returns the value associated with key <span class=\"code\" >a<\/span> in the list of pairs <span class=\"code\" >l<\/span>. That is, <span class=\"code\" >assoc a [ ...; (a,b); ...] = b<\/span> if <span class=\"code\" >(a,b)<\/span> is the leftmost binding of <span class=\"code\" >a<\/span> in list <span class=\"code\" >l<\/span>. Raise <span class=\"code\" >Not_found<\/span> if there is no value associated with <span class=\"code\" >a<\/span> in the list <span class=\"code\" >l<\/span>."}, "type": "'a -> ('a * 'b) list -> 'b", "params": [{"name": "", "type": "'a"}, {"name": "", "type": "('a * 'b) list"}]}}, {"value": {"name": "List.assq", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/list.mli|7527"}, "info": {"description": "Same as <a href=\"{value|List.assoc}\" ><span class=\"code\" >List.assoc<\/span><\/a>, but uses physical equality instead of structural equality to compare keys."}, "type": "'a -> ('a * 'b) list -> 'b", "params": [{"name": "", "type": "'a"}, {"name": "", "type": "('a * 'b) list"}]}}, {"value": {"name": "List.mem_assoc", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/list.mli|7674"}, "info": {"description": "Same as <a href=\"{value|List.assoc}\" ><span class=\"code\" >List.assoc<\/span><\/a>, but simply return true if a binding exists, and false if no bindings exist for the given key."}, "type": "'a -> ('a * 'b) list -> bool", "params": [{"name": "", "type": "'a"}, {"name": "", "type": "('a * 'b) list"}]}}, {"value": {"name": "List.mem_assq", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/list.mli|7847"}, "info": {"description": "Same as <a href=\"{value|List.mem_assoc}\" ><span class=\"code\" >List.mem_assoc<\/span><\/a>, but uses physical equality instead of structural equality to compare keys."}, "type": "'a -> ('a * 'b) list -> bool", "params": [{"name": "", "type": "'a"}, {"name": "", "type": "('a * 'b) list"}]}}, {"value": {"name": "List.remove_assoc", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/list.mli|8004"}, "info": {"description": "<span class=\"code\" >remove_assoc a l<\/span> returns the list of pairs <span class=\"code\" >l<\/span> without the first pair with key <span class=\"code\" >a<\/span>, if any. Not tail-recursive."}, "type": "'a -> ('a * 'b) list -> ('a * 'b) list", "params": [{"name": "", "type": "'a"}, {"name": "", "type": "('a * 'b) list"}]}}, {"value": {"name": "List.remove_assq", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/list.mli|8190"}, "info": {"description": "Same as <a href=\"{value|List.remove_assoc}\" ><span class=\"code\" >List.remove_assoc<\/span><\/a>, but uses physical equality instead of structural equality to compare keys.  Not tail-recursive."}, "type": "'a -> ('a * 'b) list -> ('a * 'b) list", "params": [{"name": "", "type": "'a"}, {"name": "", "type": "('a * 'b) list"}]}}, {"comment": "<h6>Lists of pairs<\/h6>"}, {"value": {"name": "List.split", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/list.mli|8413"}, "info": {"description": "Transform a list of pairs into a pair of lists: <span class=\"code\" >split [(a1,b1); ...; (an,bn)]<\/span> is <span class=\"code\" >([a1; ...; an], [b1; ...; bn])<\/span>. Not tail-recursive."}, "type": "('a * 'b) list -> 'a list * 'b list", "params": [{"name": "", "type": "('a * 'b) list"}]}}, {"value": {"name": "List.combine", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/list.mli|8612"}, "info": {"description": "Transform a pair of lists into a list of pairs: <span class=\"code\" >combine [a1; ...; an] [b1; ...; bn]<\/span> is <span class=\"code\" >[(a1,b1); ...; (an,bn)]<\/span>. Raise <span class=\"code\" >Invalid_argument<\/span> if the two lists have different lengths.  Not tail-recursive."}, "type": "'a list -> 'b list -> ('a * 'b) list", "params": [{"name": "", "type": "'a list"}, {"name": "", "type": "'a list"}]}}, {"comment": "<h6>Sorting<\/h6>"}, {"value": {"name": "List.sort", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/list.mli|8908"}, "info": {"description": "Sort a list in increasing order according to a comparison function.  The comparison function must return 0 if its arguments compare as equal, a positive integer if the first is greater, and a negative integer if the first is smaller (see Array.sort for a complete specification).  For example, <a href=\"{value|Pervasives.compare}\" ><span class=\"code\" >Pervasives.compare<\/span><\/a> is a suitable comparison function. The resulting list is sorted in increasing order. <span class=\"code\" >List.sort<\/span> is guaranteed to run in constant heap space (in addition to the size of the result list) and logarithmic stack space.<br><\/br> The current implementation uses Merge Sort. It runs in constant heap space and logarithmic stack space."}, "type": "('a -> 'a -> int) -> 'a list -> 'a list", "params": [{"name": "", "type": "'a -> 'a -> int"}, {"name": "", "type": "'a list"}]}}, {"value": {"name": "List.stable_sort", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/list.mli|9636"}, "info": {"description": "Same as <a href=\"{value|List.sort}\" ><span class=\"code\" >List.sort<\/span><\/a>, but the sorting algorithm is guaranteed to be stable (i.e. elements that compare equal are kept in their original order) .<br><\/br> The current implementation uses Merge Sort. It runs in constant heap space and logarithmic stack space."}, "type": "('a -> 'a -> int) -> 'a list -> 'a list", "params": [{"name": "", "type": "'a -> 'a -> int"}, {"name": "", "type": "'a list"}]}}, {"value": {"name": "List.fast_sort", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/list.mli|9964"}, "info": {"description": "Same as <a href=\"{value|List.sort}\" ><span class=\"code\" >List.sort<\/span><\/a> or <a href=\"{value|List.stable_sort}\" ><span class=\"code\" >List.stable_sort<\/span><\/a>, whichever is faster on typical input."}, "type": "('a -> 'a -> int) -> 'a list -> 'a list", "params": [{"name": "", "type": "'a -> 'a -> int"}, {"name": "", "type": "'a list"}]}}, {"value": {"name": "List.merge", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/list.mli|10115"}, "info": {"description": "Merge two lists: Assuming that <span class=\"code\" >l1<\/span> and <span class=\"code\" >l2<\/span> are sorted according to the comparison function <span class=\"code\" >cmp<\/span>, <span class=\"code\" >merge cmp l1 l2<\/span> will return a sorted list containting all the elements of <span class=\"code\" >l1<\/span> and <span class=\"code\" >l2<\/span>. If several elements compare equal, the elements of <span class=\"code\" >l1<\/span> will be before the elements of <span class=\"code\" >l2<\/span>. Not tail-recursive (sum of the lengths of the arguments)."}, "type": "('a -> 'a -> int) -> 'a list -> 'a list -> 'a list", "params": [{"name": "", "type": "'a -> 'a -> int"}, {"name": "", "type": "'a list"}, {"name": "", "type": "'a list"}]}}], "dependencies": {"uses": [], "used_by": []}}}, "Lexing": {"module": {"name": "Lexing", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lexing.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lexing.mli|0"}, "info": {"description": "The run-time library for lexers generated by <span class=\"code\" >ocamllex<\/span>."}, "type": "sig  end", "module_structure": [{"comment": "<h6>Positions<\/h6>"}, {"type": {"name": "Lexing.position", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lexing.mli|1041"}, "info": {"description": "A value of type <span class=\"code\" >position<\/span> describes a point in a source file. <span class=\"code\" >pos_fname<\/span> is the file name; <span class=\"code\" >pos_lnum<\/span> is the line number; <span class=\"code\" >pos_bol<\/span> is the offset of the beginning of the line (number of characters between the beginning of the file and the beginning of the line); <span class=\"code\" >pos_cnum<\/span> is the offset of the position (number of characters between the beginning of the file and the position).<br><\/br> See the documentation of type <span class=\"code\" >lexbuf<\/span> for information about how the lexing engine will manage positions."}, "params": [], "kind": {"type": "record", "private": "false", "fields": [{"name": "pos_fname", "mutable": false, "type": "string"}, {"name": "pos_lnum", "mutable": false, "type": "int"}, {"name": "pos_bol", "mutable": false, "type": "int"}, {"name": "pos_cnum", "mutable": false, "type": "int"}]}}}, {"value": {"name": "Lexing.dummy_pos", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lexing.mli|1649"}, "info": {"description": "A value of type <span class=\"code\" >position<\/span>, guaranteed to be different from any valid position."}, "type": "Lexing.position", "params": []}}, {"comment": "<h6>Lexer buffers<\/h6>"}, {"type": {"name": "Lexing.lexbuf", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lexing.mli|1801"}, "info": {"description": "The type of lexer buffers. A lexer buffer is the argument passed to the scanning functions defined by the generated scanners. The lexer buffer holds the current state of the scanner, plus a function to refill the buffer from the input.<br><\/br> At each token, the lexing engine will copy <span class=\"code\" >lex_curr_p<\/span> to <span class=\"code\" >lex_start_p<\/span>, then change the <span class=\"code\" >pos_cnum<\/span> field of <span class=\"code\" >lex_curr_p<\/span> by updating it with the number of characters read since the start of the <span class=\"code\" >lexbuf<\/span>.  The other fields are left unchanged by the lexing engine.  In order to keep them accurate, they must be initialised before the first use of the lexbuf, and updated by the relevant lexer actions (i.e. at each end of line -- see also <span class=\"code\" >new_line<\/span>)."}, "params": [], "kind": {"type": "record", "private": "false", "fields": [{"name": "refill_buff", "mutable": false, "type": "Lexing.lexbuf -> unit"}, {"name": "lex_buffer", "mutable": true, "type": "string"}, {"name": "lex_buffer_len", "mutable": true, "type": "int"}, {"name": "lex_abs_pos", "mutable": true, "type": "int"}, {"name": "lex_start_pos", "mutable": true, "type": "int"}, {"name": "lex_curr_pos", "mutable": true, "type": "int"}, {"name": "lex_last_pos", "mutable": true, "type": "int"}, {"name": "lex_last_action", "mutable": true, "type": "int"}, {"name": "lex_eof_reached", "mutable": true, "type": "bool"}, {"name": "lex_mem", "mutable": true, "type": "int array"}, {"name": "lex_start_p", "mutable": true, "type": "Lexing.position"}, {"name": "lex_curr_p", "mutable": true, "type": "Lexing.position"}]}}}, {"value": {"name": "Lexing.from_string", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lexing.mli|2949"}, "info": {"description": "Create a lexer buffer which reads from the given string. Reading starts from the first character in the string. An end-of-input condition is generated when the end of the string is reached."}, "type": "string -> Lexing.lexbuf", "params": [{"name": "", "type": "string"}]}}, {"value": {"name": "Lexing.from_function", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lexing.mli|3191"}, "info": {"description": "Create a lexer buffer with the given function as its reading method. When the scanner needs more characters, it will call the given function, giving it a character string <span class=\"code\" >s<\/span> and a character count <span class=\"code\" >n<\/span>. The function should put <span class=\"code\" >n<\/span> characters or less in <span class=\"code\" >s<\/span>, starting at character number 0, and return the number of characters provided. A return value of 0 means end of input."}, "type": "(string -> int -> int) -> Lexing.lexbuf", "params": [{"name": "", "type": "string -> int -> int"}]}}, {"comment": "<h6>Functions for lexer semantic actions<\/h6>"}, {"comment": "The following functions can be called from the semantic actions of lexer definitions (the ML code enclosed in braces that computes the value returned by lexing functions). They give access to the character string matched by the regular expression associated with the semantic action. These functions must be applied to the argument <span class=\"code\" >lexbuf<\/span>, which, in the code generated by <span class=\"code\" >ocamllex<\/span>, is bound to the lexer buffer passed to the parsing function."}, {"value": {"name": "Lexing.lexeme", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lexing.mli|4169"}, "info": {"description": "<span class=\"code\" >Lexing.lexeme lexbuf<\/span> returns the string matched by the regular expression."}, "type": "Lexing.lexbuf -> string", "params": [{"name": "", "type": "Lexing.lexbuf"}]}}, {"value": {"name": "Lexing.lexeme_char", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lexing.mli|4295"}, "info": {"description": "<span class=\"code\" >Lexing.lexeme_char lexbuf i<\/span> returns character number <span class=\"code\" >i<\/span> in the matched string."}, "type": "Lexing.lexbuf -> int -> char", "params": [{"name": "", "type": "Lexing.lexbuf"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Lexing.lexeme_start", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lexing.mli|4428"}, "info": {"description": "<span class=\"code\" >Lexing.lexeme_start lexbuf<\/span> returns the offset in the input stream of the first character of the matched string. The first character of the stream has offset 0."}, "type": "Lexing.lexbuf -> int", "params": [{"name": "", "type": "Lexing.lexbuf"}]}}, {"value": {"name": "Lexing.lexeme_end", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lexing.mli|4637"}, "info": {"description": "<span class=\"code\" >Lexing.lexeme_end lexbuf<\/span> returns the offset in the input stream of the character following the last character of the matched string. The first character of the stream has offset 0."}, "type": "Lexing.lexbuf -> int", "params": [{"name": "", "type": "Lexing.lexbuf"}]}}, {"value": {"name": "Lexing.lexeme_start_p", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lexing.mli|4865"}, "info": {"description": "Like <span class=\"code\" >lexeme_start<\/span>, but return a complete <span class=\"code\" >position<\/span> instead of an offset."}, "type": "Lexing.lexbuf -> Lexing.position", "params": [{"name": "", "type": "Lexing.lexbuf"}]}}, {"value": {"name": "Lexing.lexeme_end_p", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lexing.mli|4993"}, "info": {"description": "Like <span class=\"code\" >lexeme_end<\/span>, but return a complete <span class=\"code\" >position<\/span> instead of an offset."}, "type": "Lexing.lexbuf -> Lexing.position", "params": [{"name": "", "type": "Lexing.lexbuf"}]}}, {"value": {"name": "Lexing.new_line", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lexing.mli|5117"}, "info": {"description": "Update the <span class=\"code\" >lex_curr_p<\/span> field of the lexbuf to reflect the start of a new line.  You can call this function in the semantic action of the rule that matches the end-of-line character.", "since": "3.11.0"}, "type": "Lexing.lexbuf -> unit", "params": [{"name": "", "type": "Lexing.lexbuf"}]}}, {"comment": "<h6>Miscellaneous functions<\/h6>"}, {"value": {"name": "Lexing.flush_input", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lexing.mli|5400"}, "info": {"description": "Discard the contents of the buffer and reset the current position to 0.  The next use of the lexbuf will trigger a refill."}, "type": "Lexing.lexbuf -> unit", "params": [{"name": "", "type": "Lexing.lexbuf"}]}}], "dependencies": {"uses": [], "used_by": ["Parsing", "Dns"]}}}, "Int64": {"module": {"name": "Int64", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/int64.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/int64.mli|0"}, "info": {"description": "64-bit integers.<br><\/br> This module provides operations on the type <span class=\"code\" >int64<\/span> of signed 64-bit integers.  Unlike the built-in <span class=\"code\" >int<\/span> type, the type <span class=\"code\" >int64<\/span> is guaranteed to be exactly 64-bit wide on all platforms.  All arithmetic operations over <span class=\"code\" >int64<\/span> are taken modulo 2<sup>64<\/sup><br><\/br> Performance notice: values of type <span class=\"code\" >int64<\/span> occupy more memory space than values of type <span class=\"code\" >int<\/span>, and arithmetic operations on <span class=\"code\" >int64<\/span> are generally slower than those on <span class=\"code\" >int<\/span>.  Use <span class=\"code\" >int64<\/span> only when the application requires exact 64-bit arithmetic."}, "type": "sig  end", "module_structure": [{"value": {"name": "Int64.zero", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/int64.mli|1499"}, "info": {"description": "The 64-bit integer 0."}, "type": "int64", "params": []}}, {"value": {"name": "Int64.one", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/int64.mli|1546"}, "info": {"description": "The 64-bit integer 1."}, "type": "int64", "params": []}}, {"value": {"name": "Int64.minus_one", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/int64.mli|1592"}, "info": {"description": "The 64-bit integer -1."}, "type": "int64", "params": []}}, {"value": {"name": "Int64.neg", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/int64.mli|1645"}, "info": {"description": "Unary negation."}, "type": "int64 -> int64", "params": [{"name": "", "type": "int64"}]}}, {"value": {"name": "Int64.add", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/int64.mli|1714"}, "info": {"description": "Addition."}, "type": "int64 -> int64 -> int64", "params": [{"name": "", "type": "int64"}, {"name": "", "type": "int64"}]}}, {"value": {"name": "Int64.sub", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/int64.mli|1786"}, "info": {"description": "Subtraction."}, "type": "int64 -> int64 -> int64", "params": [{"name": "", "type": "int64"}, {"name": "", "type": "int64"}]}}, {"value": {"name": "Int64.mul", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/int64.mli|1861"}, "info": {"description": "Multiplication."}, "type": "int64 -> int64 -> int64", "params": [{"name": "", "type": "int64"}, {"name": "", "type": "int64"}]}}, {"value": {"name": "Int64.div", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/int64.mli|1939"}, "info": {"description": "Integer division.  Raise <span class=\"code\" >Division_by_zero<\/span> if the second argument is zero.  This division rounds the real quotient of its arguments towards zero, as specified for <a href=\"{value|Pervasives.(\/)}\" ><span class=\"code\" >Pervasives.(\/)<\/span><\/a>."}, "type": "int64 -> int64 -> int64", "params": [{"name": "", "type": "int64"}, {"name": "", "type": "int64"}]}}, {"value": {"name": "Int64.rem", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/int64.mli|2190"}, "info": {"description": "Integer remainder.  If <span class=\"code\" >y<\/span> is not zero, the result of <span class=\"code\" >Int64.rem x y<\/span> satisfies the following property: <span class=\"code\" >x = Int64.add (Int64.mul (Int64.div x y) y) (Int64.rem x y)<\/span>. If <span class=\"code\" >y = 0<\/span>, <span class=\"code\" >Int64.rem x y<\/span> raises <span class=\"code\" >Division_by_zero<\/span>."}, "type": "int64 -> int64 -> int64", "params": [{"name": "", "type": "int64"}, {"name": "", "type": "int64"}]}}, {"value": {"name": "Int64.succ", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/int64.mli|2483"}, "info": {"description": "Successor.  <span class=\"code\" >Int64.succ x<\/span> is <span class=\"code\" >Int64.add x Int64.one<\/span>."}, "type": "int64 -> int64", "params": [{"name": "", "type": "int64"}]}}, {"value": {"name": "Int64.pred", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/int64.mli|2572"}, "info": {"description": "Predecessor.  <span class=\"code\" >Int64.pred x<\/span> is <span class=\"code\" >Int64.sub x Int64.one<\/span>."}, "type": "int64 -> int64", "params": [{"name": "", "type": "int64"}]}}, {"value": {"name": "Int64.abs", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/int64.mli|2663"}, "info": {"description": "Return the absolute value of its argument."}, "type": "int64 -> int64", "params": [{"name": "", "type": "int64"}]}}, {"value": {"name": "Int64.max_int", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/int64.mli|2739"}, "info": {"description": "The greatest representable 64-bit integer, 2<sup>63<\/sup> - 1."}, "type": "int64", "params": []}}, {"value": {"name": "Int64.min_int", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/int64.mli|2822"}, "info": {"description": "The smallest representable 64-bit integer, -2<sup>63<\/sup>."}, "type": "int64", "params": []}}, {"value": {"name": "Int64.logand", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/int64.mli|2902"}, "info": {"description": "Bitwise logical and."}, "type": "int64 -> int64 -> int64", "params": [{"name": "", "type": "int64"}, {"name": "", "type": "int64"}]}}, {"value": {"name": "Int64.logor", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/int64.mli|2988"}, "info": {"description": "Bitwise logical or."}, "type": "int64 -> int64 -> int64", "params": [{"name": "", "type": "int64"}, {"name": "", "type": "int64"}]}}, {"value": {"name": "Int64.logxor", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/int64.mli|3071"}, "info": {"description": "Bitwise logical exclusive or."}, "type": "int64 -> int64 -> int64", "params": [{"name": "", "type": "int64"}, {"name": "", "type": "int64"}]}}, {"value": {"name": "Int64.lognot", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/int64.mli|3166"}, "info": {"description": "Bitwise logical negation"}, "type": "int64 -> int64", "params": [{"name": "", "type": "int64"}]}}, {"value": {"name": "Int64.shift_left", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/int64.mli|3227"}, "info": {"description": "<span class=\"code\" >Int64.shift_left x y<\/span> shifts <span class=\"code\" >x<\/span> to the left by <span class=\"code\" >y<\/span> bits. The result is unspecified if <span class=\"code\" >y &lt; 0<\/span> or <span class=\"code\" >y &gt;= 64<\/span>."}, "type": "int64 -> int -> int64", "params": [{"name": "", "type": "int64"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Int64.shift_right", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/int64.mli|3407"}, "info": {"description": "<span class=\"code\" >Int64.shift_right x y<\/span> shifts <span class=\"code\" >x<\/span> to the right by <span class=\"code\" >y<\/span> bits. This is an arithmetic shift: the sign bit of <span class=\"code\" >x<\/span> is replicated and inserted in the vacated bits. The result is unspecified if <span class=\"code\" >y &lt; 0<\/span> or <span class=\"code\" >y &gt;= 64<\/span>."}, "type": "int64 -> int -> int64", "params": [{"name": "", "type": "int64"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Int64.shift_right_logical", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/int64.mli|3693"}, "info": {"description": "<span class=\"code\" >Int64.shift_right_logical x y<\/span> shifts <span class=\"code\" >x<\/span> to the right by <span class=\"code\" >y<\/span> bits. This is a logical shift: zeroes are inserted in the vacated bits regardless of the sign of <span class=\"code\" >x<\/span>. The result is unspecified if <span class=\"code\" >y &lt; 0<\/span> or <span class=\"code\" >y &gt;= 64<\/span>."}, "type": "int64 -> int -> int64", "params": [{"name": "", "type": "int64"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Int64.of_int", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/int64.mli|3994"}, "info": {"description": "Convert the given integer (type <span class=\"code\" >int<\/span>) to a 64-bit integer (type <span class=\"code\" >int64<\/span>)."}, "type": "int -> int64", "params": [{"name": "", "type": "int"}]}}, {"value": {"name": "Int64.to_int", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/int64.mli|4130"}, "info": {"description": "Convert the given 64-bit integer (type <span class=\"code\" >int64<\/span>) to an integer (type <span class=\"code\" >int<\/span>).  On 64-bit platforms, the 64-bit integer is taken modulo 2<sup>63<\/sup>, i.e. the high-order bit is lost during the conversion.  On 32-bit platforms, the 64-bit integer is taken modulo 2<sup>31<\/sup>, i.e. the top 33 bits are lost during the conversion."}, "type": "int64 -> int", "params": [{"name": "", "type": "int64"}]}}, {"value": {"name": "Int64.of_float", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/int64.mli|4516"}, "info": {"description": "Convert the given floating-point number to a 64-bit integer, discarding the fractional part (truncate towards 0). The result of the conversion is undefined if, after truncation, the number is outside the range [<a href=\"{value|Int64.min_int}\" ><span class=\"code\" >Int64.min_int<\/span><\/a>, <a href=\"{value|Int64.max_int}\" ><span class=\"code\" >Int64.max_int<\/span><\/a>]."}, "type": "float -> int64", "params": [{"name": "", "type": "float"}]}}, {"value": {"name": "Int64.to_float", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/int64.mli|4842"}, "info": {"description": "Convert the given 64-bit integer to a floating-point number."}, "type": "int64 -> float", "params": [{"name": "", "type": "int64"}]}}, {"value": {"name": "Int64.of_int32", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/int64.mli|4971"}, "info": {"description": "Convert the given 32-bit integer (type <span class=\"code\" >int32<\/span>) to a 64-bit integer (type <span class=\"code\" >int64<\/span>)."}, "type": "int32 -> int64", "params": [{"name": "", "type": "int32"}]}}, {"value": {"name": "Int64.to_int32", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/int64.mli|5121"}, "info": {"description": "Convert the given 64-bit integer (type <span class=\"code\" >int64<\/span>) to a 32-bit integer (type <span class=\"code\" >int32<\/span>). The 64-bit integer is taken modulo 2<sup>32<\/sup>, i.e. the top 32 bits are lost during the conversion."}, "type": "int64 -> int32", "params": [{"name": "", "type": "int64"}]}}, {"value": {"name": "Int64.of_nativeint", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/int64.mli|5374"}, "info": {"description": "Convert the given native integer (type <span class=\"code\" >nativeint<\/span>) to a 64-bit integer (type <span class=\"code\" >int64<\/span>)."}, "type": "nativeint -> int64", "params": [{"name": "", "type": "nativeint"}]}}, {"value": {"name": "Int64.to_nativeint", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/int64.mli|5540"}, "info": {"description": "Convert the given 64-bit integer (type <span class=\"code\" >int64<\/span>) to a native integer.  On 32-bit platforms, the 64-bit integer is taken modulo 2<sup>32<\/sup>.  On 64-bit platforms, the conversion is exact."}, "type": "int64 -> nativeint", "params": [{"name": "", "type": "int64"}]}}, {"value": {"name": "Int64.of_string", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/int64.mli|5805"}, "info": {"description": "Convert the given string to a 64-bit integer. The string is read in decimal (by default) or in hexadecimal, octal or binary if the string begins with <span class=\"code\" >0x<\/span>, <span class=\"code\" >0o<\/span> or <span class=\"code\" >0b<\/span> respectively. Raise <span class=\"code\" >Failure \"int_of_string\"<\/span> if the given string is not a valid representation of an integer, or if the integer represented exceeds the range of integers representable in type <span class=\"code\" >int64<\/span>."}, "type": "string -> int64", "params": [{"name": "", "type": "string"}]}}, {"value": {"name": "Int64.to_string", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/int64.mli|6264"}, "info": {"description": "Return the string representation of its argument, in decimal."}, "type": "int64 -> string", "params": [{"name": "", "type": "int64"}]}}, {"value": {"name": "Int64.bits_of_float", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/int64.mli|6366"}, "info": {"description": "Return the internal representation of the given float according to the IEEE 754 floating-point ``double format'' bit layout. Bit 63 of the result represents the sign of the float; bits 62 to 52 represent the (biased) exponent; bits 51 to 0 represent the mantissa."}, "type": "float -> int64", "params": [{"name": "", "type": "float"}]}}, {"value": {"name": "Int64.float_of_bits", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/int64.mli|6719"}, "info": {"description": "Return the floating-point number whose internal representation, according to the IEEE 754 floating-point ``double format'' bit layout, is the given <span class=\"code\" >int64<\/span>."}, "type": "int64 -> float", "params": [{"name": "", "type": "int64"}]}}, {"type": {"name": "Int64.t", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/int64.mli|6964"}, "info": {"description": "An alias for the type of 64-bit integers."}, "params": [], "kind": {"type": "abstract"}, "manifest": "int64"}}, {"value": {"name": "Int64.compare", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/int64.mli|7024"}, "info": {"description": "The comparison function for 64-bit integers, with the same specification as <a href=\"{value|Pervasives.compare}\" ><span class=\"code\" >Pervasives.compare<\/span><\/a>.  Along with the type <span class=\"code\" >t<\/span>, this function <span class=\"code\" >compare<\/span> allows the module <span class=\"code\" >Int64<\/span> to be passed as argument to the functors <a href=\"{module|Set.Make}\" ><span class=\"code\" >Set.Make<\/span><\/a> and <a href=\"{module|Map.Make}\" ><span class=\"code\" >Map.Make<\/span><\/a>."}, "type": "Int64.t -> Int64.t -> int", "params": [{"name": "", "type": "Int64.t"}, {"name": "", "type": "Int64.t"}]}}], "dependencies": {"uses": [], "used_by": ["Random"]}}}, "Int32": {"module": {"name": "Int32", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/int32.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/int32.mli|0"}, "info": {"description": "32-bit integers.<br><\/br> This module provides operations on the type <span class=\"code\" >int32<\/span> of signed 32-bit integers.  Unlike the built-in <span class=\"code\" >int<\/span> type, the type <span class=\"code\" >int32<\/span> is guaranteed to be exactly 32-bit wide on all platforms.  All arithmetic operations over <span class=\"code\" >int32<\/span> are taken modulo 2<sup>32<\/sup>.<br><\/br> Performance notice: values of type <span class=\"code\" >int32<\/span> occupy more memory space than values of type <span class=\"code\" >int<\/span>, and arithmetic operations on <span class=\"code\" >int32<\/span> are generally slower than those on <span class=\"code\" >int<\/span>.  Use <span class=\"code\" >int32<\/span> only when the application requires exact 32-bit arithmetic."}, "type": "sig  end", "module_structure": [{"value": {"name": "Int32.zero", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/int32.mli|1500"}, "info": {"description": "The 32-bit integer 0."}, "type": "int32", "params": []}}, {"value": {"name": "Int32.one", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/int32.mli|1547"}, "info": {"description": "The 32-bit integer 1."}, "type": "int32", "params": []}}, {"value": {"name": "Int32.minus_one", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/int32.mli|1593"}, "info": {"description": "The 32-bit integer -1."}, "type": "int32", "params": []}}, {"value": {"name": "Int32.neg", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/int32.mli|1646"}, "info": {"description": "Unary negation."}, "type": "int32 -> int32", "params": [{"name": "", "type": "int32"}]}}, {"value": {"name": "Int32.add", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/int32.mli|1715"}, "info": {"description": "Addition."}, "type": "int32 -> int32 -> int32", "params": [{"name": "", "type": "int32"}, {"name": "", "type": "int32"}]}}, {"value": {"name": "Int32.sub", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/int32.mli|1787"}, "info": {"description": "Subtraction."}, "type": "int32 -> int32 -> int32", "params": [{"name": "", "type": "int32"}, {"name": "", "type": "int32"}]}}, {"value": {"name": "Int32.mul", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/int32.mli|1862"}, "info": {"description": "Multiplication."}, "type": "int32 -> int32 -> int32", "params": [{"name": "", "type": "int32"}, {"name": "", "type": "int32"}]}}, {"value": {"name": "Int32.div", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/int32.mli|1940"}, "info": {"description": "Integer division.  Raise <span class=\"code\" >Division_by_zero<\/span> if the second argument is zero.  This division rounds the real quotient of its arguments towards zero, as specified for <a href=\"{value|Pervasives.(\/)}\" ><span class=\"code\" >Pervasives.(\/)<\/span><\/a>."}, "type": "int32 -> int32 -> int32", "params": [{"name": "", "type": "int32"}, {"name": "", "type": "int32"}]}}, {"value": {"name": "Int32.rem", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/int32.mli|2191"}, "info": {"description": "Integer remainder.  If <span class=\"code\" >y<\/span> is not zero, the result of <span class=\"code\" >Int32.rem x y<\/span> satisfies the following property: <span class=\"code\" >x = Int32.add (Int32.mul (Int32.div x y) y) (Int32.rem x y)<\/span>. If <span class=\"code\" >y = 0<\/span>, <span class=\"code\" >Int32.rem x y<\/span> raises <span class=\"code\" >Division_by_zero<\/span>."}, "type": "int32 -> int32 -> int32", "params": [{"name": "", "type": "int32"}, {"name": "", "type": "int32"}]}}, {"value": {"name": "Int32.succ", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/int32.mli|2484"}, "info": {"description": "Successor.  <span class=\"code\" >Int32.succ x<\/span> is <span class=\"code\" >Int32.add x Int32.one<\/span>."}, "type": "int32 -> int32", "params": [{"name": "", "type": "int32"}]}}, {"value": {"name": "Int32.pred", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/int32.mli|2573"}, "info": {"description": "Predecessor.  <span class=\"code\" >Int32.pred x<\/span> is <span class=\"code\" >Int32.sub x Int32.one<\/span>."}, "type": "int32 -> int32", "params": [{"name": "", "type": "int32"}]}}, {"value": {"name": "Int32.abs", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/int32.mli|2664"}, "info": {"description": "Return the absolute value of its argument."}, "type": "int32 -> int32", "params": [{"name": "", "type": "int32"}]}}, {"value": {"name": "Int32.max_int", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/int32.mli|2740"}, "info": {"description": "The greatest representable 32-bit integer, 2<sup>31<\/sup> - 1."}, "type": "int32", "params": []}}, {"value": {"name": "Int32.min_int", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/int32.mli|2823"}, "info": {"description": "The smallest representable 32-bit integer, -2<sup>31<\/sup>."}, "type": "int32", "params": []}}, {"value": {"name": "Int32.logand", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/int32.mli|2904"}, "info": {"description": "Bitwise logical and."}, "type": "int32 -> int32 -> int32", "params": [{"name": "", "type": "int32"}, {"name": "", "type": "int32"}]}}, {"value": {"name": "Int32.logor", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/int32.mli|2990"}, "info": {"description": "Bitwise logical or."}, "type": "int32 -> int32 -> int32", "params": [{"name": "", "type": "int32"}, {"name": "", "type": "int32"}]}}, {"value": {"name": "Int32.logxor", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/int32.mli|3073"}, "info": {"description": "Bitwise logical exclusive or."}, "type": "int32 -> int32 -> int32", "params": [{"name": "", "type": "int32"}, {"name": "", "type": "int32"}]}}, {"value": {"name": "Int32.lognot", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/int32.mli|3168"}, "info": {"description": "Bitwise logical negation"}, "type": "int32 -> int32", "params": [{"name": "", "type": "int32"}]}}, {"value": {"name": "Int32.shift_left", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/int32.mli|3229"}, "info": {"description": "<span class=\"code\" >Int32.shift_left x y<\/span> shifts <span class=\"code\" >x<\/span> to the left by <span class=\"code\" >y<\/span> bits. The result is unspecified if <span class=\"code\" >y &lt; 0<\/span> or <span class=\"code\" >y &gt;= 32<\/span>."}, "type": "int32 -> int -> int32", "params": [{"name": "", "type": "int32"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Int32.shift_right", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/int32.mli|3409"}, "info": {"description": "<span class=\"code\" >Int32.shift_right x y<\/span> shifts <span class=\"code\" >x<\/span> to the right by <span class=\"code\" >y<\/span> bits. This is an arithmetic shift: the sign bit of <span class=\"code\" >x<\/span> is replicated and inserted in the vacated bits. The result is unspecified if <span class=\"code\" >y &lt; 0<\/span> or <span class=\"code\" >y &gt;= 32<\/span>."}, "type": "int32 -> int -> int32", "params": [{"name": "", "type": "int32"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Int32.shift_right_logical", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/int32.mli|3695"}, "info": {"description": "<span class=\"code\" >Int32.shift_right_logical x y<\/span> shifts <span class=\"code\" >x<\/span> to the right by <span class=\"code\" >y<\/span> bits. This is a logical shift: zeroes are inserted in the vacated bits regardless of the sign of <span class=\"code\" >x<\/span>. The result is unspecified if <span class=\"code\" >y &lt; 0<\/span> or <span class=\"code\" >y &gt;= 32<\/span>."}, "type": "int32 -> int -> int32", "params": [{"name": "", "type": "int32"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Int32.of_int", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/int32.mli|3996"}, "info": {"description": "Convert the given integer (type <span class=\"code\" >int<\/span>) to a 32-bit integer (type <span class=\"code\" >int32<\/span>)."}, "type": "int -> int32", "params": [{"name": "", "type": "int"}]}}, {"value": {"name": "Int32.to_int", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/int32.mli|4132"}, "info": {"description": "Convert the given 32-bit integer (type <span class=\"code\" >int32<\/span>) to an integer (type <span class=\"code\" >int<\/span>).  On 32-bit platforms, the 32-bit integer is taken modulo 2<sup>31<\/sup>, i.e. the high-order bit is lost during the conversion.  On 64-bit platforms, the conversion is exact."}, "type": "int32 -> int", "params": [{"name": "", "type": "int32"}]}}, {"value": {"name": "Int32.of_float", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/int32.mli|4444"}, "info": {"description": "Convert the given floating-point number to a 32-bit integer, discarding the fractional part (truncate towards 0). The result of the conversion is undefined if, after truncation, the number is outside the range [<a href=\"{value|Int32.min_int}\" ><span class=\"code\" >Int32.min_int<\/span><\/a>, <a href=\"{value|Int32.max_int}\" ><span class=\"code\" >Int32.max_int<\/span><\/a>]."}, "type": "float -> int32", "params": [{"name": "", "type": "float"}]}}, {"value": {"name": "Int32.to_float", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/int32.mli|4770"}, "info": {"description": "Convert the given 32-bit integer to a floating-point number."}, "type": "int32 -> float", "params": [{"name": "", "type": "int32"}]}}, {"value": {"name": "Int32.of_string", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/int32.mli|4898"}, "info": {"description": "Convert the given string to a 32-bit integer. The string is read in decimal (by default) or in hexadecimal, octal or binary if the string begins with <span class=\"code\" >0x<\/span>, <span class=\"code\" >0o<\/span> or <span class=\"code\" >0b<\/span> respectively. Raise <span class=\"code\" >Failure \"int_of_string\"<\/span> if the given string is not a valid representation of an integer, or if the integer represented exceeds the range of integers representable in type <span class=\"code\" >int32<\/span>."}, "type": "string -> int32", "params": [{"name": "", "type": "string"}]}}, {"value": {"name": "Int32.to_string", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/int32.mli|5357"}, "info": {"description": "Return the string representation of its argument, in signed decimal."}, "type": "int32 -> string", "params": [{"name": "", "type": "int32"}]}}, {"value": {"name": "Int32.bits_of_float", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/int32.mli|5466"}, "info": {"description": "Return the internal representation of the given float according to the IEEE 754 floating-point ``single format'' bit layout. Bit 31 of the result represents the sign of the float; bits 30 to 23 represent the (biased) exponent; bits 22 to 0 represent the mantissa."}, "type": "float -> int32", "params": [{"name": "", "type": "float"}]}}, {"value": {"name": "Int32.float_of_bits", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/int32.mli|5819"}, "info": {"description": "Return the floating-point number whose internal representation, according to the IEEE 754 floating-point ``single format'' bit layout, is the given <span class=\"code\" >int32<\/span>."}, "type": "int32 -> float", "params": [{"name": "", "type": "int32"}]}}, {"type": {"name": "Int32.t", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/int32.mli|6064"}, "info": {"description": "An alias for the type of 32-bit integers."}, "params": [], "kind": {"type": "abstract"}, "manifest": "int32"}}, {"value": {"name": "Int32.compare", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/int32.mli|6124"}, "info": {"description": "The comparison function for 32-bit integers, with the same specification as <a href=\"{value|Pervasives.compare}\" ><span class=\"code\" >Pervasives.compare<\/span><\/a>.  Along with the type <span class=\"code\" >t<\/span>, this function <span class=\"code\" >compare<\/span> allows the module <span class=\"code\" >Int32<\/span> to be passed as argument to the functors <a href=\"{module|Set.Make}\" ><span class=\"code\" >Set.Make<\/span><\/a> and <a href=\"{module|Map.Make}\" ><span class=\"code\" >Map.Make<\/span><\/a>."}, "type": "Int32.t -> Int32.t -> int", "params": [{"name": "", "type": "Int32.t"}, {"name": "", "type": "Int32.t"}]}}], "dependencies": {"uses": [], "used_by": ["Random", "Obj"]}}}, "Hashtbl": {"module": {"name": "Hashtbl", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/hashtbl.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/hashtbl.mli|0"}, "info": {"description": "Hash tables and hash functions.<br><\/br> Hash tables are hashed association tables, with in-place modification."}, "type": "sig  end", "module_structure": [{"comment": "<h6>Generic interface<\/h6>"}, {"type": {"name": "Hashtbl.t", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/hashtbl.mli|1101"}, "info": {"description": "The type of hash tables from type <span class=\"code\" >'a<\/span> to type <span class=\"code\" >'b<\/span>."}, "params": [{"covariant": "true", "contravariant": "true", "type": "'a"}, {"covariant": "true", "contravariant": "true", "type": "'b"}], "kind": {"type": "abstract"}}}, {"value": {"name": "Hashtbl.create", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/hashtbl.mli|1173"}, "info": {"description": "<span class=\"code\" >Hashtbl.create n<\/span> creates a new, empty hash table, with initial size <span class=\"code\" >n<\/span>.  For best results, <span class=\"code\" >n<\/span> should be on the order of the expected number of elements that will be in the table.  The table grows as needed, so <span class=\"code\" >n<\/span> is just an initial guess."}, "type": "int -> ('a, 'b) Hashtbl.t", "params": [{"name": "", "type": "int"}]}}, {"value": {"name": "Hashtbl.clear", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/hashtbl.mli|1468"}, "info": {"description": "Empty a hash table."}, "type": "('a, 'b) Hashtbl.t -> unit", "params": [{"name": "", "type": "('a, 'b) Hashtbl.t"}]}}, {"value": {"name": "Hashtbl.add", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/hashtbl.mli|1528"}, "info": {"description": "<span class=\"code\" >Hashtbl.add tbl x y<\/span> adds a binding of <span class=\"code\" >x<\/span> to <span class=\"code\" >y<\/span> in table <span class=\"code\" >tbl<\/span>. Previous bindings for <span class=\"code\" >x<\/span> are not removed, but simply hidden. That is, after performing <a href=\"{value|Hashtbl.remove}\" ><span class=\"code\" >Hashtbl.remove<\/span><\/a><span class=\"code\" > tbl x<\/span>, the previous binding for <span class=\"code\" >x<\/span>, if any, is restored. (Same behavior as with association lists.)"}, "type": "('a, 'b) Hashtbl.t -> 'a -> 'b -> unit", "params": [{"name": "", "type": "('a, 'b) Hashtbl.t"}, {"name": "", "type": "'a"}, {"name": "", "type": "'a"}]}}, {"value": {"name": "Hashtbl.copy", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/hashtbl.mli|1865"}, "info": {"description": "Return a copy of the given hashtable."}, "type": "('a, 'b) Hashtbl.t -> ('a, 'b) Hashtbl.t", "params": [{"name": "", "type": "('a, 'b) Hashtbl.t"}]}}, {"value": {"name": "Hashtbl.find", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/hashtbl.mli|1947"}, "info": {"description": "<span class=\"code\" >Hashtbl.find tbl x<\/span> returns the current binding of <span class=\"code\" >x<\/span> in <span class=\"code\" >tbl<\/span>, or raises <span class=\"code\" >Not_found<\/span> if no such binding exists."}, "type": "('a, 'b) Hashtbl.t -> 'a -> 'b", "params": [{"name": "", "type": "('a, 'b) Hashtbl.t"}, {"name": "", "type": "'a"}]}}, {"value": {"name": "Hashtbl.find_all", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/hashtbl.mli|2107"}, "info": {"description": "<span class=\"code\" >Hashtbl.find_all tbl x<\/span> returns the list of all data associated with <span class=\"code\" >x<\/span> in <span class=\"code\" >tbl<\/span>. The current binding is returned first, then the previous bindings, in reverse order of introduction in the table."}, "type": "('a, 'b) Hashtbl.t -> 'a -> 'b list", "params": [{"name": "", "type": "('a, 'b) Hashtbl.t"}, {"name": "", "type": "'a"}]}}, {"value": {"name": "Hashtbl.mem", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/hashtbl.mli|2365"}, "info": {"description": "<span class=\"code\" >Hashtbl.mem tbl x<\/span> checks if <span class=\"code\" >x<\/span> is bound in <span class=\"code\" >tbl<\/span>."}, "type": "('a, 'b) Hashtbl.t -> 'a -> bool", "params": [{"name": "", "type": "('a, 'b) Hashtbl.t"}, {"name": "", "type": "'a"}]}}, {"value": {"name": "Hashtbl.remove", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/hashtbl.mli|2461"}, "info": {"description": "<span class=\"code\" >Hashtbl.remove tbl x<\/span> removes the current binding of <span class=\"code\" >x<\/span> in <span class=\"code\" >tbl<\/span>, restoring the previous binding if it exists. It does nothing if <span class=\"code\" >x<\/span> is not bound in <span class=\"code\" >tbl<\/span>."}, "type": "('a, 'b) Hashtbl.t -> 'a -> unit", "params": [{"name": "", "type": "('a, 'b) Hashtbl.t"}, {"name": "", "type": "'a"}]}}, {"value": {"name": "Hashtbl.replace", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/hashtbl.mli|2672"}, "info": {"description": "<span class=\"code\" >Hashtbl.replace tbl x y<\/span> replaces the current binding of <span class=\"code\" >x<\/span> in <span class=\"code\" >tbl<\/span> by a binding of <span class=\"code\" >x<\/span> to <span class=\"code\" >y<\/span>.  If <span class=\"code\" >x<\/span> is unbound in <span class=\"code\" >tbl<\/span>, a binding of <span class=\"code\" >x<\/span> to <span class=\"code\" >y<\/span> is added to <span class=\"code\" >tbl<\/span>. This is functionally equivalent to <a href=\"{value|Hashtbl.remove}\" ><span class=\"code\" >Hashtbl.remove<\/span><\/a><span class=\"code\" > tbl x<\/span> followed by <a href=\"{value|Hashtbl.add}\" ><span class=\"code\" >Hashtbl.add<\/span><\/a><span class=\"code\" > tbl x y<\/span>."}, "type": "('a, 'b) Hashtbl.t -> 'a -> 'b -> unit", "params": [{"name": "", "type": "('a, 'b) Hashtbl.t"}, {"name": "", "type": "'a"}, {"name": "", "type": "'a"}]}}, {"value": {"name": "Hashtbl.iter", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/hashtbl.mli|3007"}, "info": {"description": "<span class=\"code\" >Hashtbl.iter f tbl<\/span> applies <span class=\"code\" >f<\/span> to all bindings in table <span class=\"code\" >tbl<\/span>. <span class=\"code\" >f<\/span> receives the key as first argument, and the associated value as second argument. Each binding is presented exactly once to <span class=\"code\" >f<\/span>. The order in which the bindings are passed to <span class=\"code\" >f<\/span> is unspecified. However, if the table contains several bindings for the same key, they are passed to <span class=\"code\" >f<\/span> in reverse order of introduction, that is, the most recent binding is passed first."}, "type": "('a -> 'b -> unit) -> ('a, 'b) Hashtbl.t -> unit", "params": [{"name": "", "type": "'a -> 'b -> unit"}, {"name": "", "type": "('a, 'b) Hashtbl.t"}]}}, {"value": {"name": "Hashtbl.fold", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/hashtbl.mli|3521"}, "info": {"description": "<span class=\"code\" >Hashtbl.fold f tbl init<\/span> computes <span class=\"code\" >(f kN dN ... (f k1 d1 init)...)<\/span>, where <span class=\"code\" >k1 ... kN<\/span> are the keys of all bindings in <span class=\"code\" >tbl<\/span>, and <span class=\"code\" >d1 ... dN<\/span> are the associated values. Each binding is presented exactly once to <span class=\"code\" >f<\/span>. The order in which the bindings are passed to <span class=\"code\" >f<\/span> is unspecified. However, if the table contains several bindings for the same key, they are passed to <span class=\"code\" >f<\/span> in reverse order of introduction, that is, the most recent binding is passed first."}, "type": "('a -> 'b -> 'c -> 'c) -> ('a, 'b) Hashtbl.t -> 'c -> 'c", "params": [{"name": "", "type": "'a -> 'b -> 'c -> 'c"}, {"name": "", "type": "('a, 'b) Hashtbl.t"}, {"name": "", "type": "'a"}]}}, {"value": {"name": "Hashtbl.length", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/hashtbl.mli|4070"}, "info": {"description": "<span class=\"code\" >Hashtbl.length tbl<\/span> returns the number of bindings in <span class=\"code\" >tbl<\/span>. Multiple bindings are counted multiply, so <span class=\"code\" >Hashtbl.length<\/span> gives the number of times <span class=\"code\" >Hashtbl.iter<\/span> calls its first argument."}, "type": "('a, 'b) Hashtbl.t -> int", "params": [{"name": "", "type": "('a, 'b) Hashtbl.t"}]}}, {"comment": "<h6>Functorial interface<\/h6>"}, {"module_type": {"name": "Hashtbl.HashedType", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/hashtbl.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/hashtbl.mli|4339"}, "info": {"description": "The input signature of the functor <a href=\"{module|Hashtbl.Make}\" ><span class=\"code\" >Hashtbl.Make<\/span><\/a>."}, "type": "sig  end", "kind": ""}}, {"module_type": {"name": "Hashtbl.S", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/hashtbl.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/hashtbl.mli|5224"}, "info": {"description": "The output signature of the functor <a href=\"{module|Hashtbl.Make}\" ><span class=\"code\" >Hashtbl.Make<\/span><\/a>."}, "type": "sig  end", "kind": ""}}, {"module": {"name": "Hashtbl.Make", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/hashtbl.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/hashtbl.mli|5795"}, "info": {"description": "Functor building an implementation of the hashtable structure. The functor <span class=\"code\" >Hashtbl.Make<\/span> returns a structure containing a type <span class=\"code\" >key<\/span> of keys and a type <span class=\"code\" >'a t<\/span> of hash tables associating data of type <span class=\"code\" >'a<\/span> to keys of type <span class=\"code\" >key<\/span>. The operations perform similarly to those of the generic interface, but use the hashing and equality functions specified in the functor argument <span class=\"code\" >H<\/span> instead of generic equality and hashing."}, "type": "functor (H : HashedType) -> sig  end", "module_functor": {"parameter": {"name": "H"}, "module_with": "unavailable"}, "dependencies": {"uses": []}}}, {"comment": "<h6>The polymorphic hash primitive<\/h6>"}, {"value": {"name": "Hashtbl.hash", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/hashtbl.mli|6347"}, "info": {"description": "<span class=\"code\" >Hashtbl.hash x<\/span> associates a positive integer to any value of any type. It is guaranteed that if <span class=\"code\" >x = y<\/span> or <span class=\"code\" >Pervasives.compare x y = 0<\/span>, then <span class=\"code\" >hash x = hash y<\/span>. Moreover, <span class=\"code\" >hash<\/span> always terminates, even on cyclic structures."}, "type": "'a -> int", "params": [{"name": "", "type": "'a"}]}}, {"value": {"name": "Hashtbl.hash_param", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/hashtbl.mli|6614"}, "info": {"description": "<span class=\"code\" >Hashtbl.hash_param n m x<\/span> computes a hash value for <span class=\"code\" >x<\/span>, with the same properties as for <span class=\"code\" >hash<\/span>. The two extra parameters <span class=\"code\" >n<\/span> and <span class=\"code\" >m<\/span> give more precise control over hashing. Hashing performs a depth-first, right-to-left traversal of the structure <span class=\"code\" >x<\/span>, stopping after <span class=\"code\" >n<\/span> meaningful nodes were encountered, or <span class=\"code\" >m<\/span> nodes, meaningful or not, were encountered. Meaningful nodes are: integers; floating-point numbers; strings; characters; booleans; and constant constructors. Larger values of <span class=\"code\" >m<\/span> and <span class=\"code\" >n<\/span> means that more nodes are taken into account to compute the final hash value, and therefore collisions are less likely to happen. However, hashing takes longer. The parameters <span class=\"code\" >m<\/span> and <span class=\"code\" >n<\/span> govern the tradeoff between accuracy and speed."}, "type": "int -> int -> 'a -> int", "params": [{"name": "", "type": "int"}, {"name": "", "type": "int"}, {"name": "", "type": "'a"}]}}], "dependencies": {"uses": [], "used_by": ["Weak", "Dns", "Http"]}}}, "Gc": {"module": {"name": "Gc", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/gc.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/gc.mli|0"}, "info": {"description": "Memory management control and statistics; finalised values."}, "type": "sig  end", "module_structure": [{"type": {"name": "Gc.stat", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/gc.mli|1018"}, "info": {"description": "The memory management counters are returned in a <span class=\"code\" >stat<\/span> record.<br><\/br> The total amount of memory allocated by the program since it was started is (in words) <span class=\"code\" >minor_words + major_words - promoted_words<\/span>.  Multiply by the word size (4 on a 32-bit machine, 8 on a 64-bit machine) to get the number of bytes."}, "params": [], "kind": {"type": "record", "private": "false", "fields": [{"name": "minor_words", "mutable": false, "description": "Number of words allocated in the minor heap since the program was started.  This number is accurate in byte-code programs, but only an approximation in programs compiled to native code.", "type": "float"}, {"name": "promoted_words", "mutable": false, "description": "Number of words allocated in the minor heap that survived a minor collection and were moved to the major heap since the program was started.", "type": "float"}, {"name": "major_words", "mutable": false, "description": "Number of words allocated in the major heap, including the promoted words, since the program was started.", "type": "float"}, {"name": "minor_collections", "mutable": false, "description": "Number of minor collections since the program was started.", "type": "int"}, {"name": "major_collections", "mutable": false, "description": "Number of major collection cycles completed since the program was started.", "type": "int"}, {"name": "heap_words", "mutable": false, "description": "Total size of the major heap, in words.", "type": "int"}, {"name": "heap_chunks", "mutable": false, "description": "Number of contiguous pieces of memory that make up the major heap.", "type": "int"}, {"name": "live_words", "mutable": false, "description": "Number of words of live data in the major heap, including the header words.", "type": "int"}, {"name": "live_blocks", "mutable": false, "description": "Number of live blocks in the major heap.", "type": "int"}, {"name": "free_words", "mutable": false, "description": "Number of words in the free list.", "type": "int"}, {"name": "free_blocks", "mutable": false, "description": "Number of blocks in the free list.", "type": "int"}, {"name": "largest_free", "mutable": false, "description": "Size (in words) of the largest block in the free list.", "type": "int"}, {"name": "fragments", "mutable": false, "description": "Number of wasted words due to fragmentation.  These are 1-words free blocks placed between two live blocks.  They are not available for allocation.", "type": "int"}, {"name": "compactions", "mutable": false, "description": "Number of heap compactions since the program was started.", "type": "int"}, {"name": "top_heap_words", "mutable": false, "description": "Maximum size reached by the major heap, in words.", "type": "int"}, {"name": "stack_size", "mutable": false, "description": "Current size of the stack, in words.", "type": "int"}]}}}, {"type": {"name": "Gc.control", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/gc.mli|3222"}, "info": {"description": "The GC parameters are given as a <span class=\"code\" >control<\/span> record.  Note that these parameters can also be initialised by setting the OCAMLRUNPARAM environment variable.  See the documentation of ocamlrun."}, "params": [], "kind": {"type": "record", "private": "false", "fields": [{"name": "minor_heap_size", "mutable": true, "description": "The size (in words) of the minor heap.  Changing this parameter will trigger a minor collection.  Default: 32k.", "type": "int"}, {"name": "major_heap_increment", "mutable": true, "description": "The minimum number of words to add to the major heap when increasing it.  Default: 124k.", "type": "int"}, {"name": "space_overhead", "mutable": true, "description": "The major GC speed is computed from this parameter. This is the memory that will be \"wasted\" because the GC does not immediatly collect unreachable blocks.  It is expressed as a percentage of the memory used for live data. The GC will work more (use more CPU time and collect blocks more eagerly) if <span class=\"code\" >space_overhead<\/span> is smaller. Default: 80.", "type": "int"}, {"name": "verbose", "mutable": true, "description": "This value controls the GC messages on standard error output. It is a sum of some of the following flags, to print messages on the corresponding events:<ul><li><span class=\"code\" >0x001<\/span> Start of major GC cycle.<\/li><li><span class=\"code\" >0x002<\/span> Minor collection and major GC slice.<\/li><li><span class=\"code\" >0x004<\/span> Growing and shrinking of the heap.<\/li><li><span class=\"code\" >0x008<\/span> Resizing of stacks and memory manager tables.<\/li><li><span class=\"code\" >0x010<\/span> Heap compaction.<\/li><li><span class=\"code\" >0x020<\/span> Change of GC parameters.<\/li><li><span class=\"code\" >0x040<\/span> Computation of major GC slice size.<\/li><li><span class=\"code\" >0x080<\/span> Calling of finalisation functions.<\/li><li><span class=\"code\" >0x100<\/span> Bytecode executable search at start-up.<\/li><li><span class=\"code\" >0x200<\/span> Computation of compaction triggering condition. Default: 0.<\/li><\/ul>", "type": "int"}, {"name": "max_overhead", "mutable": true, "description": "Heap compaction is triggered when the estimated amount of \"wasted\" memory is more than <span class=\"code\" >max_overhead<\/span> percent of the amount of live data.  If <span class=\"code\" >max_overhead<\/span> is set to 0, heap compaction is triggered at the end of each major GC cycle (this setting is intended for testing purposes only). If <span class=\"code\" >max_overhead &gt;= 1000000<\/span>, compaction is never triggered. Default: 500.", "type": "int"}, {"name": "stack_limit", "mutable": true, "description": "The maximum size of the stack (in words).  This is only relevant to the byte-code runtime, as the native code runtime uses the operating system's stack.  Default: 256k.", "type": "int"}, {"name": "allocation_policy", "mutable": true, "description": "The policy used for allocating in the heap.  Possible values are 0 and 1.  0 is the next-fit policy, which is quite fast but can result in fragmentation.  1 is the first-fit policy, which can be slower in some cases but can be better for programs with fragmentation problems. Default: 0.", "type": "int"}]}}}, {"value": {"name": "Gc.stat", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/gc.mli|5991"}, "info": {"description": "Return the current values of the memory management counters in a <span class=\"code\" >stat<\/span> record.  This function examines every heap block to get the statistics."}, "type": "unit -> Gc.stat", "params": [{"name": "", "type": "unit"}]}}, {"value": {"name": "Gc.quick_stat", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/gc.mli|6195"}, "info": {"description": "Same as <span class=\"code\" >stat<\/span> except that <span class=\"code\" >live_words<\/span>, <span class=\"code\" >live_blocks<\/span>, <span class=\"code\" >free_words<\/span>, <span class=\"code\" >free_blocks<\/span>, <span class=\"code\" >largest_free<\/span>, and <span class=\"code\" >fragments<\/span> are set to 0.  This function is much faster than <span class=\"code\" >stat<\/span> because it does not need to go through the heap."}, "type": "unit -> Gc.stat", "params": [{"name": "", "type": "unit"}]}}, {"value": {"name": "Gc.counters", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/gc.mli|6495"}, "info": {"description": "Return <span class=\"code\" >(minor_words, promoted_words, major_words)<\/span>.  This function is as fast at <span class=\"code\" >quick_stat<\/span>."}, "type": "unit -> float * float * float", "params": [{"name": "", "type": "unit"}]}}, {"value": {"name": "Gc.get", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/gc.mli|6674"}, "info": {"description": "Return the current values of the GC parameters in a <span class=\"code\" >control<\/span> record."}, "type": "unit -> Gc.control", "params": [{"name": "", "type": "unit"}]}}, {"value": {"name": "Gc.set", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/gc.mli|6799"}, "info": {"description": "<span class=\"code\" >set r<\/span> changes the GC parameters according to the <span class=\"code\" >control<\/span> record <span class=\"code\" >r<\/span>. The normal usage is: <span class=\"code\" >Gc.set { (Gc.get()) with Gc.verbose = 0x00d }<\/span>"}, "type": "Gc.control -> unit", "params": [{"name": "", "type": "Gc.control"}]}}, {"value": {"name": "Gc.minor", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/gc.mli|6999"}, "info": {"description": "Trigger a minor collection."}, "type": "unit -> unit", "params": [{"name": "", "type": "unit"}]}}, {"value": {"name": "Gc.major_slice", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/gc.mli|7083"}, "info": {"description": "Do a minor collection and a slice of major collection.  The argument is the size of the slice, 0 to use the automatically-computed slice size.  In all cases, the result is the computed slice size."}, "type": "int -> int", "params": [{"name": "", "type": "int"}]}}, {"value": {"name": "Gc.major", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/gc.mli|7356"}, "info": {"description": "Do a minor collection and finish the current major collection cycle."}, "type": "unit -> unit", "params": [{"name": "", "type": "unit"}]}}, {"value": {"name": "Gc.full_major", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/gc.mli|7481"}, "info": {"description": "Do a minor collection, finish the current major collection cycle, and perform a complete new cycle.  This will collect all currently unreachable blocks."}, "type": "unit -> unit", "params": [{"name": "", "type": "unit"}]}}, {"value": {"name": "Gc.compact", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/gc.mli|7706"}, "info": {"description": "Perform a full major collection and compact the heap.  Note that heap compaction is a lengthy operation."}, "type": "unit -> unit", "params": [{"name": "", "type": "unit"}]}}, {"value": {"name": "Gc.allocated_bytes", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/gc.mli|7877"}, "info": {"description": "Return the total number of bytes allocated since the program was started.  It is returned as a <span class=\"code\" >float<\/span> to avoid overflow problems with <span class=\"code\" >int<\/span> on 32-bit machines."}, "type": "unit -> float", "params": [{"name": "", "type": "unit"}]}}, {"value": {"name": "Gc.finalise", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/gc.mli|8088"}, "info": {"description": "<span class=\"code\" >finalise f v<\/span> registers <span class=\"code\" >f<\/span> as a finalisation function for <span class=\"code\" >v<\/span>. <span class=\"code\" >v<\/span> must be heap-allocated.  <span class=\"code\" >f<\/span> will be called with <span class=\"code\" >v<\/span> as argument at some point between the first time <span class=\"code\" >v<\/span> becomes unreachable and the time <span class=\"code\" >v<\/span> is collected by the GC.  Several functions can be registered for the same value, or even several instances of the same function.  Each instance will be called once (or never, if the program terminates before <span class=\"code\" >v<\/span> becomes unreachable).<br><\/br> The GC will call the finalisation functions in the order of deallocation.  When several values become unreachable at the same time (i.e. during the same GC cycle), the finalisation functions will be called in the reverse order of the corresponding calls to <span class=\"code\" >finalise<\/span>.  If <span class=\"code\" >finalise<\/span> is called in the same order as the values are allocated, that means each value is finalised before the values it depends upon.  Of course, this becomes false if additional dependencies are introduced by assignments.<br><\/br> Anything reachable from the closure of finalisation functions is considered reachable, so the following code will not work as expected:<ul><li><span class=\"code\" > let v = ... in Gc.finalise (fun x -&gt; ...) v <\/span><\/li><\/ul> Instead you should write:<ul><li><span class=\"code\" > let f = fun x -&gt; ... ;; let v = ... in Gc.finalise f v <\/span><\/li><\/ul> The <span class=\"code\" >f<\/span> function can use all features of O'Caml, including assignments that make the value reachable again.  It can also loop forever (in this case, the other finalisation functions will not be called during the execution of f, unless it calls <span class=\"code\" >finalise_release<\/span>). It can call <span class=\"code\" >finalise<\/span> on <span class=\"code\" >v<\/span> or other values to register other functions or even itself.  It can raise an exception; in this case the exception will interrupt whatever the program was doing when the function was called.<br><\/br> <span class=\"code\" >finalise<\/span> will raise <span class=\"code\" >Invalid_argument<\/span> if <span class=\"code\" >v<\/span> is not heap-allocated.  Some examples of values that are not heap-allocated are integers, constant constructors, booleans, the empty array, the empty list, the unit value.  The exact list of what is heap-allocated or not is implementation-dependent. Some constant values can be heap-allocated but never deallocated during the lifetime of the program, for example a list of integer constants; this is also implementation-dependent. You should also be aware that compiler optimisations may duplicate some immutable values, for example floating-point numbers when stored into arrays, so they can be finalised and collected while another copy is still in use by the program.<br><\/br> The results of calling <a href=\"{value|String.make}\" ><span class=\"code\" >String.make<\/span><\/a>, <a href=\"{value|String.create}\" ><span class=\"code\" >String.create<\/span><\/a>, <a href=\"{value|Array.make}\" ><span class=\"code\" >Array.make<\/span><\/a>, and <a href=\"{value|Pervasives.ref}\" ><span class=\"code\" >Pervasives.ref<\/span><\/a> are guaranteed to be heap-allocated and non-constant except when the length argument is <span class=\"code\" >0<\/span>."}, "type": "('a -> unit) -> 'a -> unit", "params": [{"name": "", "type": "'a -> unit"}, {"name": "", "type": "'a"}]}}, {"value": {"name": "Gc.finalise_release", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/gc.mli|10890"}, "info": {"description": "A finalisation function may call <span class=\"code\" >finalise_release<\/span> to tell the GC that it can launch the next finalisation function without waiting for the current one to return."}, "type": "unit -> unit", "params": [{"name": "", "type": "unit"}]}}, {"type": {"name": "Gc.alarm", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/gc.mli|11113"}, "info": {"description": "An alarm is a piece of data that calls a user function at the end of each major GC cycle.  The following functions are provided to create and delete alarms."}, "params": [], "kind": {"type": "abstract"}}}, {"value": {"name": "Gc.create_alarm", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/gc.mli|11290"}, "info": {"description": "<span class=\"code\" >create_alarm f<\/span> will arrange for <span class=\"code\" >f<\/span> to be called at the end of each major GC cycle, starting with the current cycle or the next one. A value of type <span class=\"code\" >alarm<\/span> is returned that you can use to call <span class=\"code\" >delete_alarm<\/span>."}, "type": "(unit -> unit) -> Gc.alarm", "params": [{"name": "", "type": "unit -> unit"}]}}, {"value": {"name": "Gc.delete_alarm", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/gc.mli|11562"}, "info": {"description": "<span class=\"code\" >delete_alarm a<\/span> will stop the calls to the function associated to <span class=\"code\" >a<\/span>.  Calling <span class=\"code\" >delete_alarm a<\/span> again has no effect."}, "type": "Gc.alarm -> unit", "params": [{"name": "", "type": "Gc.alarm"}]}}], "dependencies": {"uses": [], "used_by": []}}}, "Digest": {"module": {"name": "Digest", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/digest.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/digest.mli|0"}, "info": {"description": "MD5 message digest.<br><\/br> This module provides functions to compute 128-bit ``digests'' of arbitrary-length strings or files. The digests are of cryptographic quality: it is very hard, given a digest, to forge a string having that digest. The algorithm used is MD5."}, "type": "sig  end", "module_structure": [{"type": {"name": "Digest.t", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/digest.mli|1234"}, "info": {"description": "The type of digests: 16-character strings."}, "params": [], "kind": {"type": "abstract"}, "manifest": "string"}}, {"value": {"name": "Digest.string", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/digest.mli|1296"}, "info": {"description": "Return the digest of the given string."}, "type": "string -> Digest.t", "params": [{"name": "", "type": "string"}]}}, {"value": {"name": "Digest.substring", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/digest.mli|1368"}, "info": {"description": "<span class=\"code\" >Digest.substring s ofs len<\/span> returns the digest of the substring of <span class=\"code\" >s<\/span> starting at character number <span class=\"code\" >ofs<\/span> and containing <span class=\"code\" >len<\/span> characters."}, "type": "string -> int -> int -> Digest.t", "params": [{"name": "", "type": "string"}, {"name": "", "type": "int"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Digest.file", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/digest.mli|1564"}, "info": {"description": "Return the digest of the file whose name is given."}, "type": "string -> Digest.t", "params": [{"name": "", "type": "string"}]}}, {"value": {"name": "Digest.to_hex", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/digest.mli|1646"}, "info": {"description": "Return the printable hexadecimal representation of the given digest."}, "type": "Digest.t -> string", "params": [{"name": "", "type": "Digest.t"}]}}], "dependencies": {"uses": [], "used_by": []}}}, "Complex": {"module": {"name": "Complex", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/complex.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/complex.mli|0"}, "info": {"description": "Complex numbers.<br><\/br> This module provides arithmetic operations on complex numbers. Complex numbers are represented by their real and imaginary parts (cartesian representation).  Each part is represented by a double-precision floating-point number (type <span class=\"code\" >float<\/span>)."}, "type": "sig  end", "module_structure": [{"type": {"name": "Complex.t", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/complex.mli|1241"}, "info": {"description": "The type of complex numbers.  <span class=\"code\" >re<\/span> is the real part and <span class=\"code\" >im<\/span> the imaginary part."}, "params": [], "kind": {"type": "record", "private": "false", "fields": [{"name": "re", "mutable": false, "type": "float"}, {"name": "im", "mutable": false, "type": "float"}]}}}, {"value": {"name": "Complex.zero", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/complex.mli|1363"}, "info": {"description": "The complex number <span class=\"code\" >0<\/span>."}, "type": "Complex.t", "params": []}}, {"value": {"name": "Complex.one", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/complex.mli|1407"}, "info": {"description": "The complex number <span class=\"code\" >1<\/span>."}, "type": "Complex.t", "params": []}}, {"value": {"name": "Complex.i", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/complex.mli|1450"}, "info": {"description": "The complex number <span class=\"code\" >i<\/span>."}, "type": "Complex.t", "params": []}}, {"value": {"name": "Complex.neg", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/complex.mli|1491"}, "info": {"description": "Unary negation."}, "type": "Complex.t -> Complex.t", "params": [{"name": "", "type": "Complex.t"}]}}, {"value": {"name": "Complex.conj", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/complex.mli|1531"}, "info": {"description": "Conjugate: given the complex <span class=\"code\" >x + i.y<\/span>, returns <span class=\"code\" >x - i.y<\/span>."}, "type": "Complex.t -> Complex.t", "params": [{"name": "", "type": "Complex.t"}]}}, {"value": {"name": "Complex.add", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/complex.mli|1615"}, "info": {"description": "Addition"}, "type": "Complex.t -> Complex.t -> Complex.t", "params": [{"name": "", "type": "Complex.t"}, {"name": "", "type": "Complex.t"}]}}, {"value": {"name": "Complex.sub", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/complex.mli|1653"}, "info": {"description": "Subtraction"}, "type": "Complex.t -> Complex.t -> Complex.t", "params": [{"name": "", "type": "Complex.t"}, {"name": "", "type": "Complex.t"}]}}, {"value": {"name": "Complex.mul", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/complex.mli|1694"}, "info": {"description": "Multiplication"}, "type": "Complex.t -> Complex.t -> Complex.t", "params": [{"name": "", "type": "Complex.t"}, {"name": "", "type": "Complex.t"}]}}, {"value": {"name": "Complex.inv", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/complex.mli|1738"}, "info": {"description": "Multiplicative inverse (<span class=\"code\" >1\/z<\/span>)."}, "type": "Complex.t -> Complex.t", "params": [{"name": "", "type": "Complex.t"}]}}, {"value": {"name": "Complex.div", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/complex.mli|1794"}, "info": {"description": "Division"}, "type": "Complex.t -> Complex.t -> Complex.t", "params": [{"name": "", "type": "Complex.t"}, {"name": "", "type": "Complex.t"}]}}, {"value": {"name": "Complex.sqrt", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/complex.mli|1832"}, "info": {"description": "Square root.  The result <span class=\"code\" >x + i.y<\/span> is such that <span class=\"code\" >x &gt; 0<\/span> or <span class=\"code\" >x = 0<\/span> and <span class=\"code\" >y &gt;= 0<\/span>. This function has a discontinuity along the negative real axis."}, "type": "Complex.t -> Complex.t", "params": [{"name": "", "type": "Complex.t"}]}}, {"value": {"name": "Complex.norm2", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/complex.mli|2010"}, "info": {"description": "Norm squared: given <span class=\"code\" >x + i.y<\/span>, returns <span class=\"code\" >x^2 + y^2<\/span>."}, "type": "Complex.t -> float", "params": [{"name": "", "type": "Complex.t"}]}}, {"value": {"name": "Complex.norm", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/complex.mli|2092"}, "info": {"description": "Norm: given <span class=\"code\" >x + i.y<\/span>, returns <span class=\"code\" >sqrt(x^2 + y^2)<\/span>."}, "type": "Complex.t -> float", "params": [{"name": "", "type": "Complex.t"}]}}, {"value": {"name": "Complex.arg", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/complex.mli|2171"}, "info": {"description": "Argument.  The argument of a complex number is the angle in the complex plane between the positive real axis and a line passing through zero and the number.  This angle ranges from <span class=\"code\" >-pi<\/span> to <span class=\"code\" >pi<\/span>.  This function has a discontinuity along the negative real axis."}, "type": "Complex.t -> float", "params": [{"name": "", "type": "Complex.t"}]}}, {"value": {"name": "Complex.polar", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/complex.mli|2476"}, "info": {"description": "<span class=\"code\" >polar norm arg<\/span> returns the complex having norm <span class=\"code\" >norm<\/span> and argument <span class=\"code\" >arg<\/span>."}, "type": "float -> float -> Complex.t", "params": [{"name": "", "type": "float"}, {"name": "", "type": "float"}]}}, {"value": {"name": "Complex.exp", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/complex.mli|2595"}, "info": {"description": "Exponentiation.  <span class=\"code\" >exp z<\/span> returns <span class=\"code\" >e<\/span> to the <span class=\"code\" >z<\/span> power."}, "type": "Complex.t -> Complex.t", "params": [{"name": "", "type": "Complex.t"}]}}, {"value": {"name": "Complex.log", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/complex.mli|2674"}, "info": {"description": "Natural logarithm (in base <span class=\"code\" >e<\/span>)."}, "type": "Complex.t -> Complex.t", "params": [{"name": "", "type": "Complex.t"}]}}, {"value": {"name": "Complex.pow", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/complex.mli|2731"}, "info": {"description": "Power function.  <span class=\"code\" >pow z1 z2<\/span> returns <span class=\"code\" >z1<\/span> to the <span class=\"code\" >z2<\/span> power."}, "type": "Complex.t -> Complex.t -> Complex.t", "params": [{"name": "", "type": "Complex.t"}, {"name": "", "type": "Complex.t"}]}}], "dependencies": {"uses": [], "used_by": []}}}, "Char": {"module": {"name": "Char", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/char.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/char.mli|0"}, "info": {"description": "Character operations."}, "type": "sig  end", "module_structure": [{"value": {"name": "Char.code", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/char.mli|976"}, "info": {"description": "Return the ASCII code of the argument."}, "type": "char -> int", "params": [{"name": "", "type": "char"}]}}, {"value": {"name": "Char.chr", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/char.mli|1065"}, "info": {"description": "Return the character with the given ASCII code. Raise <span class=\"code\" >Invalid_argument \"Char.chr\"<\/span> if the argument is outside the range 0--255."}, "type": "int -> char", "params": [{"name": "", "type": "int"}]}}, {"value": {"name": "Char.escaped", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/char.mli|1230"}, "info": {"description": "Return a string representing the given character, with special characters escaped following the lexical conventions of Objective Caml."}, "type": "char -> string", "params": [{"name": "", "type": "char"}]}}, {"value": {"name": "Char.lowercase", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/char.mli|1408"}, "info": {"description": "Convert the given character to its equivalent lowercase character."}, "type": "char -> char", "params": [{"name": "", "type": "char"}]}}, {"value": {"name": "Char.uppercase", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/char.mli|1512"}, "info": {"description": "Convert the given character to its equivalent uppercase character."}, "type": "char -> char", "params": [{"name": "", "type": "char"}]}}, {"type": {"name": "Char.t", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/char.mli|1621"}, "info": {"description": "An alias for the type of characters."}, "params": [], "kind": {"type": "abstract"}, "manifest": "char"}}, {"value": {"name": "Char.compare", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/char.mli|1675"}, "info": {"description": "The comparison function for characters, with the same specification as <a href=\"{value|Pervasives.compare}\" ><span class=\"code\" >Pervasives.compare<\/span><\/a>.  Along with the type <span class=\"code\" >t<\/span>, this function <span class=\"code\" >compare<\/span> allows the module <span class=\"code\" >Char<\/span> to be passed as argument to the functors <a href=\"{module|Set.Make}\" ><span class=\"code\" >Set.Make<\/span><\/a> and <a href=\"{module|Map.Make}\" ><span class=\"code\" >Map.Make<\/span><\/a>."}, "type": "Char.t -> Char.t -> int", "params": [{"name": "", "type": "Char.t"}, {"name": "", "type": "Char.t"}]}}], "dependencies": {"uses": [], "used_by": []}}}, "CamlinternalLazy": {"module": {"name": "CamlinternalLazy", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/camlinternalLazy.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/camlinternalLazy.mli|0"}, "info": "", "type": "sig  end", "module_structure": [{"exception": {"name": "CamlinternalLazy.Undefined", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/camlinternalLazy.mli|996"}, "info": ""}}, {"value": {"name": "CamlinternalLazy.force_lazy_block", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/camlinternalLazy.mli|1019"}, "info": "", "type": "'a lazy_t -> 'a", "params": [{"name": "", "type": "'a lazy_t"}]}}, {"value": {"name": "CamlinternalLazy.force_val_lazy_block", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/camlinternalLazy.mli|1062"}, "info": "", "type": "'a lazy_t -> 'a", "params": [{"name": "", "type": "'a lazy_t"}]}}, {"value": {"name": "CamlinternalLazy.force", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/camlinternalLazy.mli|1109"}, "info": "", "type": "'a lazy_t -> 'a", "params": [{"name": "", "type": "'a lazy_t"}]}}, {"value": {"name": "CamlinternalLazy.force_val", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/camlinternalLazy.mli|1140"}, "info": "", "type": "'a lazy_t -> 'a", "params": [{"name": "", "type": "'a lazy_t"}]}}], "dependencies": {"uses": [], "used_by": []}}}, "Callback": {"module": {"name": "Callback", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/callback.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/callback.mli|0"}, "info": {"description": "Registering Caml values with the C runtime.<br><\/br> This module allows Caml values to be registered with the C runtime under a symbolic name, so that C code can later call back registered Caml functions, or raise registered Caml exceptions."}, "type": "sig  end", "module_structure": [{"value": {"name": "Callback.register", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/callback.mli|1201"}, "info": {"description": "<span class=\"code\" >Callback.register n v<\/span> registers the value <span class=\"code\" >v<\/span> under the name <span class=\"code\" >n<\/span>. C code can later retrieve a handle to <span class=\"code\" >v<\/span> by calling <span class=\"code\" >caml_named_value(n)<\/span>."}, "type": "string -> 'a -> unit", "params": [{"name": "", "type": "string"}, {"name": "", "type": "'a"}]}}, {"value": {"name": "Callback.register_exception", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/callback.mli|1395"}, "info": {"description": "<span class=\"code\" >Callback.register_exception n exn<\/span> registers the exception contained in the exception value <span class=\"code\" >exn<\/span> under the name <span class=\"code\" >n<\/span>. C code can later retrieve a handle to the exception by calling <span class=\"code\" >caml_named_value(n)<\/span>. The exception value thus obtained is suitable for passign as first argument to <span class=\"code\" >raise_constant<\/span> or <span class=\"code\" >raise_with_arg<\/span>."}, "type": "string -> exn -> unit", "params": [{"name": "", "type": "string"}, {"name": "", "type": "exn"}]}}], "dependencies": {"uses": [], "used_by": []}}}, "Buffer": {"module": {"name": "Buffer", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/buffer.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/buffer.mli|0"}, "info": {"description": "Extensible string buffers.<br><\/br> This module implements string buffers that automatically expand as necessary.  It provides accumulative concatenation of strings in quasi-linear time (instead of quadratic time when strings are concatenated pairwise)."}, "type": "sig  end", "module_structure": [{"type": {"name": "Buffer.t", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/buffer.mli|1220"}, "info": {"description": "The abstract type of buffers."}, "params": [], "kind": {"type": "abstract"}}}, {"value": {"name": "Buffer.create", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/buffer.mli|1260"}, "info": {"description": "<span class=\"code\" >create n<\/span> returns a fresh buffer, initially empty. The <span class=\"code\" >n<\/span> parameter is the initial size of the internal string that holds the buffer contents. That string is automatically reallocated when more than <span class=\"code\" >n<\/span> characters are stored in the buffer, but shrinks back to <span class=\"code\" >n<\/span> characters when <span class=\"code\" >reset<\/span> is called. For best performance, <span class=\"code\" >n<\/span> should be of the same order of magnitude as the number of characters that are expected to be stored in the buffer (for instance, 80 for a buffer that holds one output line).  Nothing bad will happen if the buffer grows beyond that limit, however. In doubt, take <span class=\"code\" >n = 16<\/span> for instance. If <span class=\"code\" >n<\/span> is not between 1 and <a href=\"{value|Sys.max_string_length}\" ><span class=\"code\" >Sys.max_string_length<\/span><\/a>, it will be clipped to that interval."}, "type": "int -> Buffer.t", "params": [{"name": "", "type": "int"}]}}, {"value": {"name": "Buffer.contents", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/buffer.mli|2026"}, "info": {"description": "Return a copy of the current contents of the buffer. The buffer itself is unchanged."}, "type": "Buffer.t -> string", "params": [{"name": "", "type": "Buffer.t"}]}}, {"value": {"name": "Buffer.sub", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/buffer.mli|2149"}, "info": {"description": "<span class=\"code\" >Buffer.sub b off len<\/span> returns (a copy of) the substring of the current contents of the buffer <span class=\"code\" >b<\/span> starting at offset <span class=\"code\" >off<\/span> of length <span class=\"code\" >len<\/span> bytes. May raise <span class=\"code\" >Invalid_argument<\/span> if out of bounds request. The buffer itself is unaffected."}, "type": "Buffer.t -> int -> int -> string", "params": [{"name": "", "type": "Buffer.t"}, {"name": "", "type": "int"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Buffer.blit", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/buffer.mli|2428"}, "info": {"description": "<span class=\"code\" >Buffer.blit src srcoff dst dstoff len<\/span> copies <span class=\"code\" >len<\/span> characters from the current contents of the buffer <span class=\"code\" >src<\/span>, starting at offset <span class=\"code\" >srcoff<\/span> to string <span class=\"code\" >dst<\/span>, starting at character <span class=\"code\" >dstoff<\/span>.<br><\/br> Raise <span class=\"code\" >Invalid_argument<\/span> if <span class=\"code\" >srcoff<\/span> and <span class=\"code\" >len<\/span> do not designate a valid substring of <span class=\"code\" >src<\/span>, or if <span class=\"code\" >dstoff<\/span> and <span class=\"code\" >len<\/span> do not designate a valid substring of <span class=\"code\" >dst<\/span>.", "since": "3.11.2"}, "type": "Buffer.t -> int -> string -> int -> int -> unit", "params": [{"name": "", "type": "Buffer.t"}, {"name": "", "type": "int"}, {"name": "", "type": "string"}, {"name": "", "type": "int"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Buffer.nth", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/buffer.mli|2871"}, "info": {"description": "get the n-th character of the buffer. Raise <span class=\"code\" >Invalid_argument<\/span> if index out of bounds"}, "type": "Buffer.t -> int -> char", "params": [{"name": "", "type": "Buffer.t"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Buffer.length", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/buffer.mli|2992"}, "info": {"description": "Return the number of characters currently contained in the buffer."}, "type": "Buffer.t -> int", "params": [{"name": "", "type": "Buffer.t"}]}}, {"value": {"name": "Buffer.clear", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/buffer.mli|3089"}, "info": {"description": "Empty the buffer."}, "type": "Buffer.t -> unit", "params": [{"name": "", "type": "Buffer.t"}]}}, {"value": {"name": "Buffer.reset", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/buffer.mli|3137"}, "info": {"description": "Empty the buffer and deallocate the internal string holding the buffer contents, replacing it with the initial internal string of length <span class=\"code\" >n<\/span> that was allocated by <a href=\"{value|Buffer.create}\" ><span class=\"code\" >Buffer.create<\/span><\/a> <span class=\"code\" >n<\/span>. For long-lived buffers that may have grown a lot, <span class=\"code\" >reset<\/span> allows faster reclamation of the space used by the buffer."}, "type": "Buffer.t -> unit", "params": [{"name": "", "type": "Buffer.t"}]}}, {"value": {"name": "Buffer.add_char", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/buffer.mli|3481"}, "info": {"description": "<span class=\"code\" >add_char b c<\/span> appends the character <span class=\"code\" >c<\/span> at the end of the buffer <span class=\"code\" >b<\/span>."}, "type": "Buffer.t -> char -> unit", "params": [{"name": "", "type": "Buffer.t"}, {"name": "", "type": "char"}]}}, {"value": {"name": "Buffer.add_string", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/buffer.mli|3593"}, "info": {"description": "<span class=\"code\" >add_string b s<\/span> appends the string <span class=\"code\" >s<\/span> at the end of the buffer <span class=\"code\" >b<\/span>."}, "type": "Buffer.t -> string -> unit", "params": [{"name": "", "type": "Buffer.t"}, {"name": "", "type": "string"}]}}, {"value": {"name": "Buffer.add_substring", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/buffer.mli|3708"}, "info": {"description": "<span class=\"code\" >add_substring b s ofs len<\/span> takes <span class=\"code\" >len<\/span> characters from offset <span class=\"code\" >ofs<\/span> in string <span class=\"code\" >s<\/span> and appends them at the end of the buffer <span class=\"code\" >b<\/span>."}, "type": "Buffer.t -> string -> int -> int -> unit", "params": [{"name": "", "type": "Buffer.t"}, {"name": "", "type": "string"}, {"name": "", "type": "int"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Buffer.add_substitute", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/buffer.mli|3903"}, "info": {"description": "<span class=\"code\" >add_substitute b f s<\/span> appends the string pattern <span class=\"code\" >s<\/span> at the end of the buffer <span class=\"code\" >b<\/span> with substitution. The substitution process looks for variables into the pattern and substitutes each variable name by its value, as obtained by applying the mapping <span class=\"code\" >f<\/span> to the variable name. Inside the string pattern, a variable name immediately follows a non-escaped <span class=\"code\" >$<\/span> character and is one of the following:<ul><li>a non empty sequence of alphanumeric or <span class=\"code\" >_<\/span> characters,<\/li><li>an arbitrary sequence of characters enclosed by a pair of matching parentheses or curly brackets. An escaped <span class=\"code\" >$<\/span> character is a <span class=\"code\" >$<\/span> that immediately follows a backslash character; it then stands for a plain <span class=\"code\" >$<\/span>. Raise <span class=\"code\" >Not_found<\/span> if the closing character of a parenthesized variable cannot be found.<\/li><\/ul>"}, "type": "Buffer.t -> (string -> string) -> string -> unit", "params": [{"name": "", "type": "Buffer.t"}, {"name": "", "type": "string -> string"}, {"name": "", "type": "string"}]}}, {"value": {"name": "Buffer.add_buffer", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/buffer.mli|4768"}, "info": {"description": "<span class=\"code\" >add_buffer b1 b2<\/span> appends the current contents of buffer <span class=\"code\" >b2<\/span> at the end of buffer <span class=\"code\" >b1<\/span>.  <span class=\"code\" >b2<\/span> is not modified."}, "type": "Buffer.t -> Buffer.t -> unit", "params": [{"name": "", "type": "Buffer.t"}, {"name": "", "type": "Buffer.t"}]}}], "dependencies": {"uses": [], "used_by": ["Format", "Printf", "Utf8", "Utf16", "Cow"]}}}, "Array": {"module": {"name": "Array", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/array.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/array.mli|0"}, "info": {"description": "Array operations."}, "type": "sig  end", "module_structure": [{"value": {"name": "Array.length", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/array.mli|973"}, "info": {"description": "Return the length (number of elements) of the given array."}, "type": "'a array -> int", "params": [{"name": "", "type": "'a array"}]}}, {"value": {"name": "Array.get", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/array.mli|1092"}, "info": {"description": "<span class=\"code\" >Array.get a n<\/span> returns the element number <span class=\"code\" >n<\/span> of array <span class=\"code\" >a<\/span>. The first element has number 0. The last element has number <span class=\"code\" >Array.length a - 1<\/span>. You can also write <span class=\"code\" >a.(n)<\/span> instead of <span class=\"code\" >Array.get a n<\/span>.<br><\/br> Raise <span class=\"code\" >Invalid_argument \"index out of bounds\"<\/span> if <span class=\"code\" >n<\/span> is outside the range 0 to <span class=\"code\" >(Array.length a - 1)<\/span>."}, "type": "'a array -> int -> 'a", "params": [{"name": "", "type": "'a array"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Array.set", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/array.mli|1475"}, "info": {"description": "<span class=\"code\" >Array.set a n x<\/span> modifies array <span class=\"code\" >a<\/span> in place, replacing element number <span class=\"code\" >n<\/span> with <span class=\"code\" >x<\/span>. You can also write <span class=\"code\" >a.(n) &lt;- x<\/span> instead of <span class=\"code\" >Array.set a n x<\/span>.<br><\/br> Raise <span class=\"code\" >Invalid_argument \"index out of bounds\"<\/span> if <span class=\"code\" >n<\/span> is outside the range 0 to <span class=\"code\" >Array.length a - 1<\/span>."}, "type": "'a array -> int -> 'a -> unit", "params": [{"name": "", "type": "'a array"}, {"name": "", "type": "int"}, {"name": "", "type": "'a"}]}}, {"value": {"name": "Array.make", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/array.mli|1811"}, "info": {"description": "<span class=\"code\" >Array.make n x<\/span> returns a fresh array of length <span class=\"code\" >n<\/span>, initialized with <span class=\"code\" >x<\/span>. All the elements of this new array are initially physically equal to <span class=\"code\" >x<\/span> (in the sense of the <span class=\"code\" >==<\/span> predicate). Consequently, if <span class=\"code\" >x<\/span> is mutable, it is shared among all elements of the array, and modifying <span class=\"code\" >x<\/span> through one of the array entries will modify all other entries at the same time.<br><\/br> Raise <span class=\"code\" >Invalid_argument<\/span> if <span class=\"code\" >n &lt; 0<\/span> or <span class=\"code\" >n &gt; Sys.max_array_length<\/span>. If the value of <span class=\"code\" >x<\/span> is a floating-point number, then the maximum size is only <span class=\"code\" >Sys.max_array_length \/ 2<\/span>."}, "type": "int -> 'a -> 'a array", "params": [{"name": "", "type": "int"}, {"name": "", "type": "'a"}]}}, {"value": {"name": "Array.create", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/array.mli|2441"}, "info": {"deprecated": "<span class=\"code\" >Array.create<\/span> is an alias for <a href=\"{value|Array.make}\" ><span class=\"code\" >Array.make<\/span><\/a>."}, "type": "int -> 'a -> 'a array", "params": [{"name": "", "type": "int"}, {"name": "", "type": "'a"}]}}, {"value": {"name": "Array.init", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/array.mli|2566"}, "info": {"description": "<span class=\"code\" >Array.init n f<\/span> returns a fresh array of length <span class=\"code\" >n<\/span>, with element number <span class=\"code\" >i<\/span> initialized to the result of <span class=\"code\" >f i<\/span>. In other terms, <span class=\"code\" >Array.init n f<\/span> tabulates the results of <span class=\"code\" >f<\/span> applied to the integers <span class=\"code\" >0<\/span> to <span class=\"code\" >n-1<\/span>.<br><\/br> Raise <span class=\"code\" >Invalid_argument<\/span> if <span class=\"code\" >n &lt; 0<\/span> or <span class=\"code\" >n &gt; Sys.max_array_length<\/span>. If the return type of <span class=\"code\" >f<\/span> is <span class=\"code\" >float<\/span>, then the maximum size is only <span class=\"code\" >Sys.max_array_length \/ 2<\/span>."}, "type": "int -> (int -> 'a) -> 'a array", "params": [{"name": "", "type": "int"}, {"name": "", "type": "int -> 'a"}]}}, {"value": {"name": "Array.make_matrix", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/array.mli|3011"}, "info": {"description": "<span class=\"code\" >Array.make_matrix dimx dimy e<\/span> returns a two-dimensional array (an array of arrays) with first dimension <span class=\"code\" >dimx<\/span> and second dimension <span class=\"code\" >dimy<\/span>. All the elements of this new matrix are initially physically equal to <span class=\"code\" >e<\/span>. The element (<span class=\"code\" >x,y<\/span>) of a matrix <span class=\"code\" >m<\/span> is accessed with the notation <span class=\"code\" >m.(x).(y)<\/span>.<br><\/br> Raise <span class=\"code\" >Invalid_argument<\/span> if <span class=\"code\" >dimx<\/span> or <span class=\"code\" >dimy<\/span> is negative or greater than <span class=\"code\" >Sys.max_array_length<\/span>. If the value of <span class=\"code\" >e<\/span> is a floating-point number, then the maximum size is only <span class=\"code\" >Sys.max_array_length \/ 2<\/span>."}, "type": "int -> int -> 'a -> 'a array array", "params": [{"name": "", "type": "int"}, {"name": "", "type": "int"}, {"name": "", "type": "'a"}]}}, {"value": {"name": "Array.create_matrix", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/array.mli|3599"}, "info": {"deprecated": "<span class=\"code\" >Array.create_matrix<\/span> is an alias for <a href=\"{value|Array.make_matrix}\" ><span class=\"code\" >Array.make_matrix<\/span><\/a>."}, "type": "int -> int -> 'a -> 'a array array", "params": [{"name": "", "type": "int"}, {"name": "", "type": "int"}, {"name": "", "type": "'a"}]}}, {"value": {"name": "Array.append", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/array.mli|3734"}, "info": {"description": "<span class=\"code\" >Array.append v1 v2<\/span> returns a fresh array containing the concatenation of the arrays <span class=\"code\" >v1<\/span> and <span class=\"code\" >v2<\/span>."}, "type": "'a array -> 'a array -> 'a array", "params": [{"name": "", "type": "'a array"}, {"name": "", "type": "'a array"}]}}, {"value": {"name": "Array.concat", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/array.mli|3892"}, "info": {"description": "Same as <span class=\"code\" >Array.append<\/span>, but concatenates a list of arrays."}, "type": "'a array list -> 'a array", "params": [{"name": "", "type": "'a array list"}]}}, {"value": {"name": "Array.sub", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/array.mli|3998"}, "info": {"description": "<span class=\"code\" >Array.sub a start len<\/span> returns a fresh array of length <span class=\"code\" >len<\/span>, containing the elements number <span class=\"code\" >start<\/span> to <span class=\"code\" >start + len - 1<\/span> of array <span class=\"code\" >a<\/span>.<br><\/br> Raise <span class=\"code\" >Invalid_argument \"Array.sub\"<\/span> if <span class=\"code\" >start<\/span> and <span class=\"code\" >len<\/span> do not designate a valid subarray of <span class=\"code\" >a<\/span>; that is, if <span class=\"code\" >start &lt; 0<\/span>, or <span class=\"code\" >len &lt; 0<\/span>, or <span class=\"code\" >start + len &gt; Array.length a<\/span>."}, "type": "'a array -> int -> int -> 'a array", "params": [{"name": "", "type": "'a array"}, {"name": "", "type": "int"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Array.copy", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/array.mli|4378"}, "info": {"description": "<span class=\"code\" >Array.copy a<\/span> returns a copy of <span class=\"code\" >a<\/span>, that is, a fresh array containing the same elements as <span class=\"code\" >a<\/span>."}, "type": "'a array -> 'a array", "params": [{"name": "", "type": "'a array"}]}}, {"value": {"name": "Array.fill", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/array.mli|4519"}, "info": {"description": "<span class=\"code\" >Array.fill a ofs len x<\/span> modifies the array <span class=\"code\" >a<\/span> in place, storing <span class=\"code\" >x<\/span> in elements number <span class=\"code\" >ofs<\/span> to <span class=\"code\" >ofs + len - 1<\/span>.<br><\/br> Raise <span class=\"code\" >Invalid_argument \"Array.fill\"<\/span> if <span class=\"code\" >ofs<\/span> and <span class=\"code\" >len<\/span> do not designate a valid subarray of <span class=\"code\" >a<\/span>."}, "type": "'a array -> int -> int -> 'a -> unit", "params": [{"name": "", "type": "'a array"}, {"name": "", "type": "int"}, {"name": "", "type": "int"}, {"name": "", "type": "'a"}]}}, {"value": {"name": "Array.blit", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/array.mli|4799"}, "info": {"description": "<span class=\"code\" >Array.blit v1 o1 v2 o2 len<\/span> copies <span class=\"code\" >len<\/span> elements from array <span class=\"code\" >v1<\/span>, starting at element number <span class=\"code\" >o1<\/span>, to array <span class=\"code\" >v2<\/span>, starting at element number <span class=\"code\" >o2<\/span>. It works correctly even if <span class=\"code\" >v1<\/span> and <span class=\"code\" >v2<\/span> are the same array, and the source and destination chunks overlap.<br><\/br> Raise <span class=\"code\" >Invalid_argument \"Array.blit\"<\/span> if <span class=\"code\" >o1<\/span> and <span class=\"code\" >len<\/span> do not designate a valid subarray of <span class=\"code\" >v1<\/span>, or if <span class=\"code\" >o2<\/span> and <span class=\"code\" >len<\/span> do not designate a valid subarray of <span class=\"code\" >v2<\/span>."}, "type": "'a array -> int -> 'a array -> int -> int -> unit", "params": [{"name": "", "type": "'a array"}, {"name": "", "type": "int"}, {"name": "", "type": "'a array"}, {"name": "", "type": "int"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Array.to_list", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/array.mli|5310"}, "info": {"description": "<span class=\"code\" >Array.to_list a<\/span> returns the list of all the elements of <span class=\"code\" >a<\/span>."}, "type": "'a array -> 'a list", "params": [{"name": "", "type": "'a array"}]}}, {"value": {"name": "Array.of_list", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/array.mli|5415"}, "info": {"description": "<span class=\"code\" >Array.of_list l<\/span> returns a fresh array containing the elements of <span class=\"code\" >l<\/span>."}, "type": "'a list -> 'a array", "params": [{"name": "", "type": "'a list"}]}}, {"value": {"name": "Array.iter", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/array.mli|5532"}, "info": {"description": "<span class=\"code\" >Array.iter f a<\/span> applies function <span class=\"code\" >f<\/span> in turn to all the elements of <span class=\"code\" >a<\/span>.  It is equivalent to <span class=\"code\" >f a.(0); f a.(1); ...; f a.(Array.length a - 1); ()<\/span>."}, "type": "('a -> unit) -> 'a array -> unit", "params": [{"name": "", "type": "'a -> unit"}, {"name": "", "type": "'a array"}]}}, {"value": {"name": "Array.map", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/array.mli|5740"}, "info": {"description": "<span class=\"code\" >Array.map f a<\/span> applies function <span class=\"code\" >f<\/span> to all the elements of <span class=\"code\" >a<\/span>, and builds an array with the results returned by <span class=\"code\" >f<\/span>: <span class=\"code\" >[| f a.(0); f a.(1); ...; f a.(Array.length a - 1) |]<\/span>."}, "type": "('a -> 'b) -> 'a array -> 'b array", "params": [{"name": "", "type": "'a -> 'b"}, {"name": "", "type": "'a array"}]}}, {"value": {"name": "Array.iteri", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/array.mli|5975"}, "info": {"description": "Same as <a href=\"{value|Array.iter}\" ><span class=\"code\" >Array.iter<\/span><\/a>, but the function is applied to the index of the element as first argument, and the element itself as second argument."}, "type": "(int -> 'a -> unit) -> 'a array -> unit", "params": [{"name": "", "type": "int -> 'a -> unit"}, {"name": "", "type": "'a array"}]}}, {"value": {"name": "Array.mapi", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/array.mli|6182"}, "info": {"description": "Same as <a href=\"{value|Array.map}\" ><span class=\"code\" >Array.map<\/span><\/a>, but the function is applied to the index of the element as first argument, and the element itself as second argument."}, "type": "(int -> 'a -> 'b) -> 'a array -> 'b array", "params": [{"name": "", "type": "int -> 'a -> 'b"}, {"name": "", "type": "'a array"}]}}, {"value": {"name": "Array.fold_left", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/array.mli|6389"}, "info": {"description": "<span class=\"code\" >Array.fold_left f x a<\/span> computes <span class=\"code\" >f (... (f (f x a.(0)) a.(1)) ...) a.(n-1)<\/span>, where <span class=\"code\" >n<\/span> is the length of the array <span class=\"code\" >a<\/span>."}, "type": "('a -> 'b -> 'a) -> 'a -> 'b array -> 'a", "params": [{"name": "", "type": "'a -> 'b -> 'a"}, {"name": "", "type": "'a"}, {"name": "", "type": "'a array"}]}}, {"value": {"name": "Array.fold_right", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/array.mli|6580"}, "info": {"description": "<span class=\"code\" >Array.fold_right f a x<\/span> computes <span class=\"code\" >f a.(0) (f a.(1) ( ... (f a.(n-1) x) ...))<\/span>, where <span class=\"code\" >n<\/span> is the length of the array <span class=\"code\" >a<\/span>."}, "type": "('a -> 'b -> 'b) -> 'a array -> 'b -> 'b", "params": [{"name": "", "type": "'a -> 'b -> 'b"}, {"name": "", "type": "'a array"}, {"name": "", "type": "'a"}]}}, {"comment": "<h6>Sorting<\/h6>"}, {"value": {"name": "Array.sort", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/array.mli|6796"}, "info": {"description": "Sort an array in increasing order according to a comparison function.  The comparison function must return 0 if its arguments compare as equal, a positive integer if the first is greater, and a negative integer if the first is smaller (see below for a complete specification).  For example, <a href=\"{value|Pervasives.compare}\" ><span class=\"code\" >Pervasives.compare<\/span><\/a> is a suitable comparison function, provided there are no floating-point NaN values in the data.  After calling <span class=\"code\" >Array.sort<\/span>, the array is sorted in place in increasing order. <span class=\"code\" >Array.sort<\/span> is guaranteed to run in constant heap space and (at most) logarithmic stack space.<br><\/br> The current implementation uses Heap Sort.  It runs in constant stack space.<br><\/br> Specification of the comparison function: Let <span class=\"code\" >a<\/span> be the array and <span class=\"code\" >cmp<\/span> the comparison function.  The following must be true for all x, y, z in a :<ul><li>  <span class=\"code\" >cmp x y<\/span> &gt; 0 if and only if <span class=\"code\" >cmp y x<\/span> &lt; 0<\/li><li>  if <span class=\"code\" >cmp x y<\/span> &gt;= 0 and <span class=\"code\" >cmp y z<\/span> &gt;= 0 then <span class=\"code\" >cmp x z<\/span> &gt;= 0<\/li><\/ul> When <span class=\"code\" >Array.sort<\/span> returns, <span class=\"code\" >a<\/span> contains the same elements as before, reordered in such a way that for all i and j valid indices of <span class=\"code\" >a<\/span> :<ul><li>  <span class=\"code\" >cmp a.(i) a.(j)<\/span> &gt;= 0 if and only if i &gt;= j<\/li><\/ul>"}, "type": "('a -> 'a -> int) -> 'a array -> unit", "params": [{"name": "", "type": "'a -> 'a -> int"}, {"name": "", "type": "'a array"}]}}, {"value": {"name": "Array.stable_sort", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/array.mli|8008"}, "info": {"description": "Same as <a href=\"{value|Array.sort}\" ><span class=\"code\" >Array.sort<\/span><\/a>, but the sorting algorithm is stable (i.e. elements that compare equal are kept in their original order) and not guaranteed to run in constant heap space.<br><\/br> The current implementation uses Merge Sort. It uses <span class=\"code\" >n\/2<\/span> words of heap space, where <span class=\"code\" >n<\/span> is the length of the array. It is usually faster than the current implementation of <a href=\"{value|Array.sort}\" ><span class=\"code\" >Array.sort<\/span><\/a>."}, "type": "('a -> 'a -> int) -> 'a array -> unit", "params": [{"name": "", "type": "'a -> 'a -> int"}, {"name": "", "type": "'a array"}]}}, {"value": {"name": "Array.fast_sort", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/array.mli|8453"}, "info": {"description": "Same as <a href=\"{value|Array.sort}\" ><span class=\"code\" >Array.sort<\/span><\/a> or <a href=\"{value|Array.stable_sort}\" ><span class=\"code\" >Array.stable_sort<\/span><\/a>, whichever is faster on typical input."}, "type": "('a -> 'a -> int) -> 'a array -> unit", "params": [{"name": "", "type": "'a -> 'a -> int"}, {"name": "", "type": "'a array"}]}}], "dependencies": {"uses": [], "used_by": []}}}, "Weak": {"module": {"name": "Weak", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/weak.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/weak.mli|0"}, "info": {"description": "Arrays of weak pointers and hash tables of weak pointers."}, "type": "sig  end", "module_structure": [{"comment": "<h6>Low-level functions<\/h6>"}, {"type": {"name": "Weak.t", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/weak.mli|1049"}, "info": {"description": "The type of arrays of weak pointers (weak arrays).  A weak pointer is a value that the garbage collector may erase whenever the value is not used any more (through normal pointers) by the program.  Note that finalisation functions are run after the weak pointers are erased.<br><\/br> A weak pointer is said to be full if it points to a value, empty if the value was erased by the GC.<br><\/br> Notes:<ul><li>Integers are not allocated and cannot be stored in weak arrays.<\/li><li>Weak arrays cannot be marshaled using <a href=\"{value|Pervasives.output_value}\" ><span class=\"code\" >Pervasives.output_value<\/span><\/a> nor the functions of the <a href=\"{module|Marshal}\" ><span class=\"code\" >Marshal<\/span><\/a> module.<\/li><\/ul>"}, "params": [{"covariant": "true", "contravariant": "true", "type": "'b"}], "kind": {"type": "abstract"}}}, {"value": {"name": "Weak.create", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/weak.mli|1657"}, "info": {"description": "<span class=\"code\" >Weak.create n<\/span> returns a new weak array of length <span class=\"code\" >n<\/span>. All the pointers are initially empty.  Raise <span class=\"code\" >Invalid_argument<\/span> if <span class=\"code\" >n<\/span> is negative or greater than <a href=\"{value|Sys.max_array_length}\" ><span class=\"code\" >Sys.max_array_length<\/span><\/a><span class=\"code\" >-1<\/span>."}, "type": "int -> 'a Weak.t", "params": [{"name": "", "type": "int"}]}}, {"value": {"name": "Weak.length", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/weak.mli|1879"}, "info": {"description": "<span class=\"code\" >Weak.length ar<\/span> returns the length (number of elements) of <span class=\"code\" >ar<\/span>."}, "type": "'a Weak.t -> int", "params": [{"name": "", "type": "'a Weak.t"}]}}, {"value": {"name": "Weak.set", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/weak.mli|1980"}, "info": {"description": "<span class=\"code\" >Weak.set ar n (Some el)<\/span> sets the <span class=\"code\" >n<\/span>th cell of <span class=\"code\" >ar<\/span> to be a (full) pointer to <span class=\"code\" >el<\/span>; <span class=\"code\" >Weak.set ar n None<\/span> sets the <span class=\"code\" >n<\/span>th cell of <span class=\"code\" >ar<\/span> to empty. Raise <span class=\"code\" >Invalid_argument \"Weak.set\"<\/span> if <span class=\"code\" >n<\/span> is not in the range 0 to <a href=\"{value|Weak.length}\" ><span class=\"code\" >Weak.length<\/span><\/a><span class=\"code\" > a - 1<\/span>."}, "type": "'a Weak.t -> int -> 'a option -> unit", "params": [{"name": "", "type": "'a Weak.t"}, {"name": "", "type": "int"}, {"name": "", "type": "'a option"}]}}, {"value": {"name": "Weak.get", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/weak.mli|2279"}, "info": {"description": "<span class=\"code\" >Weak.get ar n<\/span> returns None if the <span class=\"code\" >n<\/span>th cell of <span class=\"code\" >ar<\/span> is empty, <span class=\"code\" >Some x<\/span> (where <span class=\"code\" >x<\/span> is the value) if it is full. Raise <span class=\"code\" >Invalid_argument \"Weak.get\"<\/span> if <span class=\"code\" >n<\/span> is not in the range 0 to <a href=\"{value|Weak.length}\" ><span class=\"code\" >Weak.length<\/span><\/a><span class=\"code\" > a - 1<\/span>."}, "type": "'a Weak.t -> int -> 'a option", "params": [{"name": "", "type": "'a Weak.t"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Weak.get_copy", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/weak.mli|2536"}, "info": {"description": "<span class=\"code\" >Weak.get_copy ar n<\/span> returns None if the <span class=\"code\" >n<\/span>th cell of <span class=\"code\" >ar<\/span> is empty, <span class=\"code\" >Some x<\/span> (where <span class=\"code\" >x<\/span> is a (shallow) copy of the value) if it is full. In addition to pitfalls with mutable values, the interesting difference with <span class=\"code\" >get<\/span> is that <span class=\"code\" >get_copy<\/span> does not prevent the incremental GC from erasing the value in its current cycle (<span class=\"code\" >get<\/span> may delay the erasure to the next GC cycle). Raise <span class=\"code\" >Invalid_argument \"Weak.get\"<\/span> if <span class=\"code\" >n<\/span> is not in the range 0 to <a href=\"{value|Weak.length}\" ><span class=\"code\" >Weak.length<\/span><\/a><span class=\"code\" > a - 1<\/span>."}, "type": "'a Weak.t -> int -> 'a option", "params": [{"name": "", "type": "'a Weak.t"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Weak.check", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/weak.mli|3073"}, "info": {"description": "<span class=\"code\" >Weak.check ar n<\/span> returns <span class=\"code\" >true<\/span> if the <span class=\"code\" >n<\/span>th cell of <span class=\"code\" >ar<\/span> is full, <span class=\"code\" >false<\/span> if it is empty.  Note that even if <span class=\"code\" >Weak.check ar n<\/span> returns <span class=\"code\" >true<\/span>, a subsequent <a href=\"{value|Weak.get}\" ><span class=\"code\" >Weak.get<\/span><\/a><span class=\"code\" > ar n<\/span> can return <span class=\"code\" >None<\/span>."}, "type": "'a Weak.t -> int -> bool", "params": [{"name": "", "type": "'a Weak.t"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Weak.fill", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/weak.mli|3314"}, "info": {"description": "<span class=\"code\" >Weak.fill ar ofs len el<\/span> sets to <span class=\"code\" >el<\/span> all pointers of <span class=\"code\" >ar<\/span> from <span class=\"code\" >ofs<\/span> to <span class=\"code\" >ofs + len - 1<\/span>.  Raise <span class=\"code\" >Invalid_argument \"Weak.fill\"<\/span> if <span class=\"code\" >ofs<\/span> and <span class=\"code\" >len<\/span> do not designate a valid subarray of <span class=\"code\" >a<\/span>."}, "type": "'a Weak.t -> int -> int -> 'a option -> unit", "params": [{"name": "", "type": "'a Weak.t"}, {"name": "", "type": "int"}, {"name": "", "type": "int"}, {"name": "", "type": "'a option"}]}}, {"value": {"name": "Weak.blit", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/weak.mli|3568"}, "info": {"description": "<span class=\"code\" >Weak.blit ar1 off1 ar2 off2 len<\/span> copies <span class=\"code\" >len<\/span> weak pointers from <span class=\"code\" >ar1<\/span> (starting at <span class=\"code\" >off1<\/span>) to <span class=\"code\" >ar2<\/span> (starting at <span class=\"code\" >off2<\/span>). It works correctly even if <span class=\"code\" >ar1<\/span> and <span class=\"code\" >ar2<\/span> are the same. Raise <span class=\"code\" >Invalid_argument \"Weak.blit\"<\/span> if <span class=\"code\" >off1<\/span> and <span class=\"code\" >len<\/span> do not designate a valid subarray of <span class=\"code\" >ar1<\/span>, or if <span class=\"code\" >off2<\/span> and <span class=\"code\" >len<\/span> do not designate a valid subarray of <span class=\"code\" >ar2<\/span>."}, "type": "'a Weak.t -> int -> 'a Weak.t -> int -> int -> unit", "params": [{"name": "", "type": "'a Weak.t"}, {"name": "", "type": "int"}, {"name": "", "type": "'a Weak.t"}, {"name": "", "type": "int"}, {"name": "", "type": "int"}]}}, {"comment": "<h6>Weak hash tables<\/h6>"}, {"comment": "A weak hash table is a hashed set of values.  Each value may magically disappear from the set when it is not used by the rest of the program any more.  This is normally used to share data structures without inducing memory leaks. Weak hash tables are defined on values from a <a href=\"{module_type|Hashtbl.HashedType}\" ><span class=\"code\" >Hashtbl.HashedType<\/span><\/a> module; the <span class=\"code\" >equal<\/span> relation and <span class=\"code\" >hash<\/span> function are taken from that module.  We will say that <span class=\"code\" >v<\/span> is an instance of <span class=\"code\" >x<\/span> if <span class=\"code\" >equal x v<\/span> is <span class=\"code\" >true<\/span>.<br><\/br> The <span class=\"code\" >equal<\/span> relation must be able to work on a shallow copy of the values and give the same result as with the values themselves."}, {"module_type": {"name": "Weak.S", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/weak.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/weak.mli|4646"}, "info": {"description": "The output signature of the functor <a href=\"{module|Weak.Make}\" ><span class=\"code\" >Weak.Make<\/span><\/a>."}, "type": "sig  end", "kind": ""}}, {"module": {"name": "Weak.Make", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/weak.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/weak.mli|7147"}, "info": {"description": "Functor building an implementation of the weak hash table structure."}, "type": "functor (H : Hashtbl.HashedType) -> sig  end", "module_functor": {"parameter": {"name": "H"}, "module_with": "unavailable"}, "dependencies": {"uses": []}}}], "dependencies": {"uses": ["Hashtbl"], "used_by": []}}}, "Sys": {"module": {"name": "Sys", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/sys.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/sys.mli|0"}, "info": {"description": "System interface."}, "type": "sig  end", "module_structure": [{"comment": "System interface."}, {"value": {"name": "Sys.os_type", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/sys.mli|991"}, "info": {"description": "Operating system currently executing the Caml program. One of<ul><li> <span class=\"code\" >\"Unix\"<\/span> (for all Unix versions, including Linux and Mac OS X),<\/li><li> <span class=\"code\" >\"Win32\"<\/span> (for MS-Windows, OCaml compiled with MSVC++ or Mingw),<\/li><li> <span class=\"code\" >\"Cygwin\"<\/span> (for MS-Windows, OCaml compiled with Cygwin).<\/li><\/ul>"}, "type": "string", "params": []}}, {"value": {"name": "Sys.word_size", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/sys.mli|1277"}, "info": {"description": "Size of one word on the machine currently executing the Caml program, in bits: 32 or 64."}, "type": "int", "params": []}}, {"value": {"name": "Sys.max_string_length", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/sys.mli|1397"}, "info": {"description": "Maximum length of a string."}, "type": "int", "params": []}}, {"value": {"name": "Sys.max_array_length", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/sys.mli|1461"}, "info": {"description": "Maximum length of a normal array.  The maximum length of a float array is <span class=\"code\" >max_array_length\/2<\/span> on 32-bit machines and <span class=\"code\" >max_array_length<\/span> on 64-bit machines."}, "type": "int", "params": []}}], "dependencies": {"uses": ["Pervasives"], "used_by": []}}}, "Scanf": {"module": {"name": "Scanf", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/scanf.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/scanf.mli|0"}, "info": {"description": "Formatted input functions."}, "type": "sig  end", "module_structure": [{"comment": "<h6>Introduction<\/h6>"}, {"comment": "<h7>Functional input with format strings<\/h7>"}, {"comment": "The module <span class=\"code\" >Scanf<\/span> provides formatted input functions or <em>scanners<\/em>.<br><\/br> The formatted input functions can read from any kind of input, including strings, files, or anything that can return characters. The more general source of characters is named a <em>formatted input channel<\/em> (or <em>    scanning buffer<\/em>) and has type <a href=\"{type|Scanf.Scanning.in_channel}\" ><span class=\"code\" >Scanf.Scanning.in_channel<\/span><\/a>. The more general formatted input function reads from any scanning buffer and is named <span class=\"code\" >bscanf<\/span>.<br><\/br> Generally speaking, the formatted input functions have 3 arguments:<ul><li>the first argument is a source of characters for the input,<\/li><li>the second argument is a format string that specifies the values to read,<\/li><li>the third argument is a <em>receiver function<\/em> that is applied to the values read.<\/li><\/ul> Hence, a typical call to the formatted input function <a href=\"{value|Scanf.bscanf}\" ><span class=\"code\" >Scanf.bscanf<\/span><\/a> is <span class=\"code\" >bscanf ic fmt f<\/span>, where:<br><\/br><ul><li><span class=\"code\" >ic<\/span> is a source of characters (typically a <em>    formatted input channel<\/em> with type <a href=\"{type|Scanf.Scanning.in_channel}\" ><span class=\"code\" >Scanf.Scanning.in_channel<\/span><\/a>),<\/li><\/ul><ul><li><span class=\"code\" >fmt<\/span> is a format string (the same format strings as those used to print material with module <a href=\"{module|Printf}\" ><span class=\"code\" >Printf<\/span><\/a> or <a href=\"{module|Format}\" ><span class=\"code\" >Format<\/span><\/a>),<\/li><\/ul><ul><li><span class=\"code\" >f<\/span> is a function that has as many arguments as the number of values to read in the input.<\/li><\/ul>"}, {"comment": "<h7>A simple example<\/h7>"}, {"comment": "As suggested above, the expression <span class=\"code\" >bscanf ic \"%d\" f<\/span> reads a decimal integer <span class=\"code\" >n<\/span> from the source of characters <span class=\"code\" >ic<\/span> and returns <span class=\"code\" >f n<\/span>.<br><\/br> For instance,<br><\/br><ul><li>if we use <span class=\"code\" >stdin<\/span> as the source of characters (<a href=\"{value|Scanf.Scanning.stdin}\" ><span class=\"code\" >Scanf.Scanning.stdin<\/span><\/a> is the predefined formatted input channel that reads from standard input),<\/li><\/ul><ul><li>if we define the receiver <span class=\"code\" >f<\/span> as <span class=\"code\" >let f x = x + 1<\/span>,<\/li><\/ul> then <span class=\"code\" >bscanf Scanning.stdin \"%d\" f<\/span> reads an integer <span class=\"code\" >n<\/span> from the standard input and returns <span class=\"code\" >f n<\/span> (that is <span class=\"code\" >n + 1<\/span>). Thus, if we evaluate <span class=\"code\" >bscanf stdin \"%d\" f<\/span>, and then enter <span class=\"code\" >41<\/span> at the keyboard, we get <span class=\"code\" >42<\/span> as the final result."}, {"comment": "<h7>Formatted input as a functional feature<\/h7>"}, {"comment": "The Caml scanning facility is reminiscent of the corresponding C feature. However, it is also largely different, simpler, and yet more powerful: the formatted input functions are higher-order functionals and the parameter passing mechanism is just the regular function application not the variable assignment based mechanism which is typical for formatted input in imperative languages; the Caml format strings also feature useful additions to easily define complex tokens; as expected within a functional programming language, the formatted input functions also support polymorphism, in particular arbitrary interaction with polymorphic user-defined scanners.  Furthermore, the Caml formatted input facility is fully type-checked at compile time."}, {"module": {"name": "Scanf.Scanning", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/scanf.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/scanf.mli|3836"}, "info": {"description": "<h6>Formatted input channel<\/h6>"}, "type": "sig  end", "module_structure": [{"type": {"name": "Scanf.Scanning.in_channel", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/scanf.mli|3864"}, "info": "", "params": [], "kind": {"type": "abstract"}}}, {"type": {"name": "Scanf.Scanning.scanbuf", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/scanf.mli|4251"}, "info": {"description": "The type of scanning buffers. A scanning buffer is the source from which a formatted input function gets characters. The scanning buffer holds the current state of the scan, plus a function to get the next char from the input, and a token buffer to store the string matched so far.<br><\/br> Note: a scanning action may often require to examine one character in advance; when this ``lookahead'' character does not belong to the token read, it is stored back in the scanning buffer and becomes the next character read."}, "params": [], "kind": {"type": "abstract"}, "manifest": "Scanf.Scanning.in_channel"}}, {"value": {"name": "Scanf.Scanning.stdin", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/scanf.mli|4819"}, "info": {"description": "The standard input notion for the module <span class=\"code\" >Scanf<\/span>. <span class=\"code\" >stdin<\/span> is equivalent to <span class=\"code\" >Scanning.from_channel Pervasives.stdin<\/span>.<br><\/br> Note: when input is read interactively from <span class=\"code\" >stdin<\/span>, the newline character that triggers the evaluation is incorporated in the input; thus, scanning specifications must properly skip this character (simply add a <span class=\"code\" >'\\n'<\/span> as the last character of the format string).", "since": "3.12.0"}, "type": "Scanf.Scanning.in_channel", "params": []}}, {"value": {"name": "Scanf.Scanning.open_in", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/scanf.mli|5272"}, "info": {"description": "Bufferized file reading in text mode. The efficient and usual way to scan text mode files (in effect, <span class=\"code\" >from_file<\/span> returns a scanning buffer that reads characters in large chunks, rather than one character at a time as buffers returned by <span class=\"code\" >from_channel<\/span> below do). <span class=\"code\" >Scanning.from_file fname<\/span> returns a scanning buffer which reads from the given file <span class=\"code\" >fname<\/span> in text mode.", "since": "3.12.0"}, "type": "string -> Scanf.Scanning.in_channel", "params": [{"name": "", "type": "string"}]}}, {"value": {"name": "Scanf.Scanning.open_in_bin", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/scanf.mli|5726"}, "info": {"description": "Bufferized file reading in binary mode.", "since": "3.12.0"}, "type": "string -> Scanf.Scanning.in_channel", "params": [{"name": "", "type": "string"}]}}, {"value": {"name": "Scanf.Scanning.close_in", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/scanf.mli|5829"}, "info": {"description": "Close the <span class=\"code\" >Pervasives.input_channel<\/span> associated with the given <span class=\"code\" >Scanning.in_channel<\/span>.", "since": "3.12.0"}, "type": "Scanf.Scanning.in_channel -> unit", "params": [{"name": "", "type": "Scanf.Scanning.in_channel"}]}}, {"value": {"name": "Scanf.Scanning.from_file", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/scanf.mli|5977"}, "info": {"description": "An alias for <span class=\"code\" >open_in<\/span> above."}, "type": "string -> Scanf.Scanning.in_channel", "params": [{"name": "", "type": "string"}]}}, {"value": {"name": "Scanf.Scanning.from_file_bin", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/scanf.mli|6053"}, "info": {"description": "An alias for <span class=\"code\" >open_in_bin<\/span> above."}, "type": "string -> Scanf.Scanning.in_channel", "params": [{"name": "", "type": "string"}]}}, {"value": {"name": "Scanf.Scanning.from_string", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/scanf.mli|6138"}, "info": {"description": "<span class=\"code\" >Scanning.from_string s<\/span> returns a formatted input channel which reads from the given string. Reading starts from the first character in the string. The end-of-input condition is set when the end of the string is reached."}, "type": "string -> Scanf.Scanning.in_channel", "params": [{"name": "", "type": "string"}]}}, {"value": {"name": "Scanf.Scanning.from_function", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/scanf.mli|6421"}, "info": {"description": "<span class=\"code\" >Scanning.from_function f<\/span> returns a scanning buffer with the given function as its reading method.<br><\/br> When scanning needs one more character, the given function is called.<br><\/br> When the function has no more character to provide, it <em>must<\/em> signal an end-of-input condition by raising the exception <span class=\"code\" >End_of_file<\/span>."}, "type": "(unit -> char) -> Scanf.Scanning.in_channel", "params": [{"name": "", "type": "unit -> char"}]}}, {"value": {"name": "Scanf.Scanning.from_channel", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/scanf.mli|6805"}, "info": {"description": "<span class=\"code\" >Scanning.from_channel ic<\/span> returns a formatted input channel which reads from the regular input channel <span class=\"code\" >ic<\/span> argument, starting at the current reading position."}, "type": "Pervasives.in_channel -> Scanf.Scanning.in_channel", "params": [{"name": "", "type": "Pervasives.in_channel"}]}}, {"value": {"name": "Scanf.Scanning.end_of_input", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/scanf.mli|7039"}, "info": {"description": "<span class=\"code\" >Scanning.end_of_input ic<\/span> tests the end-of-input condition of the given formatted input channel."}, "type": "Scanf.Scanning.in_channel -> bool", "params": [{"name": "", "type": "Scanf.Scanning.in_channel"}]}}, {"value": {"name": "Scanf.Scanning.beginning_of_input", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/scanf.mli|7189"}, "info": {"description": "<span class=\"code\" >Scanning.beginning_of_input ic<\/span> tests the beginning of input condition of the given formatted input channel."}, "type": "Scanf.Scanning.in_channel -> bool", "params": [{"name": "", "type": "Scanf.Scanning.in_channel"}]}}, {"value": {"name": "Scanf.Scanning.name_of_input", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/scanf.mli|7357"}, "info": {"description": "<span class=\"code\" >Scanning.file_name_of_input ic<\/span> returns the name of the character source for the formatted input channel <span class=\"code\" >ic<\/span>.", "since": "3.09.0"}, "type": "Scanf.Scanning.in_channel -> string", "params": [{"name": "", "type": "Scanf.Scanning.in_channel"}]}}, {"value": {"name": "Scanf.Scanning.stdib", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/scanf.mli|7542"}, "info": {"description": "A deprecated alias for <span class=\"code\" >Scanning.stdin<\/span>, the scanning buffer reading from <span class=\"code\" >Pervasives.stdin<\/span>."}, "type": "Scanf.Scanning.in_channel", "params": []}}], "dependencies": {"uses": []}}}, {"comment": "<h6>Type of formatted input functions<\/h6>"}, {"type": {"name": "Scanf.scanner", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/scanf.mli|7731"}, "info": {"description": "The type of formatted input scanners: <span class=\"code\" >('a, 'b, 'c, 'd) scanner<\/span> is the type of a formatted input function that reads from some formatted input channel according to some format string; more precisely, if <span class=\"code\" >scan<\/span> is some formatted input function, then <span class=\"code\" >scan ic fmt f<\/span> applies <span class=\"code\" >f<\/span> to the arguments specified by the format string <span class=\"code\" >fmt<\/span>, when <span class=\"code\" >scan<\/span> has read those arguments from the formatted input channel <span class=\"code\" >ic<\/span>.<br><\/br> For instance, the <span class=\"code\" >scanf<\/span> function below has type <span class=\"code\" >('a, 'b, 'c, 'd) scanner<\/span>, since it is a formatted input function that reads from <span class=\"code\" >Scanning.stdin<\/span>: <span class=\"code\" >scanf fmt f<\/span> applies <span class=\"code\" >f<\/span> to the arguments specified by <span class=\"code\" >fmt<\/span>, reading those arguments from <span class=\"code\" >Pervasives.stdin<\/span> as expected.<br><\/br> If the format <span class=\"code\" >fmt<\/span> has some <span class=\"code\" >%r<\/span> indications, the corresponding input functions must be provided before the receiver <span class=\"code\" >f<\/span> argument. For instance, if <span class=\"code\" >read_elem<\/span> is an input function for values of type <span class=\"code\" >t<\/span>, then <span class=\"code\" >bscanf ic \"%r;\" read_elem f<\/span> reads a value <span class=\"code\" >v<\/span> of type <span class=\"code\" >t<\/span> followed by a <span class=\"code\" >';'<\/span> character, and returns <span class=\"code\" >f v<\/span>.", "since": "3.10.0"}, "params": [{"covariant": "true", "contravariant": "true", "type": "'a"}, {"covariant": "true", "contravariant": "true", "type": "'b"}, {"covariant": "true", "contravariant": "true", "type": "'c"}, {"covariant": "true", "contravariant": "true", "type": "'d"}], "kind": {"type": "abstract"}, "manifest": "('a, Scanf.Scanning.in_channel, 'b, 'c, 'a -> 'd, 'd) format6 -> 'c"}}, {"exception": {"name": "Scanf.Scan_failure", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/scanf.mli|8916"}, "info": {"description": "The exception that formatted input functions raise when the input cannot be read according to the given format."}, "exception_args": ["string"]}}, {"comment": "<h6>The general formatted input function<\/h6>"}, {"value": {"name": "Scanf.bscanf", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/scanf.mli|9124"}, "info": {"description": "<span class=\"code\" >bscanf ic fmt r1 ... rN f<\/span> reads arguments for the function <span class=\"code\" >f<\/span>, from the formatted input channel <span class=\"code\" >ic<\/span>, according to the format string <span class=\"code\" >fmt<\/span>, and applies <span class=\"code\" >f<\/span> to these values. The result of this call to <span class=\"code\" >f<\/span> is returned as the result of the entire <span class=\"code\" >bscanf<\/span> call. For instance, if <span class=\"code\" >f<\/span> is the function <span class=\"code\" >fun s i -&gt; i + 1<\/span>, then <span class=\"code\" >Scanf.sscanf \"x=  1\" \"%s = %i\" f<\/span> returns <span class=\"code\" >2<\/span>.<br><\/br> Arguments <span class=\"code\" >r1<\/span> to <span class=\"code\" >rN<\/span> are user-defined input functions that read the argument corresponding to a <span class=\"code\" >%r<\/span> conversion."}, "type": "Scanf.Scanning.in_channel -> ('a, 'b, 'c, 'd) Scanf.scanner", "params": [{"name": "", "type": "Scanf.Scanning.in_channel"}]}}, {"comment": "<h6>Format string description<\/h6>"}, {"comment": "The format is a character string which contains three types of objects:<ul><li>plain characters, which are simply matched with the characters of the input (with a special case for <a href=\"{section|Scanf.space}\" ><span class=\"code\" >Scanf.space<\/span><\/a> and line feed),<\/li><li>conversion specifications, each of which causes reading and conversion of one argument for the function <span class=\"code\" >f<\/span> (see <a href=\"{section|Scanf.conversion}\" ><span class=\"code\" >Scanf.conversion<\/span><\/a>),<\/li><li>scanning indications to specify boundaries of tokens (see scanning <a href=\"{section|Scanf.indication}\" ><span class=\"code\" >Scanf.indication<\/span><\/a>).<\/li><\/ul>"}, {"comment": "<h7>The space character in format strings<\/h7>"}, {"comment": "As mentioned above, a plain character in the format string is just matched with the next character of the input; however, two characters are special exceptions to this rule: the space character (<span class=\"code\" >' '<\/span> or ASCII code 32) and the line feed character (<span class=\"code\" >'\\n'<\/span> or ASCII code 10). A space does not match a single space character, but any amount of ``whitespace'' in the input. More precisely, a space inside the format string matches <em>any number<\/em> of tab, space, line feed and carriage return characters. Similarly, a line feed character in the format string matches either a single line feed or a carriage return followed by a line feed.<br><\/br> Matching <em>any<\/em> amount of whitespace, a space in the format string also matches no amount of whitespace at all; hence, the call <span class=\"code\" >bscanf ib \"Price = %d $\" (fun p -&gt; p)<\/span> succeeds and returns <span class=\"code\" >1<\/span> when reading an input with various whitespace in it, such as <span class=\"code\" >Price = 1 $<\/span>, <span class=\"code\" >Price  =  1    $<\/span>, or even <span class=\"code\" >Price=1$<\/span>."}, {"comment": "<h7>Conversion specifications in format strings<\/h7>"}, {"comment": "Conversion specifications consist in the <span class=\"code\" >%<\/span> character, followed by an optional flag, an optional field width, and followed by one or two conversion characters. The conversion characters and their meanings are:<br><\/br><ul><li><span class=\"code\" >d<\/span>: reads an optionally signed decimal integer.<\/li><li><span class=\"code\" >i<\/span>: reads an optionally signed integer (usual input conventions for decimal (<span class=\"code\" >0-9<\/span>+), hexadecimal (<span class=\"code\" >0x[0-9a-f]+<\/span> and <span class=\"code\" >0X[0-9A-F]+<\/span>), octal (<span class=\"code\" >0o[0-7]+<\/span>), and binary (<span class=\"code\" >0b[0-1]+<\/span>) notations are understood).<\/li><li><span class=\"code\" >u<\/span>: reads an unsigned decimal integer.<\/li><li><span class=\"code\" >x<\/span> or <span class=\"code\" >X<\/span>: reads an unsigned hexadecimal integer (<span class=\"code\" >[0-9a-f]+<\/span> or <span class=\"code\" >[0-9A-F]+<\/span>).<\/li><li><span class=\"code\" >o<\/span>: reads an unsigned octal integer (<span class=\"code\" >[0-7]+<\/span>).<\/li><li><span class=\"code\" >s<\/span>: reads a string argument that spreads as much as possible, until the following bounding condition holds:<\/li><li>a whitespace has been found (see <a href=\"{section|Scanf.space}\" ><span class=\"code\" >Scanf.space<\/span><\/a>),<\/li><li>a scanning indication (see scanning <a href=\"{section|Scanf.indication}\" ><span class=\"code\" >Scanf.indication<\/span><\/a>) has been encountered,<\/li><li>the end-of-input has been reached. Hence, this conversion always succeeds: it returns an empty string, if the bounding condition holds when the scan begins.<\/li><li><span class=\"code\" >S<\/span>: reads a delimited string argument (delimiters and special escaped characters follow the lexical conventions of Caml).<\/li><li><span class=\"code\" >c<\/span>: reads a single character. To test the current input character without reading it, specify a null field width, i.e. use specification <span class=\"code\" >%0c<\/span>. Raise <span class=\"code\" >Invalid_argument<\/span>, if the field width specification is greater than 1.<\/li><li><span class=\"code\" >C<\/span>: reads a single delimited character (delimiters and special escaped characters follow the lexical conventions of Caml).<\/li><li><span class=\"code\" >f<\/span>, <span class=\"code\" >e<\/span>, <span class=\"code\" >E<\/span>, <span class=\"code\" >g<\/span>, <span class=\"code\" >G<\/span>: reads an optionally signed floating-point number in decimal notation, in the style <span class=\"code\" >dddd.ddd e\/E+-dd<\/span>.<\/li><li><span class=\"code\" >F<\/span>: reads a floating point number according to the lexical conventions of Caml (hence the decimal point is mandatory if the exponent part is not mentioned).<\/li><li><span class=\"code\" >B<\/span>: reads a boolean argument (<span class=\"code\" >true<\/span> or <span class=\"code\" >false<\/span>).<\/li><li><span class=\"code\" >b<\/span>: reads a boolean argument (for backward compatibility; do not use in new programs).<\/li><li><span class=\"code\" >ld<\/span>, <span class=\"code\" >li<\/span>, <span class=\"code\" >lu<\/span>, <span class=\"code\" >lx<\/span>, <span class=\"code\" >lX<\/span>, <span class=\"code\" >lo<\/span>: reads an <span class=\"code\" >int32<\/span> argument to the format specified by the second letter for regular integers.<\/li><li><span class=\"code\" >nd<\/span>, <span class=\"code\" >ni<\/span>, <span class=\"code\" >nu<\/span>, <span class=\"code\" >nx<\/span>, <span class=\"code\" >nX<\/span>, <span class=\"code\" >no<\/span>: reads a <span class=\"code\" >nativeint<\/span> argument to the format specified by the second letter for regular integers.<\/li><li><span class=\"code\" >Ld<\/span>, <span class=\"code\" >Li<\/span>, <span class=\"code\" >Lu<\/span>, <span class=\"code\" >Lx<\/span>, <span class=\"code\" >LX<\/span>, <span class=\"code\" >Lo<\/span>: reads an <span class=\"code\" >int64<\/span> argument to the format specified by the second letter for regular integers.<\/li><li><span class=\"code\" >[ range ]<\/span>: reads characters that matches one of the characters mentioned in the range of characters <span class=\"code\" >range<\/span> (or not mentioned in it, if the range starts with <span class=\"code\" >^<\/span>). Reads a <span class=\"code\" >string<\/span> that can be empty, if the next input character does not match the range. The set of characters from <span class=\"code\" >c1<\/span> to <span class=\"code\" >c2<\/span> (inclusively) is denoted by <span class=\"code\" >c1-c2<\/span>. Hence, <span class=\"code\" >%[0-9]<\/span> returns a string representing a decimal number or an empty string if no decimal digit is found; similarly, <span class=\"code\" >%[\\\\048-\\\\057\\\\065-\\\\070]<\/span> returns a string of hexadecimal digits. If a closing bracket appears in a range, it must occur as the first character of the range (or just after the <span class=\"code\" >^<\/span> in case of range negation); hence <span class=\"code\" >[]]<\/span> matches a <span class=\"code\" >]<\/span> character and <span class=\"code\" >[^]]<\/span> matches any character that is not <span class=\"code\" >]<\/span>.<\/li><li><span class=\"code\" >r<\/span>: user-defined reader. Takes the next <span class=\"code\" >ri<\/span> formatted input function and applies it to the scanning buffer <span class=\"code\" >ib<\/span> to read the next argument. The input function <span class=\"code\" >ri<\/span> must therefore have type <span class=\"code\" >Scanning.in_channel -&gt; 'a<\/span> and the argument read has type <span class=\"code\" >'a<\/span>.<\/li><li><span class=\"code\" >{ fmt %}<\/span>: reads a format string argument. The format string read must have the same type as the format string specification <span class=\"code\" >fmt<\/span>. For instance, <span class=\"code\" >\"%{ %i %}\"<\/span> reads any format string that can read a value of type <span class=\"code\" >int<\/span>; hence <span class=\"code\" >Scanf.sscanf \"fmt:\\\"number is %u\\\"\" \"fmt:%{%i%}\"<\/span> succeeds and returns the format string <span class=\"code\" >\"number is %u\"<\/span>.<\/li><li><span class=\"code\" >\\( fmt %\\)<\/span>: scanning format substitution. Reads a format string to read with it instead of <span class=\"code\" >fmt<\/span>. The format string read must have the same type as the format string specification <span class=\"code\" >fmt<\/span> that is replaces. For instance, <span class=\"code\" >\"%( %i %)\"<\/span> reads any format string that can read a value of type <span class=\"code\" >int<\/span>. Returns the format string read, and the value read using the format string read. Hence, <span class=\"code\" >Scanf.sscanf \"\\\"%4d\\\"1234.00\" \"%(%i%)\" (fun fmt i -&gt; fmt, i)<\/span> evaluates to <span class=\"code\" >(\"%4d\", 1234)<\/span>. If the special flag <span class=\"code\" >_<\/span> is used, the conversion discards the format string read and only returns the value read with the format string read. Hence, <span class=\"code\" >Scanf.sscanf \"\\\"%4d\\\"1234.00\" \"%_(%i%)\"<\/span> is simply equivalent to <span class=\"code\" >Scanf.sscanf \"1234.00\" \"%4d\"<\/span>.<\/li><li><span class=\"code\" >l<\/span>: returns the number of lines read so far.<\/li><li><span class=\"code\" >n<\/span>: returns the number of characters read so far.<\/li><li><span class=\"code\" >N<\/span> or <span class=\"code\" >L<\/span>: returns the number of tokens read so far.<\/li><li><span class=\"code\" >!<\/span>: matches the end of input condition.<\/li><li><span class=\"code\" >%<\/span>: matches one <span class=\"code\" >%<\/span> character in the input.<\/li><li><span class=\"code\" >,<\/span>: the no-op delimiter for conversion specifications.<\/li><\/ul> Following the <span class=\"code\" >%<\/span> character that introduces a conversion, there may be the special flag <span class=\"code\" >_<\/span>: the conversion that follows occurs as usual, but the resulting value is discarded. For instance, if <span class=\"code\" >f<\/span> is the function <span class=\"code\" >fun i -&gt; i + 1<\/span>, then <span class=\"code\" >Scanf.sscanf \"x = 1\" \"%_s = %i\" f<\/span> returns <span class=\"code\" >2<\/span>.<br><\/br> The field width is composed of an optional integer literal indicating the maximal width of the token to read. For instance, <span class=\"code\" >%6d<\/span> reads an integer, having at most 6 decimal digits; <span class=\"code\" >%4f<\/span> reads a float with at most 4 characters; and <span class=\"code\" >%8[\\\\000-\\\\255]<\/span> returns the next 8 characters (or all the characters still available, if fewer than 8 characters are available in the input).<br><\/br> Notes:<br><\/br><ul><li>as mentioned above, a <span class=\"code\" >%s<\/span> conversion always succeeds, even if there is nothing to read in the input: in this case, it simply returns <span class=\"code\" >\"\"<\/span>.<\/li><\/ul><ul><li>in addition to the relevant digits, <span class=\"code\" >'_'<\/span> characters may appear inside numbers (this is reminiscent to the usual Caml lexical conventions). If stricter scanning is desired, use the range conversion facility instead of the number conversions.<\/li><\/ul><ul><li>the <span class=\"code\" >scanf<\/span> facility is not intended for heavy duty lexical analysis and parsing. If it appears not expressive enough for your needs, several alternative exists: regular expressions (module <span class=\"code\" >Str<\/span>), stream parsers, <span class=\"code\" >ocamllex<\/span>-generated lexers, <span class=\"code\" >ocamlyacc<\/span>-generated parsers.<\/li><\/ul>"}, {"comment": "<h7>Scanning indications in format strings<\/h7>"}, {"comment": "Scanning indications appear just after the string conversions <span class=\"code\" >%s<\/span> and <span class=\"code\" >%[ range ]<\/span> to delimit the end of the token. A scanning indication is introduced by a <span class=\"code\" >@<\/span> character, followed by some constant character <span class=\"code\" >c<\/span>. It means that the string token should end just before the next matching <span class=\"code\" >c<\/span> (which is skipped). If no <span class=\"code\" >c<\/span> character is encountered, the string token spreads as much as possible. For instance, <span class=\"code\" >\"%s@\\t\"<\/span> reads a string up to the next tab character or to the end of input. If a scanning indication <span class=\"code\" >@c<\/span> does not follow a string conversion, it is treated as a plain <span class=\"code\" >c<\/span> character.<br><\/br> Note:<br><\/br><ul><li>the scanning indications introduce slight differences in the syntax of <span class=\"code\" >Scanf<\/span> format strings, compared to those used for the <span class=\"code\" >Printf<\/span> module. However, the scanning indications are similar to those used in the <span class=\"code\" >Format<\/span> module; hence, when producing formatted text to be scanned by <span class=\"code\" >!Scanf.bscanf<\/span>, it is wise to use printing functions from the <span class=\"code\" >Format<\/span> module (or, if you need to use functions from <span class=\"code\" >Printf<\/span>, banish or carefully double check the format strings that contain <span class=\"code\" >'@'<\/span> characters).<\/li><\/ul>"}, {"comment": "<h7>Exceptions during scanning<\/h7>"}, {"comment": "Scanners may raise the following exceptions when the input cannot be read according to the format string:<br><\/br><ul><li>Raise <span class=\"code\" >Scanf.Scan_failure<\/span> if the input does not match the format.<\/li><\/ul><ul><li>Raise <span class=\"code\" >Failure<\/span> if a conversion to a number is not possible.<\/li><\/ul><ul><li>Raise <span class=\"code\" >End_of_file<\/span> if the end of input is encountered while some more characters are needed to read the current conversion specification.<\/li><\/ul><ul><li>Raise <span class=\"code\" >Invalid_argument<\/span> if the format string is invalid.<\/li><\/ul> Note:<br><\/br><ul><li>as a consequence, scanning a <span class=\"code\" >%s<\/span> conversion never raises exception <span class=\"code\" >End_of_file<\/span>: if the end of input is reached the conversion succeeds and simply returns the characters read so far, or <span class=\"code\" >\"\"<\/span> if none were ever read.<\/li><\/ul>"}, {"comment": "<h6>Specialised formatted input functions<\/h6>"}, {"value": {"name": "Scanf.fscanf", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/scanf.mli|20060"}, "info": {"description": "Same as <a href=\"{value|Scanf.bscanf}\" ><span class=\"code\" >Scanf.bscanf<\/span><\/a>, but reads from the given regular input channel.<br><\/br> Warning: since all formatted input functions operate from a <em>formatted input channel<\/em>, be aware that each <span class=\"code\" >fscanf<\/span> invocation will operate with a formatted input channel reading from the given channel. This extra level of bufferization can lead to strange scanning behaviour if you use low level primitives on the channel (reading characters, seeking the reading position, and so on).<br><\/br> As a consequence, never mix direct low level reading and high level scanning from the same regular input channel."}, "type": "Pervasives.in_channel -> ('a, 'b, 'c, 'd) Scanf.scanner", "params": [{"name": "", "type": "Pervasives.in_channel"}]}}, {"value": {"name": "Scanf.sscanf", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/scanf.mli|20741"}, "info": {"description": "Same as <a href=\"{value|Scanf.bscanf}\" ><span class=\"code\" >Scanf.bscanf<\/span><\/a>, but reads from the given string."}, "type": "string -> ('a, 'b, 'c, 'd) Scanf.scanner", "params": [{"name": "", "type": "string"}]}}, {"value": {"name": "Scanf.scanf", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/scanf.mli|20857"}, "info": {"description": "Same as <a href=\"{value|Scanf.bscanf}\" ><span class=\"code\" >Scanf.bscanf<\/span><\/a>, but reads from the predefined formatted input channel <a href=\"{value|Scanf.Scanning.stdin}\" ><span class=\"code\" >Scanf.Scanning.stdin<\/span><\/a> that is connected to <span class=\"code\" >Pervasives.stdin<\/span>."}, "type": "('a, 'b, 'c, 'd) Scanf.scanner", "params": []}}, {"value": {"name": "Scanf.kscanf", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/scanf.mli|21052"}, "info": {"description": "Same as <a href=\"{value|Scanf.bscanf}\" ><span class=\"code\" >Scanf.bscanf<\/span><\/a>, but takes an additional function argument <span class=\"code\" >ef<\/span> that is called in case of error: if the scanning process or some conversion fails, the scanning function aborts and calls the error handling function <span class=\"code\" >ef<\/span> with the scanning buffer and the exception that aborted the scanning process as arguments."}, "type": "Scanf.Scanning.in_channel ->\n  (Scanf.Scanning.in_channel -> exn -> 'a) -> ('b, 'c, 'd, 'a) Scanf.scanner", "params": [{"name": "", "type": "Scanf.Scanning.in_channel"}, {"name": "", "type": "Scanf.Scanning.in_channel -> exn -> 'a"}]}}, {"comment": "<h6>Reading format strings from input<\/h6>"}, {"value": {"name": "Scanf.bscanf_format", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/scanf.mli|21547"}, "info": {"description": "<span class=\"code\" >bscanf_format ic fmt f<\/span> reads a format string token from the formatted input channel <span class=\"code\" >ic<\/span>, according to the given format string <span class=\"code\" >fmt<\/span>, and applies <span class=\"code\" >f<\/span> to the resulting format string value. Raise <span class=\"code\" >Scan_failure<\/span> if the format string value read does not have the same type as <span class=\"code\" >fmt<\/span>.", "since": "3.09.0"}, "type": "Scanf.Scanning.in_channel ->\n  ('a, 'b, 'c, 'd, 'e, 'f) format6 ->\n  (('a, 'b, 'c, 'd, 'e, 'f) format6 -> 'g) -> 'g", "params": [{"name": "", "type": "Scanf.Scanning.in_channel"}, {"name": "", "type": "('a, 'b, 'c, 'd, 'e, 'f) format6"}, {"name": "", "type": "('a, 'b, 'c, 'd, 'e, 'f) format6 -> 'g"}]}}, {"value": {"name": "Scanf.sscanf_format", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/scanf.mli|22004"}, "info": {"description": "Same as <a href=\"{value|Scanf.bscanf_format}\" ><span class=\"code\" >Scanf.bscanf_format<\/span><\/a>, but reads from the given string.", "since": "3.09.0"}, "type": "string ->\n  ('a, 'b, 'c, 'd, 'e, 'f) format6 ->\n  (('a, 'b, 'c, 'd, 'e, 'f) format6 -> 'g) -> 'g", "params": [{"name": "", "type": "string"}, {"name": "", "type": "('a, 'b, 'c, 'd, 'e, 'f) format6"}, {"name": "", "type": "('a, 'b, 'c, 'd, 'e, 'f) format6 -> 'g"}]}}, {"value": {"name": "Scanf.format_from_string", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/scanf.mli|22216"}, "info": {"description": "<span class=\"code\" >format_from_string s fmt<\/span> converts a string argument to a format string, according to the given format string <span class=\"code\" >fmt<\/span>. Raise <span class=\"code\" >Scan_failure<\/span> if <span class=\"code\" >s<\/span>, considered as a format string, does not have the same type as <span class=\"code\" >fmt<\/span>.", "since": "3.10.0"}, "type": "string ->\n  ('a, 'b, 'c, 'd, 'e, 'f) format6 -> ('a, 'b, 'c, 'd, 'e, 'f) format6", "params": [{"name": "", "type": "string"}, {"name": "", "type": "('a, 'b, 'c, 'd, 'e, 'f) format6"}]}}], "dependencies": {"uses": ["Pervasives"], "used_by": []}}}, "Random": {"module": {"name": "Random", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/random.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/random.mli|0"}, "info": {"description": "Pseudo-random number generators (PRNG)."}, "type": "sig  end", "module_structure": [{"comment": "<h6>Basic functions<\/h6>"}, {"value": {"name": "Random.init", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/random.mli|1025"}, "info": {"description": "Initialize the generator, using the argument as a seed. The same seed will always yield the same sequence of numbers."}, "type": "int -> unit", "params": [{"name": "", "type": "int"}]}}, {"value": {"name": "Random.full_init", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/random.mli|1179"}, "info": {"description": "Same as <a href=\"{value|Random.init}\" ><span class=\"code\" >Random.init<\/span><\/a> but takes more data as seed."}, "type": "int array -> unit", "params": [{"name": "", "type": "int array"}]}}, {"value": {"name": "Random.self_init", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/random.mli|1273"}, "info": {"description": "Initialize the generator with a more-or-less random seed chosen in a system-dependent way."}, "type": "unit -> unit", "params": [{"name": "", "type": "unit"}]}}, {"value": {"name": "Random.bits", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/random.mli|1404"}, "info": {"description": "Return 30 random bits in a nonnegative integer."}, "type": "unit -> int", "params": [{"name": "", "type": "unit"}]}}, {"value": {"name": "Random.int", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/random.mli|1586"}, "info": {"description": "<span class=\"code\" >Random.int bound<\/span> returns a random integer between 0 (inclusive) and <span class=\"code\" >bound<\/span> (exclusive).  <span class=\"code\" >bound<\/span> must be greater than 0 and less than 2<sup>30<\/sup>."}, "type": "int -> int", "params": [{"name": "", "type": "int"}]}}, {"value": {"name": "Random.int32", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/random.mli|1770"}, "info": {"description": "<span class=\"code\" >Random.int32 bound<\/span> returns a random integer between 0 (inclusive) and <span class=\"code\" >bound<\/span> (exclusive).  <span class=\"code\" >bound<\/span> must be greater than 0."}, "type": "Int32.t -> Int32.t", "params": [{"name": "", "type": "Int32.t"}]}}, {"value": {"name": "Random.nativeint", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/random.mli|1942"}, "info": {"description": "<span class=\"code\" >Random.nativeint bound<\/span> returns a random integer between 0 (inclusive) and <span class=\"code\" >bound<\/span> (exclusive).  <span class=\"code\" >bound<\/span> must be greater than 0."}, "type": "Nativeint.t -> Nativeint.t", "params": [{"name": "", "type": "Nativeint.t"}]}}, {"value": {"name": "Random.int64", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/random.mli|2130"}, "info": {"description": "<span class=\"code\" >Random.int64 bound<\/span> returns a random integer between 0 (inclusive) and <span class=\"code\" >bound<\/span> (exclusive).  <span class=\"code\" >bound<\/span> must be greater than 0."}, "type": "Int64.t -> Int64.t", "params": [{"name": "", "type": "Int64.t"}]}}, {"value": {"name": "Random.float", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/random.mli|2302"}, "info": {"description": "<span class=\"code\" >Random.float bound<\/span> returns a random floating-point number between 0 (inclusive) and <span class=\"code\" >bound<\/span> (exclusive).  If <span class=\"code\" >bound<\/span> is negative, the result is negative or zero.  If <span class=\"code\" >bound<\/span> is 0, the result is 0."}, "type": "float -> float", "params": [{"name": "", "type": "float"}]}}, {"value": {"name": "Random.bool", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/random.mli|2545"}, "info": {"description": "<span class=\"code\" >Random.bool ()<\/span> returns <span class=\"code\" >true<\/span> or <span class=\"code\" >false<\/span> with probability 0.5 each."}, "type": "unit -> bool", "params": [{"name": "", "type": "unit"}]}}, {"comment": "<h6>Advanced functions<\/h6>"}, {"comment": "The functions from module <span class=\"code\" >State<\/span> manipulate the current state of the random generator explicitely. This allows using one or several deterministic PRNGs, even in a multi-threaded program, without interference from other parts of the program."}, {"module": {"name": "Random.State", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/random.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/random.mli|2945"}, "info": "", "type": "sig  end", "module_structure": [{"type": {"name": "Random.State.t", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/random.mli|2971"}, "info": {"description": "The type of PRNG states."}, "params": [], "kind": {"type": "abstract"}}}, {"value": {"name": "Random.State.make", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/random.mli|3010"}, "info": {"description": "Create a new state and initialize it with the given seed."}, "type": "int array -> Random.State.t", "params": [{"name": "", "type": "int array"}]}}, {"value": {"name": "Random.State.make_self_init", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/random.mli|3106"}, "info": {"description": "Create a new state and initialize it with a system-dependent low-entropy seed."}, "type": "unit -> Random.State.t", "params": [{"name": "", "type": "unit"}]}}, {"value": {"name": "Random.State.copy", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/random.mli|3234"}, "info": {"description": "Return a copy of the given state."}, "type": "Random.State.t -> Random.State.t", "params": [{"name": "", "type": "Random.State.t"}]}}, {"value": {"name": "Random.State.bits", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/random.mli|3298"}, "info": "", "type": "Random.State.t -> int", "params": [{"name": "", "type": "Random.State.t"}]}}, {"value": {"name": "Random.State.int", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/random.mli|3320"}, "info": "", "type": "Random.State.t -> int -> int", "params": [{"name": "", "type": "Random.State.t"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Random.State.int32", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/random.mli|3348"}, "info": "", "type": "Random.State.t -> Int32.t -> Int32.t", "params": [{"name": "", "type": "Random.State.t"}, {"name": "", "type": "Int32.t"}]}}, {"value": {"name": "Random.State.nativeint", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/random.mli|3386"}, "info": "", "type": "Random.State.t -> Nativeint.t -> Nativeint.t", "params": [{"name": "", "type": "Random.State.t"}, {"name": "", "type": "Nativeint.t"}]}}, {"value": {"name": "Random.State.int64", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/random.mli|3436"}, "info": "", "type": "Random.State.t -> Int64.t -> Int64.t", "params": [{"name": "", "type": "Random.State.t"}, {"name": "", "type": "Int64.t"}]}}, {"value": {"name": "Random.State.float", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/random.mli|3474"}, "info": "", "type": "Random.State.t -> float -> float", "params": [{"name": "", "type": "Random.State.t"}, {"name": "", "type": "float"}]}}, {"value": {"name": "Random.State.bool", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/random.mli|3508"}, "info": {"description": "These functions are the same as the basic functions, except that they use (and update) the given PRNG state instead of the default one."}, "type": "Random.State.t -> bool", "params": [{"name": "", "type": "Random.State.t"}]}}], "dependencies": {"uses": []}}}, {"value": {"name": "Random.get_state", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/random.mli|3690"}, "info": {"description": "Return the current state of the generator used by the basic functions."}, "type": "unit -> Random.State.t", "params": [{"name": "", "type": "unit"}]}}, {"value": {"name": "Random.set_state", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/random.mli|3801"}, "info": {"description": "Set the state of the generator used by the basic functions."}, "type": "Random.State.t -> unit", "params": [{"name": "", "type": "Random.State.t"}]}}], "dependencies": {"uses": ["Nativeint", "Int64", "Int32"], "used_by": []}}}, "Obj": {"module": {"name": "Obj", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/obj.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/obj.mli|0"}, "info": {"description": "Operations on internal representations of values.<br><\/br> Not for the casual user."}, "type": "sig  end", "module_structure": [{"type": {"name": "Obj.t", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/obj.mli|1038"}, "info": "", "params": [], "kind": {"type": "abstract"}}}, {"value": {"name": "Obj.repr", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/obj.mli|1041"}, "info": "", "type": "'a -> Obj.t", "params": [{"name": "", "type": "'a"}]}}, {"value": {"name": "Obj.obj", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/obj.mli|1079"}, "info": "", "type": "Obj.t -> 'a", "params": [{"name": "", "type": "Obj.t"}]}}, {"value": {"name": "Obj.magic", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/obj.mli|1116"}, "info": "", "type": "'a -> 'b", "params": [{"name": "", "type": "'a"}]}}, {"value": {"name": "Obj.is_block", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/obj.mli|1156"}, "info": "", "type": "Obj.t -> bool", "params": [{"name": "", "type": "Obj.t"}]}}, {"value": {"name": "Obj.is_int", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/obj.mli|1208"}, "info": "", "type": "Obj.t -> bool", "params": [{"name": "", "type": "Obj.t"}]}}, {"value": {"name": "Obj.tag", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/obj.mli|1252"}, "info": "", "type": "Obj.t -> int", "params": [{"name": "", "type": "Obj.t"}]}}, {"value": {"name": "Obj.set_tag", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/obj.mli|1293"}, "info": "", "type": "Obj.t -> int -> unit", "params": [{"name": "", "type": "Obj.t"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Obj.size", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/obj.mli|1350"}, "info": "", "type": "Obj.t -> int", "params": [{"name": "", "type": "Obj.t"}]}}, {"value": {"name": "Obj.field", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/obj.mli|1389"}, "info": "", "type": "Obj.t -> int -> Obj.t", "params": [{"name": "", "type": "Obj.t"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Obj.set_field", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/obj.mli|1435"}, "info": "", "type": "Obj.t -> int -> Obj.t -> unit", "params": [{"name": "", "type": "Obj.t"}, {"name": "", "type": "int"}, {"name": "", "type": "Obj.t"}]}}, {"value": {"name": "Obj.double_field", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/obj.mli|1497"}, "info": "", "type": "Obj.t -> int -> float", "params": [{"name": "", "type": "Obj.t"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Obj.set_double_field", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/obj.mli|1555"}, "info": "", "type": "Obj.t -> int -> float -> unit", "params": [{"name": "", "type": "Obj.t"}, {"name": "", "type": "int"}, {"name": "", "type": "float"}]}}, {"value": {"name": "Obj.new_block", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/obj.mli|1625"}, "info": "", "type": "int -> int -> Obj.t", "params": [{"name": "", "type": "int"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Obj.dup", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/obj.mli|1681"}, "info": "", "type": "Obj.t -> Obj.t", "params": [{"name": "", "type": "Obj.t"}]}}, {"value": {"name": "Obj.truncate", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/obj.mli|1720"}, "info": "", "type": "Obj.t -> int -> unit", "params": [{"name": "", "type": "Obj.t"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Obj.add_offset", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/obj.mli|1779"}, "info": "", "type": "Obj.t -> Int32.t -> Obj.t", "params": [{"name": "", "type": "Obj.t"}, {"name": "", "type": "Int32.t"}]}}, {"value": {"name": "Obj.lazy_tag", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/obj.mli|1873"}, "info": "", "type": "int", "params": []}}, {"value": {"name": "Obj.closure_tag", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/obj.mli|1892"}, "info": "", "type": "int", "params": []}}, {"value": {"name": "Obj.object_tag", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/obj.mli|1914"}, "info": "", "type": "int", "params": []}}, {"value": {"name": "Obj.infix_tag", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/obj.mli|1935"}, "info": "", "type": "int", "params": []}}, {"value": {"name": "Obj.forward_tag", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/obj.mli|1955"}, "info": "", "type": "int", "params": []}}, {"value": {"name": "Obj.no_scan_tag", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/obj.mli|1977"}, "info": "", "type": "int", "params": []}}, {"value": {"name": "Obj.abstract_tag", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/obj.mli|1999"}, "info": "", "type": "int", "params": []}}, {"value": {"name": "Obj.string_tag", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/obj.mli|2022"}, "info": "", "type": "int", "params": []}}, {"value": {"name": "Obj.double_tag", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/obj.mli|2043"}, "info": "", "type": "int", "params": []}}, {"value": {"name": "Obj.double_array_tag", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/obj.mli|2064"}, "info": "", "type": "int", "params": []}}, {"value": {"name": "Obj.custom_tag", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/obj.mli|2091"}, "info": "", "type": "int", "params": []}}, {"value": {"name": "Obj.final_tag", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/obj.mli|2112"}, "info": "", "type": "int", "params": []}}, {"value": {"name": "Obj.int_tag", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/obj.mli|2151"}, "info": "", "type": "int", "params": []}}, {"value": {"name": "Obj.out_of_heap_tag", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/obj.mli|2169"}, "info": "", "type": "int", "params": []}}, {"value": {"name": "Obj.unaligned_tag", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/obj.mli|2195"}, "info": "", "type": "int", "params": []}}, {"comment": "The following two functions are deprecated.  Use module <a href=\"{module|Marshal}\" ><span class=\"code\" >Marshal<\/span><\/a> instead."}, {"value": {"name": "Obj.marshal", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/obj.mli|2350"}, "info": "", "type": "Obj.t -> string", "params": [{"name": "", "type": "Obj.t"}]}}, {"value": {"name": "Obj.unmarshal", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/obj.mli|2376"}, "info": "", "type": "string -> int -> Obj.t * int", "params": [{"name": "", "type": "string"}, {"name": "", "type": "int"}]}}], "dependencies": {"uses": ["Int32"], "used_by": ["Printf", "Parsing", "CamlinternalOO", "CamlinternalMod"]}}}, "Format": {"module": {"name": "Format", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|0"}, "info": {"description": "Pretty printing.<br><\/br> This module implements a pretty-printing facility to format text within ``pretty-printing boxes''. The pretty-printer breaks lines at specified break hints, and indents lines according to the box structure.<br><\/br> For a gentle introduction to the basics of pretty-printing using <span class=\"code\" >Format<\/span>, read <a href=\"http:\/\/caml.inria.fr\/resources\/doc\/guides\/format.html\" >http:\/\/caml.inria.fr\/resources\/doc\/guides\/format.html<\/a>.<br><\/br> You may consider this module as providing an extension to the <span class=\"code\" >printf<\/span> facility to provide automatic line breaking. The addition of pretty-printing annotations to your regular <span class=\"code\" >printf<\/span> formats gives you fancy indentation and line breaks. Pretty-printing annotations are described below in the documentation of the function <a href=\"{value|Format.fprintf}\" ><span class=\"code\" >Format.fprintf<\/span><\/a>.<br><\/br> You may also use the explicit box management and printing functions provided by this module. This style is more basic but more verbose than the <span class=\"code\" >fprintf<\/span> concise formats.<br><\/br> For instance, the sequence <span class=\"code\" >open_box 0; print_string \"x =\"; print_space (); print_int 1; close_box (); print_newline ()<\/span> that prints <span class=\"code\" >x = 1<\/span> within a pretty-printing box, can be abbreviated as <span class=\"code\" >printf \"@[%s@ %i@]@.\" \"x =\" 1<\/span>, or even shorter <span class=\"code\" >printf \"@[x =@ %i@]@.\" 1<\/span>.<br><\/br> Rule of thumb for casual users of this library:<ul><li>use simple boxes (as obtained by <span class=\"code\" >open_box 0<\/span>);<\/li><li>use simple break hints (as obtained by <span class=\"code\" >print_cut ()<\/span> that outputs a simple break hint, or by <span class=\"code\" >print_space ()<\/span> that outputs a space indicating a break hint);<\/li><li>once a box is opened, display its material with basic printing functions (e. g. <span class=\"code\" >print_int<\/span> and <span class=\"code\" >print_string<\/span>);<\/li><li>when the material for a box has been printed, call <span class=\"code\" >close_box ()<\/span> to close the box;<\/li><li>at the end of your routine, flush the pretty-printer to display all the remaining material, e.g. evaluate <span class=\"code\" >print_newline ()<\/span>.<\/li><\/ul> The behaviour of pretty-printing commands is unspecified if there is no opened pretty-printing box. Each box opened via one of the <span class=\"code\" >open_<\/span> functions below must be closed using <span class=\"code\" >close_box<\/span> for proper formatting. Otherwise, some of the material printed in the boxes may not be output, or may be formatted incorrectly.<br><\/br> In case of interactive use, the system closes all opened boxes and flushes all pending text (as with the <span class=\"code\" >print_newline<\/span> function) after each phrase. Each phrase is therefore executed in the initial state of the pretty-printer.<br><\/br> Warning: the material output by the following functions is delayed in the pretty-printer queue in order to compute the proper line breaking. Hence, you should not mix calls to the printing functions of the basic I\/O system with calls to the functions of this module: this could result in some strange output seemingly unrelated with the evaluation order of printing commands."}, "type": "sig  end", "module_structure": [{"comment": "Pretty printing.<br><\/br> This module implements a pretty-printing facility to format text within ``pretty-printing boxes''. The pretty-printer breaks lines at specified break hints, and indents lines according to the box structure.<br><\/br> For a gentle introduction to the basics of pretty-printing using <span class=\"code\" >Format<\/span>, read <a href=\"http:\/\/caml.inria.fr\/resources\/doc\/guides\/format.html\" >http:\/\/caml.inria.fr\/resources\/doc\/guides\/format.html<\/a>.<br><\/br> You may consider this module as providing an extension to the <span class=\"code\" >printf<\/span> facility to provide automatic line breaking. The addition of pretty-printing annotations to your regular <span class=\"code\" >printf<\/span> formats gives you fancy indentation and line breaks. Pretty-printing annotations are described below in the documentation of the function <a href=\"{value|Format.fprintf}\" ><span class=\"code\" >Format.fprintf<\/span><\/a>.<br><\/br> You may also use the explicit box management and printing functions provided by this module. This style is more basic but more verbose than the <span class=\"code\" >fprintf<\/span> concise formats.<br><\/br> For instance, the sequence <span class=\"code\" >open_box 0; print_string \"x =\"; print_space (); print_int 1; close_box (); print_newline ()<\/span> that prints <span class=\"code\" >x = 1<\/span> within a pretty-printing box, can be abbreviated as <span class=\"code\" >printf \"@[%s@ %i@]@.\" \"x =\" 1<\/span>, or even shorter <span class=\"code\" >printf \"@[x =@ %i@]@.\" 1<\/span>.<br><\/br> Rule of thumb for casual users of this library:<ul><li>use simple boxes (as obtained by <span class=\"code\" >open_box 0<\/span>);<\/li><li>use simple break hints (as obtained by <span class=\"code\" >print_cut ()<\/span> that outputs a simple break hint, or by <span class=\"code\" >print_space ()<\/span> that outputs a space indicating a break hint);<\/li><li>once a box is opened, display its material with basic printing functions (e. g. <span class=\"code\" >print_int<\/span> and <span class=\"code\" >print_string<\/span>);<\/li><li>when the material for a box has been printed, call <span class=\"code\" >close_box ()<\/span> to close the box;<\/li><li>at the end of your routine, flush the pretty-printer to display all the remaining material, e.g. evaluate <span class=\"code\" >print_newline ()<\/span>.<\/li><\/ul> The behaviour of pretty-printing commands is unspecified if there is no opened pretty-printing box. Each box opened via one of the <span class=\"code\" >open_<\/span> functions below must be closed using <span class=\"code\" >close_box<\/span> for proper formatting. Otherwise, some of the material printed in the boxes may not be output, or may be formatted incorrectly.<br><\/br> In case of interactive use, the system closes all opened boxes and flushes all pending text (as with the <span class=\"code\" >print_newline<\/span> function) after each phrase. Each phrase is therefore executed in the initial state of the pretty-printer.<br><\/br> Warning: the material output by the following functions is delayed in the pretty-printer queue in order to compute the proper line breaking. Hence, you should not mix calls to the printing functions of the basic I\/O system with calls to the functions of this module: this could result in some strange output seemingly unrelated with the evaluation order of printing commands."}, {"comment": "<h6>Boxes<\/h6>"}, {"value": {"name": "Format.open_box", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|3842"}, "info": {"description": "<span class=\"code\" >open_box d<\/span> opens a new pretty-printing box with offset <span class=\"code\" >d<\/span>. This box is the general purpose pretty-printing box. Material in this box is displayed ``horizontal or vertical'': break hints inside the box may lead to a new line, if there is no more room on the line to print the remainder of the box, or if a new line may lead to a new indentation (demonstrating the indentation of the box). When a new line is printed in the box, <span class=\"code\" >d<\/span> is added to the current indentation."}, "type": "int -> unit", "params": [{"name": "", "type": "int"}]}}, {"value": {"name": "Format.close_box", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|4377"}, "info": {"description": "Closes the most recently opened pretty-printing box."}, "type": "unit -> unit", "params": [{"name": "", "type": "unit"}]}}, {"comment": "<h6>Formatting functions<\/h6>"}, {"value": {"name": "Format.print_string", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|4502"}, "info": {"description": "<span class=\"code\" >print_string str<\/span> prints <span class=\"code\" >str<\/span> in the current box."}, "type": "string -> unit", "params": [{"name": "", "type": "string"}]}}, {"value": {"name": "Format.print_as", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|4598"}, "info": {"description": "<span class=\"code\" >print_as len str<\/span> prints <span class=\"code\" >str<\/span> in the current box. The pretty-printer formats <span class=\"code\" >str<\/span> as if it were of length <span class=\"code\" >len<\/span>."}, "type": "int -> string -> unit", "params": [{"name": "", "type": "int"}, {"name": "", "type": "string"}]}}, {"value": {"name": "Format.print_int", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|4767"}, "info": {"description": "Prints an integer in the current box."}, "type": "int -> unit", "params": [{"name": "", "type": "int"}]}}, {"value": {"name": "Format.print_float", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|4843"}, "info": {"description": "Prints a floating point number in the current box."}, "type": "float -> unit", "params": [{"name": "", "type": "float"}]}}, {"value": {"name": "Format.print_char", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|4936"}, "info": {"description": "Prints a character in the current box."}, "type": "char -> unit", "params": [{"name": "", "type": "char"}]}}, {"value": {"name": "Format.print_bool", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|5015"}, "info": {"description": "Prints a boolean in the current box."}, "type": "bool -> unit", "params": [{"name": "", "type": "bool"}]}}, {"comment": "<h6>Break hints<\/h6>"}, {"value": {"name": "Format.print_space", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|5116"}, "info": {"description": "<span class=\"code\" >print_space ()<\/span> is used to separate items (typically to print a space between two words). It indicates that the line may be split at this point. It either prints one space or splits the line. It is equivalent to <span class=\"code\" >print_break 1 0<\/span>."}, "type": "unit -> unit", "params": [{"name": "", "type": "unit"}]}}, {"value": {"name": "Format.print_cut", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|5401"}, "info": {"description": "<span class=\"code\" >print_cut ()<\/span> is used to mark a good break position. It indicates that the line may be split at this point. It either prints nothing or splits the line. This allows line splitting at the current point, without printing spaces or adding indentation. It is equivalent to <span class=\"code\" >print_break 0 0<\/span>."}, "type": "unit -> unit", "params": [{"name": "", "type": "unit"}]}}, {"value": {"name": "Format.print_break", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|5744"}, "info": {"description": "Inserts a break hint in a pretty-printing box. <span class=\"code\" >print_break nspaces offset<\/span> indicates that the line may be split (a newline character is printed) at this point, if the contents of the current box does not fit on the current line. If the line is split at that point, <span class=\"code\" >offset<\/span> is added to the current indentation. If the line is not split, <span class=\"code\" >nspaces<\/span> spaces are printed."}, "type": "int -> int -> unit", "params": [{"name": "", "type": "int"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Format.print_flush", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|6180"}, "info": {"description": "Flushes the pretty printer: all opened boxes are closed, and all pending text is displayed."}, "type": "unit -> unit", "params": [{"name": "", "type": "unit"}]}}, {"value": {"name": "Format.print_newline", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|6316"}, "info": {"description": "Equivalent to <span class=\"code\" >print_flush<\/span> followed by a new line."}, "type": "unit -> unit", "params": [{"name": "", "type": "unit"}]}}, {"value": {"name": "Format.force_newline", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|6411"}, "info": {"description": "Forces a newline in the current box. Not the normal way of pretty-printing, you should prefer break hints."}, "type": "unit -> unit", "params": [{"name": "", "type": "unit"}]}}, {"value": {"name": "Format.print_if_newline", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|6564"}, "info": {"description": "Executes the next formatting command if the preceding line has just been split. Otherwise, ignore the next formatting command."}, "type": "unit -> unit", "params": [{"name": "", "type": "unit"}]}}, {"comment": "<h6>Margin<\/h6>"}, {"value": {"name": "Format.set_margin", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|6762"}, "info": {"description": "<span class=\"code\" >set_margin d<\/span> sets the value of the right margin to <span class=\"code\" >d<\/span> (in characters): this value is used to detect line overflows that leads to split lines. Nothing happens if <span class=\"code\" >d<\/span> is smaller than 2. If <span class=\"code\" >d<\/span> is too large, the right margin is set to the maximum admissible value (which is greater than <span class=\"code\" >10^10<\/span>)."}, "type": "int -> unit", "params": [{"name": "", "type": "int"}]}}, {"value": {"name": "Format.get_margin", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|7113"}, "info": {"description": "Returns the position of the right margin."}, "type": "unit -> int", "params": [{"name": "", "type": "unit"}]}}, {"comment": "<h6>Maximum indentation limit<\/h6>"}, {"value": {"name": "Format.set_max_indent", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|7232"}, "info": {"description": "<span class=\"code\" >set_max_indent d<\/span> sets the value of the maximum indentation limit to <span class=\"code\" >d<\/span> (in characters): once this limit is reached, boxes are rejected to the left, if they do not fit on the current line. Nothing happens if <span class=\"code\" >d<\/span> is smaller than 2. If <span class=\"code\" >d<\/span> is too large, the limit is set to the maximum admissible value (which is greater than <span class=\"code\" >10^10<\/span>)."}, "type": "int -> unit", "params": [{"name": "", "type": "int"}]}}, {"value": {"name": "Format.get_max_indent", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|7629"}, "info": {"description": "Return the value of the maximum indentation limit (in characters)."}, "type": "unit -> int", "params": [{"name": "", "type": "unit"}]}}, {"comment": "<h6>Formatting depth: maximum number of boxes allowed before ellipsis<\/h6>"}, {"value": {"name": "Format.set_max_boxes", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|7817"}, "info": {"description": "<span class=\"code\" >set_max_boxes max<\/span> sets the maximum number of boxes simultaneously opened. Material inside boxes nested deeper is printed as an ellipsis (more precisely as the text returned by <span class=\"code\" >get_ellipsis_text ()<\/span>). Nothing happens if <span class=\"code\" >max<\/span> is smaller than 2."}, "type": "int -> unit", "params": [{"name": "", "type": "int"}]}}, {"value": {"name": "Format.get_max_boxes", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|8121"}, "info": {"description": "Returns the maximum number of boxes allowed before ellipsis."}, "type": "unit -> int", "params": [{"name": "", "type": "unit"}]}}, {"value": {"name": "Format.over_max_boxes", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|8224"}, "info": {"description": "Tests if the maximum number of boxes allowed have already been opened."}, "type": "unit -> bool", "params": [{"name": "", "type": "unit"}]}}, {"comment": "<h6>Advanced formatting<\/h6>"}, {"value": {"name": "Format.open_hbox", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|8371"}, "info": {"description": "<span class=\"code\" >open_hbox ()<\/span> opens a new pretty-printing box. This box is ``horizontal'': the line is not split in this box (new lines may still occur inside boxes nested deeper)."}, "type": "unit -> unit", "params": [{"name": "", "type": "unit"}]}}, {"value": {"name": "Format.open_vbox", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|8582"}, "info": {"description": "<span class=\"code\" >open_vbox d<\/span> opens a new pretty-printing box with offset <span class=\"code\" >d<\/span>. This box is ``vertical'': every break hint inside this box leads to a new line. When a new line is printed in the box, <span class=\"code\" >d<\/span> is added to the current indentation."}, "type": "int -> unit", "params": [{"name": "", "type": "int"}]}}, {"value": {"name": "Format.open_hvbox", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|8858"}, "info": {"description": "<span class=\"code\" >open_hvbox d<\/span> opens a new pretty-printing box with offset <span class=\"code\" >d<\/span>. This box is ``horizontal-vertical'': it behaves as an ``horizontal'' box if it fits on a single line, otherwise it behaves as a ``vertical'' box. When a new line is printed in the box, <span class=\"code\" >d<\/span> is added to the current indentation."}, "type": "int -> unit", "params": [{"name": "", "type": "int"}]}}, {"value": {"name": "Format.open_hovbox", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|9205"}, "info": {"description": "<span class=\"code\" >open_hovbox d<\/span> opens a new pretty-printing box with offset <span class=\"code\" >d<\/span>. This box is ``horizontal or vertical'': break hints inside this box may lead to a new line, if there is no more room on the line to print the remainder of the box. When a new line is printed in the box, <span class=\"code\" >d<\/span> is added to the current indentation."}, "type": "int -> unit", "params": [{"name": "", "type": "int"}]}}, {"comment": "<h6>Tabulations<\/h6>"}, {"value": {"name": "Format.open_tbox", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|9596"}, "info": {"description": "Opens a tabulation box."}, "type": "unit -> unit", "params": [{"name": "", "type": "unit"}]}}, {"value": {"name": "Format.close_tbox", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|9659"}, "info": {"description": "Closes the most recently opened tabulation box."}, "type": "unit -> unit", "params": [{"name": "", "type": "unit"}]}}, {"value": {"name": "Format.print_tbreak", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|9747"}, "info": {"description": "Break hint in a tabulation box. <span class=\"code\" >print_tbreak spaces offset<\/span> moves the insertion point to the next tabulation (<span class=\"code\" >spaces<\/span> being added to this position). Nothing occurs if insertion point is already on a tabulation mark. If there is no next tabulation on the line, then a newline is printed and the insertion point moves to the first tabulation of the box. If a new line is printed, <span class=\"code\" >offset<\/span> is added to the current indentation."}, "type": "int -> int -> unit", "params": [{"name": "", "type": "int"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Format.set_tab", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|10248"}, "info": {"description": "Sets a tabulation mark at the current insertion point."}, "type": "unit -> unit", "params": [{"name": "", "type": "unit"}]}}, {"value": {"name": "Format.print_tab", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|10340"}, "info": {"description": "<span class=\"code\" >print_tab ()<\/span> is equivalent to <span class=\"code\" >print_tbreak 0 0<\/span>."}, "type": "unit -> unit", "params": [{"name": "", "type": "unit"}]}}, {"comment": "<h6>Ellipsis<\/h6>"}, {"value": {"name": "Format.set_ellipsis_text", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|10452"}, "info": {"description": "Set the text of the ellipsis printed when too many boxes are opened (a single dot, <span class=\"code\" >.<\/span>, by default)."}, "type": "string -> unit", "params": [{"name": "", "type": "string"}]}}, {"value": {"name": "Format.get_ellipsis_text", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|10605"}, "info": {"description": "Return the text of the ellipsis."}, "type": "unit -> string", "params": [{"name": "", "type": "unit"}]}}, {"comment": "<h6>Semantics Tags<\/h6>"}, {"type": {"name": "Format.tag", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|10724"}, "info": "", "params": [], "kind": {"type": "abstract"}, "manifest": "string"}}, {"comment": "<i>Semantics tags<\/i> (or simply <em>tags<\/em>) are used to decorate printed entities for user's defined purposes, e.g. setting font and giving size indications for a display device, or marking delimitation of semantics entities (e.g. HTML or TeX elements or terminal escape sequences).<br><\/br> By default, those tags do not influence line breaking calculation: the tag ``markers'' are not considered as part of the printing material that drives line breaking (in other words, the length of those strings is considered as zero for line breaking).<br><\/br> Thus, tag handling is in some sense transparent to pretty-printing and does not interfere with usual pretty-printing. Hence, a single pretty printing routine can output both simple ``verbatim'' material or richer decorated output depending on the treatment of tags. By default, tags are not active, hence the output is not decorated with tag information. Once <span class=\"code\" >set_tags<\/span> is set to <span class=\"code\" >true<\/span>, the pretty printer engine honours tags and decorates the output accordingly.<br><\/br> When a tag has been opened (or closed), it is both and successively ``printed'' and ``marked''. Printing a tag means calling a formatter specific function with the name of the tag as argument: that ``tag printing'' function can then print any regular material to the formatter (so that this material is enqueued as usual in the formatter queue for further line-breaking computation). Marking a tag means to output an arbitrary string (the ``tag marker''), directly into the output device of the formatter. Hence, the formatter specific ``tag marking'' function must return the tag marker string associated to its tag argument. Being flushed directly into the output device of the formatter, tag marker strings are not considered as part of the printing material that drives line breaking (in other words, the length of the strings corresponding to tag markers is considered as zero for line breaking). In addition, advanced users may take advantage of the specificity of tag markers to be precisely output when the pretty printer has already decided where to break the lines, and precisely when the queue is flushed into the output device.<br><\/br> In the spirit of HTML tags, the default tag marking functions output tags enclosed in \"&lt;\" and \"&gt;\": hence, the opening marker of tag <span class=\"code\" >t<\/span> is <span class=\"code\" >\"&lt;t&gt;\"<\/span> and the closing marker <span class=\"code\" >\"&lt;\/t&gt;\"<\/span>.<br><\/br> Default tag printing functions just do nothing.<br><\/br> Tag marking and tag printing functions are user definable and can be set by calling <span class=\"code\" >set_formatter_tag_functions<\/span>."}, {"value": {"name": "Format.open_tag", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|13351"}, "info": {"description": "<span class=\"code\" >open_tag t<\/span> opens the tag named <span class=\"code\" >t<\/span>; the <span class=\"code\" >print_open_tag<\/span> function of the formatter is called with <span class=\"code\" >t<\/span> as argument; the tag marker <span class=\"code\" >mark_open_tag t<\/span> will be flushed into the output device of the formatter."}, "type": "Format.tag -> unit", "params": [{"name": "", "type": "Format.tag"}]}}, {"value": {"name": "Format.close_tag", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|13603"}, "info": {"description": "<span class=\"code\" >close_tag ()<\/span> closes the most recently opened tag <span class=\"code\" >t<\/span>. In addition, the <span class=\"code\" >print_close_tag<\/span> function of the formatter is called with <span class=\"code\" >t<\/span> as argument. The marker <span class=\"code\" >mark_close_tag t<\/span> will be flushed into the output device of the formatter."}, "type": "unit -> unit", "params": [{"name": "", "type": "unit"}]}}, {"value": {"name": "Format.set_tags", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|13887"}, "info": {"description": "<span class=\"code\" >set_tags b<\/span> turns on or off the treatment of tags (default is off)."}, "type": "bool -> unit", "params": [{"name": "", "type": "bool"}]}}, {"value": {"name": "Format.set_print_tags", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|13993"}, "info": "", "type": "bool -> unit", "params": [{"name": "", "type": "bool"}]}}, {"value": {"name": "Format.set_mark_tags", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|14029"}, "info": {"description": "<span class=\"code\" >set_print_tags b<\/span> turns on or off the printing of tags, while <span class=\"code\" >set_mark_tags b<\/span> turns on or off the output of tag markers."}, "type": "bool -> unit", "params": [{"name": "", "type": "bool"}]}}, {"value": {"name": "Format.get_print_tags", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|14199"}, "info": "", "type": "unit -> bool", "params": [{"name": "", "type": "unit"}]}}, {"value": {"name": "Format.get_mark_tags", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|14235"}, "info": {"description": "Return the current status of tags printing and tags marking."}, "type": "unit -> bool", "params": [{"name": "", "type": "unit"}]}}, {"comment": "<h6>Redirecting the standard formatter output<\/h6>"}, {"value": {"name": "Format.set_formatter_out_channel", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|14393"}, "info": {"description": "Redirect the pretty-printer output to the given channel. (All the output functions of the standard formatter are set to the default output functions printing to the given channel.)"}, "type": "Pervasives.out_channel -> unit", "params": [{"name": "", "type": "Pervasives.out_channel"}]}}, {"value": {"name": "Format.set_formatter_output_functions", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|14656"}, "info": {"description": "<span class=\"code\" >set_formatter_output_functions out flush<\/span> redirects the relevant pretty-printer output functions to the functions <span class=\"code\" >out<\/span> and <span class=\"code\" >flush<\/span>.<br><\/br> The <span class=\"code\" >out<\/span> function performs the pretty-printer string output. It is called with a string <span class=\"code\" >s<\/span>, a start position <span class=\"code\" >p<\/span>, and a number of characters <span class=\"code\" >n<\/span>; it is supposed to output characters <span class=\"code\" >p<\/span> to <span class=\"code\" >p + n - 1<\/span> of <span class=\"code\" >s<\/span>. The <span class=\"code\" >flush<\/span> function is called whenever the pretty-printer is flushed (via conversion <span class=\"code\" >%!<\/span>, pretty-printing indications <span class=\"code\" >@?<\/span> or <span class=\"code\" >@.<\/span>, or using low level function <span class=\"code\" >print_flush<\/span> or <span class=\"code\" >print_newline<\/span>)."}, "type": "(string -> int -> int -> unit) -> (unit -> unit) -> unit", "params": [{"name": "", "type": "string -> int -> int -> unit"}, {"name": "", "type": "unit -> unit"}]}}, {"value": {"name": "Format.get_formatter_output_functions", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|15330"}, "info": {"description": "Return the current output functions of the pretty-printer."}, "type": "unit -> (string -> int -> int -> unit) * (unit -> unit)", "params": [{"name": "", "type": "unit"}]}}, {"comment": "<h6>Changing the meaning of standard formatter pretty printing<\/h6>"}, {"comment": "The <span class=\"code\" >Format<\/span> module is versatile enough to let you completely redefine the meaning of pretty printing: you may provide your own functions to define how to handle indentation, line breaking, and even printing of all the characters that have to be printed!"}, {"value": {"name": "Format.set_all_formatter_output_functions", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|15840"}, "info": {"description": "<span class=\"code\" >set_all_formatter_output_functions out flush outnewline outspace<\/span> redirects the pretty-printer output to the functions <span class=\"code\" >out<\/span> and <span class=\"code\" >flush<\/span> as described in <span class=\"code\" >set_formatter_output_functions<\/span>. In addition, the pretty-printer function that outputs a newline is set to the function <span class=\"code\" >outnewline<\/span> and the function that outputs indentation spaces is set to the function <span class=\"code\" >outspace<\/span>.<br><\/br> This way, you can change the meaning of indentation (which can be something else than just printing space characters) and the meaning of new lines opening (which can be connected to any other action needed by the application at hand). The two functions <span class=\"code\" >outspace<\/span> and <span class=\"code\" >outnewline<\/span> are normally connected to <span class=\"code\" >out<\/span> and <span class=\"code\" >flush<\/span>: respective default values for <span class=\"code\" >outspace<\/span> and <span class=\"code\" >outnewline<\/span> are <span class=\"code\" >out (String.make n ' ') 0 n<\/span> and <span class=\"code\" >out \"\\n\" 0 1<\/span>."}, "type": "out:(string -> int -> int -> unit) ->\n  flush:(unit -> unit) ->\n  newline:(unit -> unit) -> spaces:(int -> unit) -> unit", "params": [{"name": "out", "type": "string -> int -> int -> unit"}, {"name": "flush", "type": "unit -> unit"}, {"name": "newline", "type": "unit -> unit"}, {"name": "spaces", "type": "int -> unit"}]}}, {"value": {"name": "Format.get_all_formatter_output_functions", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|16866"}, "info": {"description": "Return the current output functions of the pretty-printer, including line breaking and indentation functions. Useful to record the current setting and restore it afterwards."}, "type": "unit ->\n  (string -> int -> int -> unit) * (unit -> unit) * (unit -> unit) *\n  (int -> unit)", "params": [{"name": "", "type": "unit"}]}}, {"comment": "<h6>Changing the meaning of printing semantics tags<\/h6>"}, {"type": {"name": "Format.formatter_tag_functions", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|17267"}, "info": {"description": "The tag handling functions specific to a formatter: <span class=\"code\" >mark<\/span> versions are the ``tag marking'' functions that associate a string marker to a tag in order for the pretty-printing engine to flush those markers as 0 length tokens in the output device of the formatter. <span class=\"code\" >print<\/span> versions are the ``tag printing'' functions that can perform regular printing when a tag is closed or opened."}, "params": [], "kind": {"type": "record", "private": "false", "fields": [{"name": "mark_open_tag", "mutable": false, "type": "Format.tag -> string"}, {"name": "mark_close_tag", "mutable": false, "type": "Format.tag -> string"}, {"name": "print_open_tag", "mutable": false, "type": "Format.tag -> unit"}, {"name": "print_close_tag", "mutable": false, "type": "Format.tag -> unit"}]}}}, {"value": {"name": "Format.set_formatter_tag_functions", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|17836"}, "info": "", "type": "Format.formatter_tag_functions -> unit", "params": [{"name": "", "type": "Format.formatter_tag_functions"}]}}, {"comment": "<span class=\"code\" >set_formatter_tag_functions tag_funs<\/span> changes the meaning of opening and closing tags to use the functions in <span class=\"code\" >tag_funs<\/span>.<br><\/br> When opening a tag name <span class=\"code\" >t<\/span>, the string <span class=\"code\" >t<\/span> is passed to the opening tag marking function (the <span class=\"code\" >mark_open_tag<\/span> field of the record <span class=\"code\" >tag_funs<\/span>), that must return the opening tag marker for that name. When the next call to <span class=\"code\" >close_tag ()<\/span> happens, the tag name <span class=\"code\" >t<\/span> is sent back to the closing tag marking function (the <span class=\"code\" >mark_close_tag<\/span> field of record <span class=\"code\" >tag_funs<\/span>), that must return a closing tag marker for that name.<br><\/br> The <span class=\"code\" >print_<\/span> field of the record contains the functions that are called at tag opening and tag closing time, to output regular material in the pretty-printer queue."}, {"value": {"name": "Format.get_formatter_tag_functions", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|18654"}, "info": {"description": "Return the current tag functions of the pretty-printer."}, "type": "unit -> Format.formatter_tag_functions", "params": [{"name": "", "type": "unit"}]}}, {"comment": "<h6>Multiple formatted output<\/h6>"}, {"type": {"name": "Format.formatter", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|18832"}, "info": {"description": "Abstract data corresponding to a pretty-printer (also called a formatter) and all its machinery.<br><\/br> Defining new pretty-printers permits unrelated output of material in parallel on several output channels. All the parameters of a pretty-printer are local to this pretty-printer: margin, maximum indentation limit, maximum number of boxes simultaneously opened, ellipsis, and so on, are specific to each pretty-printer and may be fixed independently. Given a <span class=\"code\" >Pervasives.out_channel<\/span> output channel <span class=\"code\" >oc<\/span>, a new formatter writing to that channel is simply obtained by calling <span class=\"code\" >formatter_of_out_channel oc<\/span>. Alternatively, the <span class=\"code\" >make_formatter<\/span> function allocates a new formatter with explicit output and flushing functions (convenient to output material to strings for instance)."}, "params": [], "kind": {"type": "abstract"}}}, {"value": {"name": "Format.formatter_of_out_channel", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|19653"}, "info": {"description": "<span class=\"code\" >formatter_of_out_channel oc<\/span> returns a new formatter that writes to the corresponding channel <span class=\"code\" >oc<\/span>."}, "type": "Pervasives.out_channel -> Format.formatter", "params": [{"name": "", "type": "Pervasives.out_channel"}]}}, {"value": {"name": "Format.std_formatter", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|19823"}, "info": {"description": "The standard formatter used by the formatting functions above. It is defined as <span class=\"code\" >formatter_of_out_channel stdout<\/span>."}, "type": "Format.formatter", "params": []}}, {"value": {"name": "Format.err_formatter", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|19981"}, "info": {"description": "A formatter to use with formatting functions below for output to standard error. It is defined as <span class=\"code\" >formatter_of_out_channel stderr<\/span>."}, "type": "Format.formatter", "params": []}}, {"value": {"name": "Format.formatter_of_buffer", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|20160"}, "info": {"description": "<span class=\"code\" >formatter_of_buffer b<\/span> returns a new formatter writing to buffer <span class=\"code\" >b<\/span>. As usual, the formatter has to be flushed at the end of pretty printing, using <span class=\"code\" >pp_print_flush<\/span> or <span class=\"code\" >pp_print_newline<\/span>, to display all the pending material."}, "type": "Buffer.t -> Format.formatter", "params": [{"name": "", "type": "Buffer.t"}]}}, {"value": {"name": "Format.stdbuf", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|20454"}, "info": {"description": "The string buffer in which <span class=\"code\" >str_formatter<\/span> writes."}, "type": "Buffer.t", "params": []}}, {"value": {"name": "Format.str_formatter", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|20537"}, "info": {"description": "A formatter to use with formatting functions below for output to the <span class=\"code\" >stdbuf<\/span> string buffer. <span class=\"code\" >str_formatter<\/span> is defined as <span class=\"code\" >formatter_of_buffer stdbuf<\/span>."}, "type": "Format.formatter", "params": []}}, {"value": {"name": "Format.flush_str_formatter", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|20736"}, "info": {"description": "Returns the material printed with <span class=\"code\" >str_formatter<\/span>, flushes the formatter and resets the corresponding buffer."}, "type": "unit -> string", "params": [{"name": "", "type": "unit"}]}}, {"value": {"name": "Format.make_formatter", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|20900"}, "info": {"description": "<span class=\"code\" >make_formatter out flush<\/span> returns a new formatter that writes according to the output function <span class=\"code\" >out<\/span>, and the flushing function <span class=\"code\" >flush<\/span>. For instance, a formatter to the <span class=\"code\" >Pervasives.out_channel<\/span> <span class=\"code\" >oc<\/span> is returned by <span class=\"code\" >make_formatter (Pervasives.output oc) (fun () -&gt; Pervasives.flush oc)<\/span>."}, "type": "(string -> int -> int -> unit) -> (unit -> unit) -> Format.formatter", "params": [{"name": "", "type": "string -> int -> int -> unit"}, {"name": "", "type": "unit -> unit"}]}}, {"comment": "<h6>Basic functions to use with formatters<\/h6>"}, {"value": {"name": "Format.pp_open_hbox", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|21342"}, "info": "", "type": "Format.formatter -> unit -> unit", "params": [{"name": "", "type": "Format.formatter"}, {"name": "", "type": "unit"}]}}, {"value": {"name": "Format.pp_open_vbox", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|21389"}, "info": "", "type": "Format.formatter -> int -> unit", "params": [{"name": "", "type": "Format.formatter"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Format.pp_open_hvbox", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|21435"}, "info": "", "type": "Format.formatter -> int -> unit", "params": [{"name": "", "type": "Format.formatter"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Format.pp_open_hovbox", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|21482"}, "info": "", "type": "Format.formatter -> int -> unit", "params": [{"name": "", "type": "Format.formatter"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Format.pp_open_box", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|21530"}, "info": "", "type": "Format.formatter -> int -> unit", "params": [{"name": "", "type": "Format.formatter"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Format.pp_close_box", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|21575"}, "info": "", "type": "Format.formatter -> unit -> unit", "params": [{"name": "", "type": "Format.formatter"}, {"name": "", "type": "unit"}]}}, {"value": {"name": "Format.pp_open_tag", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|21622"}, "info": "", "type": "Format.formatter -> string -> unit", "params": [{"name": "", "type": "Format.formatter"}, {"name": "", "type": "string"}]}}, {"value": {"name": "Format.pp_close_tag", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|21670"}, "info": "", "type": "Format.formatter -> unit -> unit", "params": [{"name": "", "type": "Format.formatter"}, {"name": "", "type": "unit"}]}}, {"value": {"name": "Format.pp_print_string", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|21717"}, "info": "", "type": "Format.formatter -> string -> unit", "params": [{"name": "", "type": "Format.formatter"}, {"name": "", "type": "string"}]}}, {"value": {"name": "Format.pp_print_as", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|21769"}, "info": "", "type": "Format.formatter -> int -> string -> unit", "params": [{"name": "", "type": "Format.formatter"}, {"name": "", "type": "int"}, {"name": "", "type": "string"}]}}, {"value": {"name": "Format.pp_print_int", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|21824"}, "info": "", "type": "Format.formatter -> int -> unit", "params": [{"name": "", "type": "Format.formatter"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Format.pp_print_float", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|21870"}, "info": "", "type": "Format.formatter -> float -> unit", "params": [{"name": "", "type": "Format.formatter"}, {"name": "", "type": "float"}]}}, {"value": {"name": "Format.pp_print_char", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|21920"}, "info": "", "type": "Format.formatter -> char -> unit", "params": [{"name": "", "type": "Format.formatter"}, {"name": "", "type": "char"}]}}, {"value": {"name": "Format.pp_print_bool", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|21968"}, "info": "", "type": "Format.formatter -> bool -> unit", "params": [{"name": "", "type": "Format.formatter"}, {"name": "", "type": "bool"}]}}, {"value": {"name": "Format.pp_print_break", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|22016"}, "info": "", "type": "Format.formatter -> int -> int -> unit", "params": [{"name": "", "type": "Format.formatter"}, {"name": "", "type": "int"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Format.pp_print_cut", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|22071"}, "info": "", "type": "Format.formatter -> unit -> unit", "params": [{"name": "", "type": "Format.formatter"}, {"name": "", "type": "unit"}]}}, {"value": {"name": "Format.pp_print_space", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|22118"}, "info": "", "type": "Format.formatter -> unit -> unit", "params": [{"name": "", "type": "Format.formatter"}, {"name": "", "type": "unit"}]}}, {"value": {"name": "Format.pp_force_newline", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|22167"}, "info": "", "type": "Format.formatter -> unit -> unit", "params": [{"name": "", "type": "Format.formatter"}, {"name": "", "type": "unit"}]}}, {"value": {"name": "Format.pp_print_flush", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|22218"}, "info": "", "type": "Format.formatter -> unit -> unit", "params": [{"name": "", "type": "Format.formatter"}, {"name": "", "type": "unit"}]}}, {"value": {"name": "Format.pp_print_newline", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|22267"}, "info": "", "type": "Format.formatter -> unit -> unit", "params": [{"name": "", "type": "Format.formatter"}, {"name": "", "type": "unit"}]}}, {"value": {"name": "Format.pp_print_if_newline", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|22318"}, "info": "", "type": "Format.formatter -> unit -> unit", "params": [{"name": "", "type": "Format.formatter"}, {"name": "", "type": "unit"}]}}, {"value": {"name": "Format.pp_open_tbox", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|22372"}, "info": "", "type": "Format.formatter -> unit -> unit", "params": [{"name": "", "type": "Format.formatter"}, {"name": "", "type": "unit"}]}}, {"value": {"name": "Format.pp_close_tbox", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|22419"}, "info": "", "type": "Format.formatter -> unit -> unit", "params": [{"name": "", "type": "Format.formatter"}, {"name": "", "type": "unit"}]}}, {"value": {"name": "Format.pp_print_tbreak", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|22467"}, "info": "", "type": "Format.formatter -> int -> int -> unit", "params": [{"name": "", "type": "Format.formatter"}, {"name": "", "type": "int"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Format.pp_set_tab", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|22523"}, "info": "", "type": "Format.formatter -> unit -> unit", "params": [{"name": "", "type": "Format.formatter"}, {"name": "", "type": "unit"}]}}, {"value": {"name": "Format.pp_print_tab", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|22568"}, "info": "", "type": "Format.formatter -> unit -> unit", "params": [{"name": "", "type": "Format.formatter"}, {"name": "", "type": "unit"}]}}, {"value": {"name": "Format.pp_set_tags", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|22615"}, "info": "", "type": "Format.formatter -> bool -> unit", "params": [{"name": "", "type": "Format.formatter"}, {"name": "", "type": "bool"}]}}, {"value": {"name": "Format.pp_set_print_tags", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|22661"}, "info": "", "type": "Format.formatter -> bool -> unit", "params": [{"name": "", "type": "Format.formatter"}, {"name": "", "type": "bool"}]}}, {"value": {"name": "Format.pp_set_mark_tags", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|22713"}, "info": "", "type": "Format.formatter -> bool -> unit", "params": [{"name": "", "type": "Format.formatter"}, {"name": "", "type": "bool"}]}}, {"value": {"name": "Format.pp_get_print_tags", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|22764"}, "info": "", "type": "Format.formatter -> unit -> bool", "params": [{"name": "", "type": "Format.formatter"}, {"name": "", "type": "unit"}]}}, {"value": {"name": "Format.pp_get_mark_tags", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|22816"}, "info": "", "type": "Format.formatter -> unit -> bool", "params": [{"name": "", "type": "Format.formatter"}, {"name": "", "type": "unit"}]}}, {"value": {"name": "Format.pp_set_margin", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|22867"}, "info": "", "type": "Format.formatter -> int -> unit", "params": [{"name": "", "type": "Format.formatter"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Format.pp_get_margin", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|22914"}, "info": "", "type": "Format.formatter -> unit -> int", "params": [{"name": "", "type": "Format.formatter"}, {"name": "", "type": "unit"}]}}, {"value": {"name": "Format.pp_set_max_indent", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|22961"}, "info": "", "type": "Format.formatter -> int -> unit", "params": [{"name": "", "type": "Format.formatter"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Format.pp_get_max_indent", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|23012"}, "info": "", "type": "Format.formatter -> unit -> int", "params": [{"name": "", "type": "Format.formatter"}, {"name": "", "type": "unit"}]}}, {"value": {"name": "Format.pp_set_max_boxes", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|23063"}, "info": "", "type": "Format.formatter -> int -> unit", "params": [{"name": "", "type": "Format.formatter"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Format.pp_get_max_boxes", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|23113"}, "info": "", "type": "Format.formatter -> unit -> int", "params": [{"name": "", "type": "Format.formatter"}, {"name": "", "type": "unit"}]}}, {"value": {"name": "Format.pp_over_max_boxes", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|23163"}, "info": "", "type": "Format.formatter -> unit -> bool", "params": [{"name": "", "type": "Format.formatter"}, {"name": "", "type": "unit"}]}}, {"value": {"name": "Format.pp_set_ellipsis_text", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|23215"}, "info": "", "type": "Format.formatter -> string -> unit", "params": [{"name": "", "type": "Format.formatter"}, {"name": "", "type": "string"}]}}, {"value": {"name": "Format.pp_get_ellipsis_text", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|23272"}, "info": "", "type": "Format.formatter -> unit -> string", "params": [{"name": "", "type": "Format.formatter"}, {"name": "", "type": "unit"}]}}, {"value": {"name": "Format.pp_set_formatter_out_channel", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|23329"}, "info": "", "type": "Format.formatter -> Pervasives.out_channel -> unit", "params": [{"name": "", "type": "Format.formatter"}, {"name": "", "type": "Pervasives.out_channel"}]}}, {"value": {"name": "Format.pp_set_formatter_output_functions", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|23410"}, "info": "", "type": "Format.formatter -> (string -> int -> int -> unit) -> (unit -> unit) -> unit", "params": [{"name": "", "type": "Format.formatter"}, {"name": "", "type": "string -> int -> int -> unit"}, {"name": "", "type": "unit -> unit"}]}}, {"value": {"name": "Format.pp_get_formatter_output_functions", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|23525"}, "info": "", "type": "Format.formatter -> unit -> (string -> int -> int -> unit) * (unit -> unit)", "params": [{"name": "", "type": "Format.formatter"}, {"name": "", "type": "unit"}]}}, {"value": {"name": "Format.pp_set_all_formatter_output_functions", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|23639"}, "info": "", "type": "Format.formatter ->\n  out:(string -> int -> int -> unit) ->\n  flush:(unit -> unit) ->\n  newline:(unit -> unit) -> spaces:(int -> unit) -> unit", "params": [{"name": "", "type": "Format.formatter"}, {"name": "out", "type": "string -> int -> int -> unit"}, {"name": "flush", "type": "unit -> unit"}, {"name": "newline", "type": "unit -> unit"}, {"name": "spaces", "type": "int -> unit"}]}}, {"value": {"name": "Format.pp_get_all_formatter_output_functions", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|23820"}, "info": "", "type": "Format.formatter ->\n  unit ->\n  (string -> int -> int -> unit) * (unit -> unit) * (unit -> unit) *\n  (int -> unit)", "params": [{"name": "", "type": "Format.formatter"}, {"name": "", "type": "unit"}]}}, {"value": {"name": "Format.pp_set_formatter_tag_functions", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|23975"}, "info": "", "type": "Format.formatter -> Format.formatter_tag_functions -> unit", "params": [{"name": "", "type": "Format.formatter"}, {"name": "", "type": "Format.formatter_tag_functions"}]}}, {"value": {"name": "Format.pp_get_formatter_tag_functions", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|24062"}, "info": {"description": "These functions are the basic ones: usual functions operating on the standard formatter are defined via partial evaluation of these primitives. For instance, <span class=\"code\" >print_string<\/span> is equal to <span class=\"code\" >pp_print_string std_formatter<\/span>."}, "type": "Format.formatter -> unit -> Format.formatter_tag_functions", "params": [{"name": "", "type": "Format.formatter"}, {"name": "", "type": "unit"}]}}, {"comment": "<h6><span class=\"code\" >printf<\/span> like functions for pretty-printing.<\/h6>"}, {"value": {"name": "Format.fprintf", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|24441"}, "info": "", "type": "Format.formatter -> ('a, Format.formatter, unit) Pervasives.format -> 'a", "params": [{"name": "", "type": "Format.formatter"}, {"name": "", "type": "('a, Format.formatter, unit) Pervasives.format"}]}}, {"comment": "<span class=\"code\" >fprintf ff fmt arg1 ... argN<\/span> formats the arguments <span class=\"code\" >arg1<\/span> to <span class=\"code\" >argN<\/span> according to the format string <span class=\"code\" >fmt<\/span>, and outputs the resulting string on the formatter <span class=\"code\" >ff<\/span>.<br><\/br> The format <span class=\"code\" >fmt<\/span> is a character string which contains three types of objects: plain characters and conversion specifications as specified in the <span class=\"code\" >Printf<\/span> module, and pretty-printing indications specific to the <span class=\"code\" >Format<\/span> module.<br><\/br> The pretty-printing indication characters are introduced by a <span class=\"code\" >@<\/span> character, and their meanings are:<ul><li><span class=\"code\" >@[<\/span>: open a pretty-printing box. The type and offset of the box may be optionally specified with the following syntax: the <span class=\"code\" >&lt;<\/span> character, followed by an optional box type indication, then an optional integer offset, and the closing <span class=\"code\" >&gt;<\/span> character. Box type is one of <span class=\"code\" >h<\/span>, <span class=\"code\" >v<\/span>, <span class=\"code\" >hv<\/span>, <span class=\"code\" >b<\/span>, or <span class=\"code\" >hov<\/span>, which stand respectively for an horizontal box, a vertical box, an ``horizontal-vertical'' box, or an ``horizontal or vertical'' box (<span class=\"code\" >b<\/span> standing for an ``horizontal or vertical'' box demonstrating indentation and <span class=\"code\" >hov<\/span> standing for a regular``horizontal or vertical'' box). For instance, <span class=\"code\" >@[&lt;hov 2&gt;<\/span> opens an ``horizontal or vertical'' box with indentation 2 as obtained with <span class=\"code\" >open_hovbox 2<\/span>. For more details about boxes, see the various box opening functions <span class=\"code\" >open_*box<\/span>.<\/li><li><span class=\"code\" >@]<\/span>: close the most recently opened pretty-printing box.<\/li><li><span class=\"code\" >@,<\/span>: output a good break as with <span class=\"code\" >print_cut ()<\/span>.<\/li><li><span class=\"code\" >@ <\/span>: output a space, as with <span class=\"code\" >print_space ()<\/span>.<\/li><li><span class=\"code\" >@\\n<\/span>: force a newline, as with <span class=\"code\" >force_newline ()<\/span>.<\/li><li><span class=\"code\" >@;<\/span>: output a good break as with <span class=\"code\" >print_break<\/span>. The <span class=\"code\" >nspaces<\/span> and <span class=\"code\" >offset<\/span> parameters of the break may be optionally specified with the following syntax: the <span class=\"code\" >&lt;<\/span> character, followed by an integer <span class=\"code\" >nspaces<\/span> value, then an integer <span class=\"code\" >offset<\/span>, and a closing <span class=\"code\" >&gt;<\/span> character. If no parameters are provided, the good break defaults to a space.<\/li><li><span class=\"code\" >@?<\/span>: flush the pretty printer as with <span class=\"code\" >print_flush ()<\/span>. This is equivalent to the conversion <span class=\"code\" >%!<\/span>.<\/li><li><span class=\"code\" >@.<\/span>: flush the pretty printer and output a new line, as with <span class=\"code\" >print_newline ()<\/span>.<\/li><li><span class=\"code\" >@&lt;n&gt;<\/span>: print the following item as if it were of length <span class=\"code\" >n<\/span>. Hence, <span class=\"code\" >printf \"@&lt;0&gt;%s\" arg<\/span> is equivalent to <span class=\"code\" >print_as 0 arg<\/span>. If <span class=\"code\" >@&lt;n&gt;<\/span> is not followed by a conversion specification, then the following character of the format is printed as if it were of length <span class=\"code\" >n<\/span>.<\/li><li><span class=\"code\" >@{<\/span>: open a tag. The name of the tag may be optionally specified with the following syntax: the <span class=\"code\" >&lt;<\/span> character, followed by an optional string specification, and the closing <span class=\"code\" >&gt;<\/span> character. The string specification is any character string that does not contain the closing character <span class=\"code\" >'&gt;'<\/span>. If omitted, the tag name defaults to the empty string. For more details about tags, see the functions <span class=\"code\" >open_tag<\/span> and <span class=\"code\" >close_tag<\/span>.<\/li><li><span class=\"code\" >@}<\/span>: close the most recently opened tag.<\/li><li><span class=\"code\" >@@<\/span>: print a plain <span class=\"code\" >@<\/span> character.<\/li><\/ul> Example: <span class=\"code\" >printf \"@[%s@ %d@]@.\" \"x =\" 1<\/span> is equivalent to <span class=\"code\" >open_box (); print_string \"x =\"; print_space (); print_int 1; close_box (); print_newline ()<\/span>. It prints <span class=\"code\" >x = 1<\/span> within a pretty-printing box."}, {"value": {"name": "Format.printf", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|27740"}, "info": {"description": "Same as <span class=\"code\" >fprintf<\/span> above, but output on <span class=\"code\" >std_formatter<\/span>."}, "type": "('a, Format.formatter, unit) Pervasives.format -> 'a", "params": [{"name": "", "type": "('a, Format.formatter, unit) Pervasives.format"}]}}, {"value": {"name": "Format.eprintf", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|27854"}, "info": {"description": "Same as <span class=\"code\" >fprintf<\/span> above, but output on <span class=\"code\" >err_formatter<\/span>."}, "type": "('a, Format.formatter, unit) Pervasives.format -> 'a", "params": [{"name": "", "type": "('a, Format.formatter, unit) Pervasives.format"}]}}, {"value": {"name": "Format.sprintf", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|27969"}, "info": {"description": "Same as <span class=\"code\" >printf<\/span> above, but instead of printing on a formatter, returns a string containing the result of formatting the arguments. Note that the pretty-printer queue is flushed at the end of <em>each call<\/em> to <span class=\"code\" >sprintf<\/span>.<br><\/br> In case of multiple and related calls to <span class=\"code\" >sprintf<\/span> to output material on a single string, you should consider using <span class=\"code\" >fprintf<\/span> with the predefined formatter <span class=\"code\" >str_formatter<\/span> and call <span class=\"code\" >flush_str_formatter ()<\/span> to get the final result.<br><\/br> Alternatively, you can use <span class=\"code\" >Format.fprintf<\/span> with a formatter writing to a buffer of your own: flushing the formatter and the buffer at the end of pretty-printing returns the desired string."}, "type": "('a, unit, string) Pervasives.format -> 'a", "params": [{"name": "", "type": "('a, unit, string) Pervasives.format"}]}}, {"value": {"name": "Format.ifprintf", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|28698"}, "info": {"description": "Same as <span class=\"code\" >fprintf<\/span> above, but does not print anything. Useful to ignore some material when conditionally printing.", "since": "3.10.0"}, "type": "Format.formatter -> ('a, Format.formatter, unit) Pervasives.format -> 'a", "params": [{"name": "", "type": "Format.formatter"}, {"name": "", "type": "('a, Format.formatter, unit) Pervasives.format"}]}}, {"comment": "Formatted output functions with continuations."}, {"value": {"name": "Format.kfprintf", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|28960"}, "info": {"description": "Same as <span class=\"code\" >fprintf<\/span> above, but instead of returning immediately, passes the formatter to its first argument at the end of printing."}, "type": "(Format.formatter -> 'a) ->\n  Format.formatter -> ('b, Format.formatter, unit, 'a) Pervasives.format4 -> 'b", "params": [{"name": "", "type": "Format.formatter -> 'a"}, {"name": "", "type": "Format.formatter"}, {"name": "", "type": "('a, Format.formatter, unit, 'b) Pervasives.format4"}]}}, {"value": {"name": "Format.ikfprintf", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|29207"}, "info": {"description": "Same as <span class=\"code\" >kfprintf<\/span> above, but does not print anything. Useful to ignore some material when conditionally printing.", "since": "3.12.0"}, "type": "(Format.formatter -> 'a) ->\n  Format.formatter -> ('b, Format.formatter, unit, 'a) Pervasives.format4 -> 'b", "params": [{"name": "", "type": "Format.formatter -> 'a"}, {"name": "", "type": "Format.formatter"}, {"name": "", "type": "('a, Format.formatter, unit, 'b) Pervasives.format4"}]}}, {"value": {"name": "Format.ksprintf", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|29457"}, "info": {"description": "Same as <span class=\"code\" >sprintf<\/span> above, but instead of returning the string, passes it to the first argument."}, "type": "(string -> 'a) -> ('b, unit, string, 'a) Pervasives.format4 -> 'b", "params": [{"name": "", "type": "string -> 'a"}, {"name": "", "type": "('a, unit, string, 'b) Pervasives.format4"}]}}, {"comment": "<h6>Deprecated<\/h6>"}, {"value": {"name": "Format.bprintf", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|29658"}, "info": {"description": "Deprecated and error prone function. Do not use it.<br><\/br> If you need to print to some buffer <span class=\"code\" >b<\/span>, you must first define a formatter writing to <span class=\"code\" >b<\/span>, using <span class=\"code\" >let to_b = formatter_of_buffer b<\/span>; then use regular calls to <span class=\"code\" >Format.fprintf<\/span> on formatter <span class=\"code\" >to_b<\/span>."}, "type": "Buffer.t -> ('a, Format.formatter, unit) Pervasives.format -> 'a", "params": [{"name": "", "type": "Buffer.t"}, {"name": "", "type": "('a, Format.formatter, unit) Pervasives.format"}]}}, {"value": {"name": "Format.kprintf", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/format.mli|29985"}, "info": {"description": "Deprecated name. A synonym for <span class=\"code\" >ksprintf<\/span>."}, "type": "(string -> 'a) -> ('b, unit, string, 'a) Pervasives.format4 -> 'b", "params": [{"name": "", "type": "string -> 'a"}, {"name": "", "type": "('a, unit, string, 'b) Pervasives.format4"}]}}], "dependencies": {"uses": ["Pervasives", "Buffer"], "used_by": []}}}, "Printf": {"module": {"name": "Printf", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/printf.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/printf.mli|0"}, "info": {"description": "Formatted output functions."}, "type": "sig  end", "module_structure": [{"comment": "Formatted output functions."}, {"value": {"name": "Printf.fprintf", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/printf.mli|1001"}, "info": {"description": "<span class=\"code\" >fprintf outchan format arg1 ... argN<\/span> formats the arguments <span class=\"code\" >arg1<\/span> to <span class=\"code\" >argN<\/span> according to the format string <span class=\"code\" >format<\/span>, and outputs the resulting string on the channel <span class=\"code\" >outchan<\/span>.<br><\/br> The format is a character string which contains two types of objects: plain characters, which are simply copied to the output channel, and conversion specifications, each of which causes conversion and printing of arguments.<br><\/br> Conversion specifications have the following form:<br><\/br> <span class=\"code\" >% [flags] [width] [.precision] type<\/span><br><\/br> In short, a conversion specification consists in the <span class=\"code\" >%<\/span> character, followed by optional modifiers and a type which is made of one or two characters. The types and their meanings are:<br><\/br><ul><li><span class=\"code\" >d<\/span>, <span class=\"code\" >i<\/span>, <span class=\"code\" >n<\/span>, <span class=\"code\" >l<\/span>, <span class=\"code\" >L<\/span>, or <span class=\"code\" >N<\/span>: convert an integer argument to signed decimal.<\/li><li><span class=\"code\" >u<\/span>: convert an integer argument to unsigned decimal.<\/li><li><span class=\"code\" >x<\/span>: convert an integer argument to unsigned hexadecimal, using lowercase letters.<\/li><li><span class=\"code\" >X<\/span>: convert an integer argument to unsigned hexadecimal, using uppercase letters.<\/li><li><span class=\"code\" >o<\/span>: convert an integer argument to unsigned octal.<\/li><li><span class=\"code\" >s<\/span>: insert a string argument.<\/li><li><span class=\"code\" >S<\/span>: insert a string argument in Caml syntax (double quotes, escapes).<\/li><li><span class=\"code\" >c<\/span>: insert a character argument.<\/li><li><span class=\"code\" >C<\/span>: insert a character argument in Caml syntax (single quotes, escapes).<\/li><li><span class=\"code\" >f<\/span>: convert a floating-point argument to decimal notation, in the style <span class=\"code\" >dddd.ddd<\/span>.<\/li><li><span class=\"code\" >F<\/span>: convert a floating-point argument to Caml syntax (<span class=\"code\" >dddd.<\/span> or <span class=\"code\" >dddd.ddd<\/span> or <span class=\"code\" >d.ddd e+-dd<\/span>).<\/li><li><span class=\"code\" >e<\/span> or <span class=\"code\" >E<\/span>: convert a floating-point argument to decimal notation, in the style <span class=\"code\" >d.ddd e+-dd<\/span> (mantissa and exponent).<\/li><li><span class=\"code\" >g<\/span> or <span class=\"code\" >G<\/span>: convert a floating-point argument to decimal notation, in style <span class=\"code\" >f<\/span> or <span class=\"code\" >e<\/span>, <span class=\"code\" >E<\/span> (whichever is more compact).<\/li><li><span class=\"code\" >B<\/span>: convert a boolean argument to the string <span class=\"code\" >true<\/span> or <span class=\"code\" >false<\/span><\/li><li><span class=\"code\" >b<\/span>: convert a boolean argument (for backward compatibility; do not use in new programs).<\/li><li><span class=\"code\" >ld<\/span>, <span class=\"code\" >li<\/span>, <span class=\"code\" >lu<\/span>, <span class=\"code\" >lx<\/span>, <span class=\"code\" >lX<\/span>, <span class=\"code\" >lo<\/span>: convert an <span class=\"code\" >int32<\/span> argument to the format specified by the second letter (decimal, hexadecimal, etc).<\/li><li><span class=\"code\" >nd<\/span>, <span class=\"code\" >ni<\/span>, <span class=\"code\" >nu<\/span>, <span class=\"code\" >nx<\/span>, <span class=\"code\" >nX<\/span>, <span class=\"code\" >no<\/span>: convert a <span class=\"code\" >nativeint<\/span> argument to the format specified by the second letter.<\/li><li><span class=\"code\" >Ld<\/span>, <span class=\"code\" >Li<\/span>, <span class=\"code\" >Lu<\/span>, <span class=\"code\" >Lx<\/span>, <span class=\"code\" >LX<\/span>, <span class=\"code\" >Lo<\/span>: convert an <span class=\"code\" >int64<\/span> argument to the format specified by the second letter.<\/li><li><span class=\"code\" >a<\/span>: user-defined printer. Takes two arguments and applies the first one to <span class=\"code\" >outchan<\/span> (the current output channel) and to the second argument. The first argument must therefore have type <span class=\"code\" >out_channel -&gt; 'b -&gt; unit<\/span> and the second <span class=\"code\" >'b<\/span>. The output produced by the function is inserted in the output of <span class=\"code\" >fprintf<\/span> at the current point.<\/li><li><span class=\"code\" >t<\/span>: same as <span class=\"code\" >%a<\/span>, but takes only one argument (with type <span class=\"code\" >out_channel -&gt; unit<\/span>) and apply it to <span class=\"code\" >outchan<\/span>.<\/li><li><span class=\"code\" >{ fmt %}<\/span>: convert a format string argument. The argument must have the same type as the internal format string <span class=\"code\" >fmt<\/span>.<\/li><li><span class=\"code\" >( fmt %)<\/span>: format string substitution. Takes a format string argument and substitutes it to the internal format string <span class=\"code\" >fmt<\/span> to print following arguments. The argument must have the same type as <span class=\"code\" >fmt<\/span>.<\/li><li><span class=\"code\" >!<\/span>: take no argument and flush the output.<\/li><li><span class=\"code\" >%<\/span>: take no argument and output one <span class=\"code\" >%<\/span> character.<\/li><li><span class=\"code\" >,<\/span>: the no-op delimiter for conversion specifications.<\/li><\/ul> The optional <span class=\"code\" >flags<\/span> are:<ul><li><span class=\"code\" >-<\/span>: left-justify the output (default is right justification).<\/li><li><span class=\"code\" >0<\/span>: for numerical conversions, pad with zeroes instead of spaces.<\/li><li><span class=\"code\" >+<\/span>: for numerical conversions, prefix number with a <span class=\"code\" >+<\/span> sign if positive.<\/li><li>space: for numerical conversions, prefix number with a space if positive.<\/li><li><span class=\"code\" >#<\/span>: request an alternate formatting style for numbers.<\/li><\/ul> The optional <span class=\"code\" >width<\/span> is an integer indicating the minimal width of the result. For instance, <span class=\"code\" >%6d<\/span> prints an integer, prefixing it with spaces to fill at least 6 characters.<br><\/br> The optional <span class=\"code\" >precision<\/span> is a dot <span class=\"code\" >.<\/span> followed by an integer indicating how many digits follow the decimal point in the <span class=\"code\" >%f<\/span>, <span class=\"code\" >%e<\/span>, and <span class=\"code\" >%E<\/span> conversions. For instance, <span class=\"code\" >%.4f<\/span> prints a <span class=\"code\" >float<\/span> with 4 fractional digits.<br><\/br> The integer in a <span class=\"code\" >width<\/span> or <span class=\"code\" >precision<\/span> can also be specified as <span class=\"code\" ><\/span>, in which case an extra integer argument is taken to specify the corresponding <span class=\"code\" >width<\/span> or <span class=\"code\" >precision<\/span>. This integer argument precedes immediately the argument to print. For instance, <span class=\"code\" >%.*f<\/span> prints a <span class=\"code\" >float<\/span> with as many fractional digits as the value of the argument given before the float."}, "type": "Pervasives.out_channel ->\n  ('a, Pervasives.out_channel, unit) Pervasives.format -> 'a", "params": [{"name": "", "type": "Pervasives.out_channel"}, {"name": "", "type": "('a, Pervasives.out_channel, unit) Pervasives.format"}]}}, {"value": {"name": "Printf.printf", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/printf.mli|5625"}, "info": {"description": "Same as <a href=\"{value|Printf.fprintf}\" ><span class=\"code\" >Printf.fprintf<\/span><\/a>, but output on <span class=\"code\" >stdout<\/span>."}, "type": "('a, Pervasives.out_channel, unit) Pervasives.format -> 'a", "params": [{"name": "", "type": "('a, Pervasives.out_channel, unit) Pervasives.format"}]}}, {"value": {"name": "Printf.eprintf", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/printf.mli|5734"}, "info": {"description": "Same as <a href=\"{value|Printf.fprintf}\" ><span class=\"code\" >Printf.fprintf<\/span><\/a>, but output on <span class=\"code\" >stderr<\/span>."}, "type": "('a, Pervasives.out_channel, unit) Pervasives.format -> 'a", "params": [{"name": "", "type": "('a, Pervasives.out_channel, unit) Pervasives.format"}]}}, {"value": {"name": "Printf.ifprintf", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/printf.mli|5844"}, "info": {"description": "Same as <a href=\"{value|Printf.fprintf}\" ><span class=\"code\" >Printf.fprintf<\/span><\/a>, but does not print anything. Useful to ignore some material when conditionally printing.", "since": "3.10.0"}, "type": "'a -> ('b, 'a, unit) Pervasives.format -> 'b", "params": [{"name": "", "type": "'a"}, {"name": "", "type": "('a, 'b, unit) Pervasives.format"}]}}, {"value": {"name": "Printf.sprintf", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/printf.mli|6039"}, "info": {"description": "Same as <a href=\"{value|Printf.fprintf}\" ><span class=\"code\" >Printf.fprintf<\/span><\/a>, but instead of printing on an output channel, return a string containing the result of formatting the arguments."}, "type": "('a, unit, string) Pervasives.format -> 'a", "params": [{"name": "", "type": "('a, unit, string) Pervasives.format"}]}}, {"value": {"name": "Printf.bprintf", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/printf.mli|6236"}, "info": {"description": "Same as <a href=\"{value|Printf.fprintf}\" ><span class=\"code\" >Printf.fprintf<\/span><\/a>, but instead of printing on an output channel, append the formatted arguments to the given extensible buffer (see module <a href=\"{module|Buffer}\" ><span class=\"code\" >Buffer<\/span><\/a>)."}, "type": "Buffer.t -> ('a, Buffer.t, unit) Pervasives.format -> 'a", "params": [{"name": "", "type": "Buffer.t"}, {"name": "", "type": "('a, Buffer.t, unit) Pervasives.format"}]}}, {"comment": "Formatted output functions with continuations."}, {"value": {"name": "Printf.kfprintf", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/printf.mli|6524"}, "info": {"description": "Same as <span class=\"code\" >fprintf<\/span>, but instead of returning immediately, passes the out channel to its first argument at the end of printing.", "since": "3.09.0"}, "type": "(Pervasives.out_channel -> 'a) ->\n  Pervasives.out_channel ->\n  ('b, Pervasives.out_channel, unit, 'a) Pervasives.format4 -> 'b", "params": [{"name": "", "type": "Pervasives.out_channel -> 'a"}, {"name": "", "type": "Pervasives.out_channel"}, {"name": "", "type": "('a, Pervasives.out_channel, unit, 'b) Pervasives.format4"}]}}, {"value": {"name": "Printf.ksprintf", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/printf.mli|6789"}, "info": {"description": "Same as <span class=\"code\" >sprintf<\/span> above, but instead of returning the string, passes it to the first argument.", "since": "3.09.0"}, "type": "(string -> 'a) -> ('b, unit, string, 'a) Pervasives.format4 -> 'b", "params": [{"name": "", "type": "string -> 'a"}, {"name": "", "type": "('a, unit, string, 'b) Pervasives.format4"}]}}, {"value": {"name": "Printf.kbprintf", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/printf.mli|6984"}, "info": {"description": "Same as <span class=\"code\" >bprintf<\/span>, but instead of returning immediately, passes the buffer to its first argument at the end of printing.", "since": "3.10.0"}, "type": "(Buffer.t -> 'a) ->\n  Buffer.t -> ('b, Buffer.t, unit, 'a) Pervasives.format4 -> 'b", "params": [{"name": "", "type": "Buffer.t -> 'a"}, {"name": "", "type": "Buffer.t"}, {"name": "", "type": "('a, Buffer.t, unit, 'b) Pervasives.format4"}]}}, {"value": {"name": "Printf.kprintf", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/printf.mli|7235"}, "info": {"description": "A deprecated synonym for <span class=\"code\" >ksprintf<\/span>."}, "type": "(string -> 'a) -> ('b, unit, string, 'a) Pervasives.format4 -> 'b", "params": [{"name": "", "type": "string -> 'a"}, {"name": "", "type": "('a, unit, string, 'b) Pervasives.format4"}]}}], "dependencies": {"uses": ["Pervasives", "Obj", "Buffer"], "used_by": []}}}, "Parsing": {"module": {"name": "Parsing", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/parsing.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/parsing.mli|0"}, "info": {"description": "The run-time library for parsers generated by <span class=\"code\" >ocamlyacc<\/span>."}, "type": "sig  end", "module_structure": [{"value": {"name": "Parsing.symbol_start", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/parsing.mli|1017"}, "info": {"description": "<span class=\"code\" >symbol_start<\/span> and <a href=\"{value|Parsing.symbol_end}\" ><span class=\"code\" >Parsing.symbol_end<\/span><\/a> are to be called in the action part of a grammar rule only. They return the offset of the string that matches the left-hand side of the rule: <span class=\"code\" >symbol_start()<\/span> returns the offset of the first character; <span class=\"code\" >symbol_end()<\/span> returns the offset after the last character. The first character in a file is at offset 0."}, "type": "unit -> int", "params": [{"name": "", "type": "unit"}]}}, {"value": {"name": "Parsing.symbol_end", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/parsing.mli|1420"}, "info": {"description": "See <a href=\"{value|Parsing.symbol_start}\" ><span class=\"code\" >Parsing.symbol_start<\/span><\/a>."}, "type": "unit -> int", "params": [{"name": "", "type": "unit"}]}}, {"value": {"name": "Parsing.rhs_start", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/parsing.mli|1486"}, "info": {"description": "Same as <a href=\"{value|Parsing.symbol_start}\" ><span class=\"code\" >Parsing.symbol_start<\/span><\/a> and <a href=\"{value|Parsing.symbol_end}\" ><span class=\"code\" >Parsing.symbol_end<\/span><\/a>, but return the offset of the string matching the <span class=\"code\" >n<\/span>th item on the right-hand side of the rule, where <span class=\"code\" >n<\/span> is the integer parameter to <span class=\"code\" >rhs_start<\/span> and <span class=\"code\" >rhs_end<\/span>. <span class=\"code\" >n<\/span> is 1 for the leftmost item."}, "type": "int -> int", "params": [{"name": "", "type": "int"}]}}, {"value": {"name": "Parsing.rhs_end", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/parsing.mli|1782"}, "info": {"description": "See <a href=\"{value|Parsing.rhs_start}\" ><span class=\"code\" >Parsing.rhs_start<\/span><\/a>."}, "type": "int -> int", "params": [{"name": "", "type": "int"}]}}, {"value": {"name": "Parsing.symbol_start_pos", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/parsing.mli|1841"}, "info": {"description": "Same as <span class=\"code\" >symbol_start<\/span>, but return a <span class=\"code\" >position<\/span> instead of an offset."}, "type": "unit -> Lexing.position", "params": [{"name": "", "type": "unit"}]}}, {"value": {"name": "Parsing.symbol_end_pos", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/parsing.mli|1968"}, "info": {"description": "Same as <span class=\"code\" >symbol_end<\/span>, but return a <span class=\"code\" >position<\/span> instead of an offset."}, "type": "unit -> Lexing.position", "params": [{"name": "", "type": "unit"}]}}, {"value": {"name": "Parsing.rhs_start_pos", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/parsing.mli|2089"}, "info": {"description": "Same as <span class=\"code\" >rhs_start<\/span>, but return a <span class=\"code\" >position<\/span> instead of an offset."}, "type": "int -> Lexing.position", "params": [{"name": "", "type": "int"}]}}, {"value": {"name": "Parsing.rhs_end_pos", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/parsing.mli|2207"}, "info": {"description": "Same as <span class=\"code\" >rhs_end<\/span>, but return a <span class=\"code\" >position<\/span> instead of an offset."}, "type": "int -> Lexing.position", "params": [{"name": "", "type": "int"}]}}, {"value": {"name": "Parsing.clear_parser", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/parsing.mli|2321"}, "info": {"description": "Empty the parser stack. Call it just after a parsing function has returned, to remove all pointers from the parser stack to structures that were built by semantic actions during parsing. This is optional, but lowers the memory requirements of the programs."}, "type": "unit -> unit", "params": [{"name": "", "type": "unit"}]}}, {"exception": {"name": "Parsing.Parse_error", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/parsing.mli|2630"}, "info": {"description": "Raised when a parser encounters a syntax error. Can also be raised from the action part of a grammar rule, to initiate error recovery."}}}, {"value": {"name": "Parsing.set_trace", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/parsing.mli|2801"}, "info": {"description": "Control debugging support for <span class=\"code\" >ocamlyacc<\/span>-generated parsers. After <span class=\"code\" >Parsing.set_trace true<\/span>, the pushdown automaton that executes the parsers prints a trace of its actions (reading a token, shifting a state, reducing by a rule) on standard output. <span class=\"code\" >Parsing.set_trace false<\/span> turns this debugging trace off. The boolean returned is the previous state of the trace flag.", "since": "3.11.0"}, "type": "bool -> bool", "params": [{"name": "", "type": "bool"}]}}], "dependencies": {"uses": ["Obj", "Lexing"], "used_by": []}}}, "CamlinternalOO": {"module": {"name": "CamlinternalOO", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/camlinternalOO.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/camlinternalOO.mli|0"}, "info": {"description": "Run-time support for objects and classes. All functions in this module are for system use only, not for the casual user."}, "type": "sig  end", "module_structure": [{"comment": "<h6>Classes<\/h6>"}, {"type": {"name": "CamlinternalOO.tag", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/camlinternalOO.mli|1119"}, "info": "", "params": [], "kind": {"type": "abstract"}}}, {"type": {"name": "CamlinternalOO.label", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/camlinternalOO.mli|1128"}, "info": "", "params": [], "kind": {"type": "abstract"}}}, {"type": {"name": "CamlinternalOO.table", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/camlinternalOO.mli|1139"}, "info": "", "params": [], "kind": {"type": "abstract"}}}, {"type": {"name": "CamlinternalOO.meth", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/camlinternalOO.mli|1150"}, "info": "", "params": [], "kind": {"type": "abstract"}}}, {"type": {"name": "CamlinternalOO.t", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/camlinternalOO.mli|1160"}, "info": "", "params": [], "kind": {"type": "abstract"}}}, {"type": {"name": "CamlinternalOO.obj", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/camlinternalOO.mli|1167"}, "info": "", "params": [], "kind": {"type": "abstract"}}}, {"type": {"name": "CamlinternalOO.closure", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/camlinternalOO.mli|1176"}, "info": "", "params": [], "kind": {"type": "abstract"}}}, {"value": {"name": "CamlinternalOO.public_method_label", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/camlinternalOO.mli|1184"}, "info": "", "type": "string -> CamlinternalOO.tag", "params": [{"name": "", "type": "string"}]}}, {"value": {"name": "CamlinternalOO.new_method", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/camlinternalOO.mli|1224"}, "info": "", "type": "CamlinternalOO.table -> CamlinternalOO.label", "params": [{"name": "", "type": "CamlinternalOO.table"}]}}, {"value": {"name": "CamlinternalOO.new_variable", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/camlinternalOO.mli|1256"}, "info": "", "type": "CamlinternalOO.table -> string -> int", "params": [{"name": "", "type": "CamlinternalOO.table"}, {"name": "", "type": "string"}]}}, {"value": {"name": "CamlinternalOO.new_methods_variables", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/camlinternalOO.mli|1298"}, "info": "", "type": "CamlinternalOO.table ->\n  string array -> string array -> CamlinternalOO.label array", "params": [{"name": "", "type": "CamlinternalOO.table"}, {"name": "", "type": "string array"}, {"name": "", "type": "string array"}]}}, {"value": {"name": "CamlinternalOO.get_variable", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/camlinternalOO.mli|1383"}, "info": "", "type": "CamlinternalOO.table -> string -> int", "params": [{"name": "", "type": "CamlinternalOO.table"}, {"name": "", "type": "string"}]}}, {"value": {"name": "CamlinternalOO.get_variables", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/camlinternalOO.mli|1425"}, "info": "", "type": "CamlinternalOO.table -> string array -> int array", "params": [{"name": "", "type": "CamlinternalOO.table"}, {"name": "", "type": "string array"}]}}, {"value": {"name": "CamlinternalOO.get_method_label", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/camlinternalOO.mli|1480"}, "info": "", "type": "CamlinternalOO.table -> string -> CamlinternalOO.label", "params": [{"name": "", "type": "CamlinternalOO.table"}, {"name": "", "type": "string"}]}}, {"value": {"name": "CamlinternalOO.get_method_labels", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/camlinternalOO.mli|1528"}, "info": "", "type": "CamlinternalOO.table -> string array -> CamlinternalOO.label array", "params": [{"name": "", "type": "CamlinternalOO.table"}, {"name": "", "type": "string array"}]}}, {"value": {"name": "CamlinternalOO.get_method", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/camlinternalOO.mli|1589"}, "info": "", "type": "CamlinternalOO.table -> CamlinternalOO.label -> CamlinternalOO.meth", "params": [{"name": "", "type": "CamlinternalOO.table"}, {"name": "", "type": "CamlinternalOO.label"}]}}, {"value": {"name": "CamlinternalOO.set_method", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/camlinternalOO.mli|1629"}, "info": "", "type": "CamlinternalOO.table -> CamlinternalOO.label -> CamlinternalOO.meth -> unit", "params": [{"name": "", "type": "CamlinternalOO.table"}, {"name": "", "type": "CamlinternalOO.label"}, {"name": "", "type": "CamlinternalOO.meth"}]}}, {"value": {"name": "CamlinternalOO.set_methods", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/camlinternalOO.mli|1677"}, "info": "", "type": "CamlinternalOO.table -> CamlinternalOO.label array -> unit", "params": [{"name": "", "type": "CamlinternalOO.table"}, {"name": "", "type": "CamlinternalOO.label array"}]}}, {"value": {"name": "CamlinternalOO.narrow", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/camlinternalOO.mli|1724"}, "info": "", "type": "CamlinternalOO.table -> string array -> string array -> string array -> unit", "params": [{"name": "", "type": "CamlinternalOO.table"}, {"name": "", "type": "string array"}, {"name": "", "type": "string array"}, {"name": "", "type": "string array"}]}}, {"value": {"name": "CamlinternalOO.widen", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/camlinternalOO.mli|1799"}, "info": "", "type": "CamlinternalOO.table -> unit", "params": [{"name": "", "type": "CamlinternalOO.table"}]}}, {"value": {"name": "CamlinternalOO.add_initializer", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/camlinternalOO.mli|1825"}, "info": "", "type": "CamlinternalOO.table -> (CamlinternalOO.obj -> unit) -> unit", "params": [{"name": "", "type": "CamlinternalOO.table"}, {"name": "", "type": "CamlinternalOO.obj -> unit"}]}}, {"value": {"name": "CamlinternalOO.dummy_table", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/camlinternalOO.mli|1878"}, "info": "", "type": "CamlinternalOO.table", "params": []}}, {"value": {"name": "CamlinternalOO.create_table", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/camlinternalOO.mli|1902"}, "info": "", "type": "string array -> CamlinternalOO.table", "params": [{"name": "", "type": "string array"}]}}, {"value": {"name": "CamlinternalOO.init_class", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/camlinternalOO.mli|1943"}, "info": "", "type": "CamlinternalOO.table -> unit", "params": [{"name": "", "type": "CamlinternalOO.table"}]}}, {"value": {"name": "CamlinternalOO.inherits", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/camlinternalOO.mli|1974"}, "info": "", "type": "CamlinternalOO.table ->\n  string array ->\n  string array ->\n  string array ->\n  CamlinternalOO.t * (CamlinternalOO.table -> CamlinternalOO.obj -> Obj.t) *\n  CamlinternalOO.t * CamlinternalOO.obj -> bool -> Obj.t array", "params": [{"name": "", "type": "CamlinternalOO.table"}, {"name": "", "type": "string array"}, {"name": "", "type": "string array"}, {"name": "", "type": "string array"}, {"tuple": {"type": "CamlinternalOO.t * (CamlinternalOO.table -> CamlinternalOO.obj -> Obj.t) *\n  CamlinternalOO.t * CamlinternalOO.obj", "contents": [{"name": "", "type": "CamlinternalOO.t"}, {"name": "", "type": "CamlinternalOO.table -> CamlinternalOO.obj -> Obj.t"}, {"name": "", "type": "CamlinternalOO.t"}, {"name": "", "type": "CamlinternalOO.obj"}]}}, {"name": "", "type": "bool"}]}}, {"value": {"name": "CamlinternalOO.make_class", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/camlinternalOO.mli|2117"}, "info": "", "type": "string array ->\n  (CamlinternalOO.table -> Obj.t -> CamlinternalOO.t) ->\n  CamlinternalOO.t * (CamlinternalOO.table -> Obj.t -> CamlinternalOO.t) *\n  (Obj.t -> CamlinternalOO.t) * Obj.t", "params": [{"name": "", "type": "string array"}, {"name": "", "type": "CamlinternalOO.table -> Obj.t -> CamlinternalOO.t"}]}}, {"type": {"name": "CamlinternalOO.init_table", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/camlinternalOO.mli|2239"}, "info": "", "params": [], "kind": {"type": "abstract"}}}, {"value": {"name": "CamlinternalOO.make_class_store", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/camlinternalOO.mli|2250"}, "info": "", "type": "string array ->\n  (CamlinternalOO.table -> CamlinternalOO.t) ->\n  CamlinternalOO.init_table -> unit", "params": [{"name": "", "type": "string array"}, {"name": "", "type": "CamlinternalOO.table -> CamlinternalOO.t"}, {"name": "", "type": "CamlinternalOO.init_table"}]}}, {"value": {"name": "CamlinternalOO.dummy_class", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/camlinternalOO.mli|2328"}, "info": "", "type": "string * int * int ->\n  CamlinternalOO.t * (CamlinternalOO.table -> Obj.t -> CamlinternalOO.t) *\n  (Obj.t -> CamlinternalOO.t) * Obj.t", "params": [{"tuple": {"type": "string * int * int", "contents": [{"name": "", "type": "string"}, {"name": "", "type": "int"}, {"name": "", "type": "int"}]}}]}}, {"comment": "<h6>Objects<\/h6>"}, {"value": {"name": "CamlinternalOO.copy", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/camlinternalOO.mli|2448"}, "info": "", "type": "(< .. > as 'a) -> 'a", "params": [{"name": "", "type": "< .. >"}]}}, {"value": {"name": "CamlinternalOO.create_object", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/camlinternalOO.mli|2480"}, "info": "", "type": "CamlinternalOO.table -> CamlinternalOO.obj", "params": [{"name": "", "type": "CamlinternalOO.table"}]}}, {"value": {"name": "CamlinternalOO.create_object_opt", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/camlinternalOO.mli|2513"}, "info": "", "type": "CamlinternalOO.obj -> CamlinternalOO.table -> CamlinternalOO.obj", "params": [{"name": "", "type": "CamlinternalOO.obj"}, {"name": "", "type": "CamlinternalOO.table"}]}}, {"value": {"name": "CamlinternalOO.run_initializers", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/camlinternalOO.mli|2557"}, "info": "", "type": "CamlinternalOO.obj -> CamlinternalOO.table -> unit", "params": [{"name": "", "type": "CamlinternalOO.obj"}, {"name": "", "type": "CamlinternalOO.table"}]}}, {"value": {"name": "CamlinternalOO.run_initializers_opt", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/camlinternalOO.mli|2601"}, "info": "", "type": "CamlinternalOO.obj ->\n  CamlinternalOO.obj -> CamlinternalOO.table -> CamlinternalOO.obj", "params": [{"name": "", "type": "CamlinternalOO.obj"}, {"name": "", "type": "CamlinternalOO.obj"}, {"name": "", "type": "CamlinternalOO.table"}]}}, {"value": {"name": "CamlinternalOO.create_object_and_run_initializers", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/camlinternalOO.mli|2655"}, "info": "", "type": "CamlinternalOO.obj -> CamlinternalOO.table -> CamlinternalOO.obj", "params": [{"name": "", "type": "CamlinternalOO.obj"}, {"name": "", "type": "CamlinternalOO.table"}]}}, {"value": {"name": "CamlinternalOO.send", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/camlinternalOO.mli|2716"}, "info": "", "type": "CamlinternalOO.obj -> CamlinternalOO.tag -> CamlinternalOO.t", "params": [{"name": "", "type": "CamlinternalOO.obj"}, {"name": "", "type": "CamlinternalOO.tag"}]}}, {"value": {"name": "CamlinternalOO.sendcache", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/camlinternalOO.mli|2758"}, "info": "", "type": "CamlinternalOO.obj ->\n  CamlinternalOO.tag -> CamlinternalOO.t -> int -> CamlinternalOO.t", "params": [{"name": "", "type": "CamlinternalOO.obj"}, {"name": "", "type": "CamlinternalOO.tag"}, {"name": "", "type": "CamlinternalOO.t"}, {"name": "", "type": "int"}]}}, {"value": {"name": "CamlinternalOO.sendself", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/camlinternalOO.mli|2822"}, "info": "", "type": "CamlinternalOO.obj -> CamlinternalOO.label -> CamlinternalOO.t", "params": [{"name": "", "type": "CamlinternalOO.obj"}, {"name": "", "type": "CamlinternalOO.label"}]}}, {"value": {"name": "CamlinternalOO.get_public_method", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/camlinternalOO.mli|2874"}, "info": "", "type": "CamlinternalOO.obj -> CamlinternalOO.tag -> CamlinternalOO.closure", "params": [{"name": "", "type": "CamlinternalOO.obj"}, {"name": "", "type": "CamlinternalOO.tag"}]}}, {"comment": "<h6>Table cache<\/h6>"}, {"type": {"name": "CamlinternalOO.tables", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/camlinternalOO.mli|2996"}, "info": "", "params": [], "kind": {"type": "abstract"}}}, {"value": {"name": "CamlinternalOO.lookup_tables", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/camlinternalOO.mli|3003"}, "info": "", "type": "CamlinternalOO.tables ->\n  CamlinternalOO.closure array -> CamlinternalOO.tables", "params": [{"name": "", "type": "CamlinternalOO.tables"}, {"name": "", "type": "CamlinternalOO.closure array"}]}}, {"comment": "<h6>Builtins to reduce code size<\/h6>"}, {"type": {"name": "CamlinternalOO.impl", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/camlinternalOO.mli|4229"}, "info": "", "params": [], "kind": {"type": "variant", "private": "false", "constructors": [{"name": "GetConst", "type": []}, {"name": "GetVar", "type": []}, {"name": "GetEnv", "type": []}, {"name": "GetMeth", "type": []}, {"name": "SetVar", "type": []}, {"name": "AppConst", "type": []}, {"name": "AppVar", "type": []}, {"name": "AppEnv", "type": []}, {"name": "AppMeth", "type": []}, {"name": "AppConstConst", "type": []}, {"name": "AppConstVar", "type": []}, {"name": "AppConstEnv", "type": []}, {"name": "AppConstMeth", "type": []}, {"name": "AppVarConst", "type": []}, {"name": "AppEnvConst", "type": []}, {"name": "AppMethConst", "type": []}, {"name": "MethAppConst", "type": []}, {"name": "MethAppVar", "type": []}, {"name": "MethAppEnv", "type": []}, {"name": "MethAppMeth", "type": []}, {"name": "SendConst", "type": []}, {"name": "SendVar", "type": []}, {"name": "SendEnv", "type": []}, {"name": "SendMeth", "type": []}, {"name": "Closure", "type": ["CamlinternalOO.closure"]}]}}}, {"comment": "<h6>Parameters<\/h6>"}, {"type": {"name": "CamlinternalOO.params", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/camlinternalOO.mli|4648"}, "info": "", "params": [], "kind": {"type": "record", "private": "false", "fields": [{"name": "compact_table", "mutable": true, "type": "bool"}, {"name": "copy_parent", "mutable": true, "type": "bool"}, {"name": "clean_when_copying", "mutable": true, "type": "bool"}, {"name": "retry_count", "mutable": true, "type": "int"}, {"name": "bucket_small_size", "mutable": true, "type": "int"}]}}}, {"value": {"name": "CamlinternalOO.params", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/camlinternalOO.mli|4832"}, "info": "", "type": "CamlinternalOO.params", "params": []}}, {"comment": "<h6>Statistics<\/h6>"}, {"type": {"name": "CamlinternalOO.stats", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/camlinternalOO.mli|4881"}, "info": "", "params": [], "kind": {"type": "record", "private": "false", "fields": [{"name": "classes", "mutable": false, "type": "int"}, {"name": "methods", "mutable": false, "type": "int"}, {"name": "inst_vars", "mutable": false, "type": "int"}]}}}, {"value": {"name": "CamlinternalOO.stats", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/camlinternalOO.mli|4949"}, "info": "", "type": "unit -> CamlinternalOO.stats", "params": [{"name": "", "type": "unit"}]}}], "dependencies": {"uses": ["Obj"], "used_by": ["Oo"]}}}, "CamlinternalMod": {"module": {"name": "CamlinternalMod", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/camlinternalMod.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/camlinternalMod.mli|0"}, "info": "", "type": "sig  end", "module_structure": [{"type": {"name": "CamlinternalMod.shape", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/camlinternalMod.mli|961"}, "info": "", "params": [], "kind": {"type": "variant", "private": "false", "constructors": [{"name": "Function", "type": []}, {"name": "Lazy", "type": []}, {"name": "Class", "type": []}, {"name": "Module", "type": ["CamlinternalMod.shape array"]}]}}}, {"value": {"name": "CamlinternalMod.init_mod", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/camlinternalMod.mli|1028"}, "info": "", "type": "string * int * int -> CamlinternalMod.shape -> Obj.t", "params": [{"tuple": {"type": "string * int * int", "contents": [{"name": "", "type": "string"}, {"name": "", "type": "int"}, {"name": "", "type": "int"}]}}, {"name": "", "type": "CamlinternalMod.shape"}]}}, {"value": {"name": "CamlinternalMod.update_mod", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/camlinternalMod.mli|1079"}, "info": "", "type": "CamlinternalMod.shape -> Obj.t -> Obj.t -> unit", "params": [{"name": "", "type": "CamlinternalMod.shape"}, {"name": "", "type": "Obj.t"}, {"name": "", "type": "Obj.t"}]}}], "dependencies": {"uses": ["Obj"], "used_by": []}}}, "Std_exit": {"module": {"name": "Std_exit", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/std_exit.ml", "location": {"implementation": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/std_exit.ml|0", "interface": "unknown"}, "info": "", "type": "sig  end", "module_structure": [], "dependencies": {"uses": [], "used_by": []}}}, "Log": {"module": {"name": "Log", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/log.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/log.mli|0"}, "info": {"description": "<h2>Loggers<\/h2>"}, "type": "sig  end", "module_structure": [{"type": {"name": "Log.level", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/log.mli|657"}, "info": {"description": "The level for log event"}, "params": [], "kind": {"type": "abstract"}, "manifest": "[ `debug | `error | `info | `warn ]"}}, {"type": {"name": "Log.logger", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/log.mli|739"}, "info": {"description": "Logger arguments"}, "params": [], "kind": {"type": "abstract"}, "manifest": "date:string ->\n  id:int ->\n  level:Log.level ->\n  section:string -> ?backtrace:string -> message:string -> unit"}}, {"value": {"name": "Log.add_logger", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/log.mli|977"}, "info": {"description": "Add a named logger, which will be called on each new log event"}, "type": "string -> Log.logger -> unit", "params": [{"name": "", "type": "string"}, {"name": "", "type": "Log.logger"}]}}, {"value": {"name": "Log.rm_logger", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/log.mli|1049"}, "info": {"description": "Remove a named logger"}, "type": "string -> unit", "params": [{"name": "", "type": "string"}]}}, {"value": {"name": "Log.get_loggers", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/log.mli|1115"}, "info": {"description": "Get all the active loggers"}, "type": "unit -> string list", "params": [{"name": "", "type": "unit"}]}}, {"value": {"name": "Log.text_logger", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/log.mli|1211"}, "info": {"description": "Default logger : display all the result to stdout"}, "type": "Log.logger", "params": []}}, {"value": {"name": "Log.text_logger_name", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/log.mli|1315"}, "info": {"description": "Name of the default text logger (usefull if one wants to uninstall it)"}, "type": "string", "params": []}}, {"comment": "<h2>Log functions<\/h2>"}, {"value": {"name": "Log.debug", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/log.mli|1372"}, "info": "", "type": "string -> ('a, unit, string, unit) Pervasives.format4 -> 'a", "params": [{"name": "", "type": "string"}, {"name": "", "type": "('a, unit, string, unit) Pervasives.format4"}]}}, {"value": {"name": "Log.info", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/log.mli|1432"}, "info": "", "type": "string -> ('a, unit, string, unit) Pervasives.format4 -> 'a", "params": [{"name": "", "type": "string"}, {"name": "", "type": "('a, unit, string, unit) Pervasives.format4"}]}}, {"value": {"name": "Log.warn", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/log.mli|1492"}, "info": "", "type": "string -> ('a, unit, string, unit) Pervasives.format4 -> 'a", "params": [{"name": "", "type": "string"}, {"name": "", "type": "('a, unit, string, unit) Pervasives.format4"}]}}, {"value": {"name": "Log.error", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/log.mli|1552"}, "info": "", "type": "string -> ('a, unit, string, unit) Pervasives.format4 -> 'a", "params": [{"name": "", "type": "string"}, {"name": "", "type": "('a, unit, string, unit) Pervasives.format4"}]}}, {"comment": "<h2>Date functions<\/h2>"}, {"value": {"name": "Log.set_date", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/log.mli|1695"}, "info": {"description": "Hook to get the date (OS modules might init it)"}, "type": "(unit -> string) -> unit", "params": [{"name": "", "type": "unit -> string"}]}}, {"value": {"name": "Log.set_id", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/log.mli|1779"}, "info": {"description": "Hook to get the current thread's id"}, "type": "(unit -> int) -> unit", "params": [{"name": "", "type": "unit -> int"}]}}], "dependencies": {"uses": ["*predef*"], "used_by": []}}}, "Oo": {"module": {"name": "Oo", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/oo.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/oo.mli|0"}, "info": {"description": "Operations on objects"}, "type": "sig  end", "module_structure": [{"value": {"name": "Oo.copy", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/oo.mli|975"}, "info": {"description": "<span class=\"code\" >Oo.copy o<\/span> returns a copy of object <span class=\"code\" >o<\/span>, that is a fresh object with the same methods and instance variables as <span class=\"code\" >o<\/span>"}, "type": "(< .. > as 'a) -> 'a", "params": [{"name": "", "type": "< .. >"}]}}, {"value": {"name": "Oo.id", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/oo.mli|1136"}, "info": {"description": "Return an integer identifying this object, unique for the current execution of the program."}, "type": "< .. > -> int", "params": [{"name": "", "type": "< .. >"}]}}], "dependencies": {"uses": ["CamlinternalOO"], "used_by": []}}}, "Bitstring": {"module": {"name": "Bitstring", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/bitstring.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/bitstring.mli|0"}, "info": {"description": "Bitstring library."}, "type": "sig  end", "module_structure": [{"comment": "<a href=\"#reference\" >Jump straight to the reference section for documentation on types and functions<\/a>.<br><\/br> <h2>Introduction<\/h2><br><\/br> Bitstring adds Erlang-style bitstrings and matching over bitstrings as a syntax extension and library for OCaml.  You can use this module to both parse and generate binary formats, for example, communications protocols, disk formats and binary files.<br><\/br> <a href=\"http:\/\/code.google.com\/p\/bitstring\/\" >OCaml bitstring website<\/a><br><\/br> This library used to be called \"bitmatch\".<br><\/br> <h2>Examples<\/h2><br><\/br> A function which can parse IPv4 packets:<br><\/br> <span class=\"codepre\" > let display pkt = bitmatch pkt with (* IPv4 packet header 0                   1                   2                   3    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |   4   |  IHL  |Type of Service|          Total Length         | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |         Identification        |Flags|      Fragment Offset    | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |  Time to Live |    Protocol   |         Header Checksum       | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |                       Source Address                          | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |                    Destination Address                        | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |                    Options                    |    Padding    | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ ) | { 4 : 4; hdrlen : 4; tos : 8;   length : 16; identification : 16;          flags : 3; fragoffset : 13; ttl : 8; protocol : 8;        checksum : 16; source : 32; dest : 32; options : (hdrlen-5)*32 : bitstring; payload : -1 : bitstring } -&gt; printf \"IPv4:\\n\"; printf \"  header length: %d * 32 bit words\\n\" hdrlen; printf \"  type of service: %d\\n\" tos; printf \"  packet length: %d bytes\\n\" length; printf \"  identification: %d\\n\" identification; printf \"  flags: %d\\n\" flags; printf \"  fragment offset: %d\\n\" fragoffset; printf \"  ttl: %d\\n\" ttl; printf \"  protocol: %d\\n\" protocol; printf \"  checksum: %d\\n\" checksum; printf \"  source: %lx  dest: %lx\\n\" source dest; printf \"  header options + padding:\\n\"; Bitstring.hexdump_bitstring stdout options; printf \"  packet payload:\\n\"; Bitstring.hexdump_bitstring stdout payload | { version : 4 } -&gt; eprintf \"unknown IP version %d\\n\" version; exit 1 | { _ } as pkt -&gt; eprintf \"data is smaller than one nibble:\\n\"; Bitstring.hexdump_bitstring stderr pkt; exit 1 <\/span><br><\/br> A program which can parse <a href=\"http:\/\/lxr.linux.no\/linux\/include\/linux\/ext3_fs.h\" >Linux EXT3 filesystem superblocks<\/a>:<br><\/br> <span class=\"codepre\" > let bits = Bitstring.bitstring_of_file \"tests\/ext3_sb\" let () = bitmatch bits with | { s_inodes_count : 32 : littleendian;       (* Inodes count *) s_blocks_count : 32 : littleendian;       (* Blocks count *) s_r_blocks_count : 32 : littleendian;     (* Reserved blocks count *) s_free_blocks_count : 32 : littleendian;  (* Free blocks count *) s_free_inodes_count : 32 : littleendian;  (* Free inodes count *) s_first_data_block : 32 : littleendian;   (* First Data Block *) s_log_block_size : 32 : littleendian;     (* Block size *) s_log_frag_size : 32 : littleendian;      (* Fragment size *) s_blocks_per_group : 32 : littleendian;   (* # Blocks per group *) s_frags_per_group : 32 : littleendian;    (* # Fragments per group *) s_inodes_per_group : 32 : littleendian;   (* # Inodes per group *) s_mtime : 32 : littleendian;              (* Mount time *) s_wtime : 32 : littleendian;              (* Write time *) s_mnt_count : 16 : littleendian;          (* Mount count *) s_max_mnt_count : 16 : littleendian;      (* Maximal mount count *) 0xef53 : 16 : littleendian } -&gt;           (* Magic signature *) printf \"ext3 superblock:\\n\"; printf \"  s_inodes_count = %ld\\n\" s_inodes_count; printf \"  s_blocks_count = %ld\\n\" s_blocks_count; printf \"  s_free_inodes_count = %ld\\n\" s_free_inodes_count; printf \"  s_free_blocks_count = %ld\\n\" s_free_blocks_count | { _ } -&gt; eprintf \"not an ext3 superblock!\\n%!\"; exit 2 <\/span><br><\/br> Constructing packets for a simple binary message protocol:<br><\/br> <span class=\"codepre\" > (* +---------------+---------------+--------------------------+ | type          | subtype       | parameter                | +---------------+---------------+--------------------------+ &lt;-- 16 bits --&gt; &lt;-- 16 bits --&gt; &lt;------- 32 bits --------&gt; All fields are in network byte order. ) let make_message typ subtype param = (BITSTRING { typ : 16; subtype : 16; param : 32 }) ;; <\/span><br><\/br> <h2>Loading, creating bitstrings<\/h2><br><\/br> The basic data type is the <a href=\"{type|Bitstring.bitstring}\" ><span class=\"code\" >Bitstring.bitstring<\/span><\/a>, a string of bits of arbitrary length.  Bitstrings can be any length in bits and operations do not need to be byte-aligned (although they will generally be more efficient if they are byte-aligned).<br><\/br> Internally a bitstring is stored as a normal OCaml <span class=\"code\" >string<\/span> together with an offset and length, where the offset and length are measured in bits.  Thus one can efficiently form substrings of bitstrings, overlay a bitstring on existing data, and load and save bitstrings from files or other external sources.<br><\/br> To load a bitstring from a file use <a href=\"{none|bitstring_of_file}\" ><span class=\"code\" >bitstring_of_file<\/span><\/a> or <a href=\"{value|Bitstring.bitstring_of_chan}\" ><span class=\"code\" >Bitstring.bitstring_of_chan<\/span><\/a>.<br><\/br> There are also functions to create bitstrings from arbitrary data. See the <a href=\"#reference\" >reference<\/a> below.<br><\/br> <h2>Matching bitstrings with patterns<\/h2><br><\/br> Use the <span class=\"code\" >bitmatch<\/span> operator (part of the syntax extension) to break apart a bitstring into its fields.  <span class=\"code\" >bitmatch<\/span> works a lot like the OCaml <span class=\"code\" >match<\/span> operator.<br><\/br> The general form of <span class=\"code\" >bitmatch<\/span> is:<br><\/br> <span class=\"code\" >bitmatch<\/span> <i>bitstring-expression<\/i> <span class=\"code\" >with<\/span><br><\/br> <span class=\"code\" >| {<\/span> <i>pattern<\/i> <span class=\"code\" >} -&gt;<\/span> <i>code<\/i><br><\/br> <span class=\"code\" >| {<\/span> <i>pattern<\/i> <span class=\"code\" >} -&gt;<\/span> <i>code<\/i><br><\/br> <span class=\"code\" >|<\/span> ...<br><\/br> As with normal match, the statement attempts to match the bitstring against each pattern in turn.  If none of the patterns match then the standard library <span class=\"code\" >Match_failure<\/span> exception is thrown.<br><\/br> Patterns look a bit different from normal match patterns.  They consist of a list of bitfields separated by <span class=\"code\" >;<\/span> where each bitfield contains a bind variable, the width (in bits) of the field, and other information.  Some example patterns:<br><\/br> <span class=\"codepre\" > bitmatch bits with | { version : 8; name : 8; param : 8 } -&gt; ... (* Bitstring of at least 3 bytes.  First byte is the version number, second byte is a field called name, third byte is a field called parameter. *) | { flag : 1 } -&gt; printf \"flag is %b\\n\" flag (* A single flag bit (mapped into an OCaml boolean). *) | { len : 4; data : 1+len } -&gt; printf \"len = %d, data = 0x%Lx\\n\" len data (* A 4-bit length, followed by 1-16 bits of data, where the length of the data is computed from len. *) | { ipv6_source : 128 : bitstring; ipv6_dest : 128 : bitstring } -&gt; ... (* IPv6 source and destination addresses.  Each is 128 bits and is mapped into a bitstring type which will be a substring of the main bitstring expression. *) <\/span><br><\/br> You can also add conditional when-clauses:<br><\/br> <span class=\"codepre\" > | { version : 4 } when version = 4 || version = 6 -&gt; ... (* Only match and run the code when version is 4 or 6.  If it isn't we will drop through to the next case. *) <\/span><br><\/br> Note that the pattern is only compared against the first part of the bitstring (there may be more data in the bitstring following the pattern, which is not matched).  In terms of regular expressions you might say that the pattern matches <span class=\"code\" >^pattern<\/span>, not <span class=\"code\" >^pattern$<\/span>.  To ensure that the bitstring contains only the pattern, add a length -1 bitstring to the end and test that its length is zero in the when-clause:<br><\/br> <span class=\"codepre\" > | { n : 4; rest : -1 : bitstring } when Bitstring.bitstring_length rest = 0 -&gt; ... (* Only matches exactly 4 bits. *) <\/span><br><\/br> Normally the first part of each field is a binding variable, but you can also match a constant, as in:<br><\/br> <span class=\"codepre\" > | { (4|6) : 4 } -&gt; ... (* Only matches if the first 4 bits contain either the integer 4 or the integer 6. *) <\/span><br><\/br> One may also match on strings:<br><\/br> <span class=\"codepre\" > | { \"MAGIC\" : 5*8 : string } -&gt; ... (* Only matches if the string \"MAGIC\" appears at the start of the input. *) <\/span><br><\/br> <h3>Pattern field reference<\/h3><br><\/br> The exact format of each pattern field is:<br><\/br> <span class=\"code\" >pattern : length [: qualifier [,qualifier ...]]<\/span><br><\/br> <span class=\"code\" >pattern<\/span> is the pattern, binding variable name, or constant to match.  <span class=\"code\" >length<\/span> is the length in bits which may be either a constant or an expression.  The length expression is just an OCaml expression and can use any values defined in the program, and refer back to earlier fields (but not to later fields).<br><\/br> Integers can only have lengths in the range [1..64] bits.  See the <a href=\"#integertypes\" >integer types<\/a> section below for how these are mapped to the OCaml int\/int32\/int64 types.  This is checked at compile time if the length expression is constant, otherwise it is checked at runtime and you will get a runtime exception eg. in the case of a computed length expression.<br><\/br> A bitstring field of length -1 matches all the rest of the bitstring (thus this is only useful as the last field in a pattern).<br><\/br> A bitstring field of length 0 matches an empty bitstring (occasionally useful when matching optional subfields).<br><\/br> Qualifiers are a list of identifiers\/expressions which control the type, signedness and endianness of the field.  Permissible qualifiers are:<br><\/br><ul><li><span class=\"code\" >int<\/span>: field has an integer type<\/li><li><span class=\"code\" >string<\/span>: field is a string type<\/li><li><span class=\"code\" >bitstring<\/span>: field is a bitstring type<\/li><li><span class=\"code\" >signed<\/span>: field is signed<\/li><li><span class=\"code\" >unsigned<\/span>: field is unsigned<\/li><li><span class=\"code\" >bigendian<\/span>: field is big endian - a.k.a network byte order<\/li><li><span class=\"code\" >littleendian<\/span>: field is little endian - a.k.a Intel byte order<\/li><li><span class=\"code\" >nativeendian<\/span>: field is same endianness as the machine<\/li><li><span class=\"code\" >endian (expr)<\/span>: <span class=\"code\" >expr<\/span> should be an expression which evaluates to a <a href=\"{type|Bitstring.endian}\" ><span class=\"code\" >Bitstring.endian<\/span><\/a> type, ie. <span class=\"code\" >LittleEndian<\/span>, <span class=\"code\" >BigEndian<\/span> or <span class=\"code\" >NativeEndian<\/span>. The expression is an arbitrary OCaml expression and can use the value of earlier fields in the bitmatch.<\/li><li><span class=\"code\" >offset (expr)<\/span>: see <a href=\"#computedoffsets\" >computed offsets<\/a> below.<\/li><\/ul> The default settings are <span class=\"code\" >int<\/span>, <span class=\"code\" >unsigned<\/span>, <span class=\"code\" >bigendian<\/span>, no offset.<br><\/br> Note that many of these qualifiers cannot be used together, eg. bitstrings do not have endianness.  The syntax extension should give you a compile-time error if you use incompatible qualifiers.<br><\/br> <h3>Other cases in bitmatch<\/h3><br><\/br> As well as a list of fields, it is possible to name the bitstring and\/or have a default match case:<br><\/br> <span class=\"codepre\" > | { _ } -&gt; ... (* Default match case. *) | { _ } as pkt -&gt; ... (* Default match case, with 'pkt' bound to the whole bitstring. *) <\/span><br><\/br> <h2>Constructing bitstrings<\/h2><br><\/br> Bitstrings may be constructed using the <span class=\"code\" >BITSTRING<\/span> operator (as an expression).  The <span class=\"code\" >BITSTRING<\/span> operator takes a list of fields, similar to the list of fields for matching:<br><\/br> <span class=\"codepre\" > let version = 1 ;; let data = 10 ;; let bits = BITSTRING { version : 4; data : 12 } ;; (* Constructs a 16-bit bitstring with the first four bits containing the integer 1, and the following 12 bits containing the integer 10, arranged in network byte order. *) Bitstring.hexdump_bitstring stdout bits ;; (* Prints: 00000000  10 0a         |..              | ) <\/span><br><\/br> The format of each field is the same as for pattern fields (see <a href=\"#patternfieldreference\" >Pattern field reference section<\/a>), and things like computed length fields, fixed value fields, insertion of bitstrings within bitstrings, etc. are all supported.<br><\/br> <h3>Construction exception<\/h3><br><\/br> The <span class=\"code\" >BITSTRING<\/span> operator may throw a <a href=\"{exception|Bitstring.Construct_failure}\" ><span class=\"code\" >Bitstring.Construct_failure<\/span><\/a> exception at runtime.<br><\/br> Runtime errors include:<br><\/br><ul><li>int field length not in the range [1..64]<\/li><li>a bitstring with a length declared which doesn't have the same length at runtime<\/li><li>trying to insert an out of range value into an int field (eg. an unsigned int field which is 2 bits wide can only take values in the range [0..3]).<\/li><\/ul> <h2>Integer types<\/h2><br><\/br> Integer types are mapped to OCaml types <span class=\"code\" >bool<\/span>, <span class=\"code\" >int<\/span>, <span class=\"code\" >int32<\/span> or <span class=\"code\" >int64<\/span> using a system which tries to ensure that (a) the types are reasonably predictable and (b) the most efficient type is preferred.<br><\/br> The rules are slightly different depending on whether the bit length expression in the field is a compile-time constant or a computed expression.<br><\/br> Detection of compile-time constants is quite simplistic so only simple integer literals and simple expressions (eg. <span class=\"code\" >5*8<\/span>) are recognized as constants.<br><\/br> In any case the bit size of an integer is limited to the range [1..64].  This is detected as a compile-time error if that is possible, otherwise a runtime check is added which can throw an <span class=\"code\" >Invalid_argument<\/span> exception.<br><\/br> The mapping is thus:<br><\/br> <span class=\"verbatim\" >   Bit size\t    ---- OCaml type ---- Constant\tComputed expression 1\t\tbool\t\tint64 2..31\tint\t\tint64 32\t\tint32\t\tint64 33..64\tint64\t\tint64 <\/span><br><\/br> A possible future extension may allow people with 64 bit computers to specify a more optimal <span class=\"code\" >int<\/span> type for bit sizes in the range <span class=\"code\" >32..63<\/span>.  If this was implemented then such code <i>could not even be compiled<\/i> on 32 bit platforms, so it would limit portability.<br><\/br> Another future extension may be to allow computed expressions to assert min\/max range for the bit size, allowing a more efficient data type than int64 to be used.  (Of course under such circumstances there would still need to be a runtime check to enforce the size).<br><\/br> <h2>Advanced pattern-matching features<\/h2><br><\/br> <h3>Computed offsets<\/h3><br><\/br> You can add an <span class=\"code\" >offset(..)<\/span> qualifier to bitmatch patterns in order to move the current offset within the bitstring forwards.<br><\/br> For example:<br><\/br> <span class=\"codepre\" > bitmatch bits with | { field1 : 8; field2 : 8 : offset(160) } -&gt; ... <\/span><br><\/br> matches <span class=\"code\" >field1<\/span> at the start of the bitstring and <span class=\"code\" >field2<\/span> at 160 bits into the bitstring.  The middle 152 bits go unmatched (ie. can be anything).<br><\/br> The generated code is efficient.  If field lengths and offsets are known to be constant at compile time, then almost all runtime checks are avoided.  Non-constant field lengths and\/or non-constant offsets can result in more runtime checks being added.<br><\/br> Note that moving the offset backwards, and moving the offset in <span class=\"code\" >BITSTRING<\/span> constructors, are both not supported at present.<br><\/br> <h3>Check expressions<\/h3><br><\/br> You can add a <span class=\"code\" >check(expr)<\/span> qualifier to bitmatch patterns. If the expression evaluates to false then the current match case fails to match (in other words, we fall through to the next match case - there is no error).<br><\/br> For example: <span class=\"codepre\" > bitmatch bits with | { field : 16 : check (field &gt; 100) } -&gt; ... <\/span><br><\/br> Note the difference between a check expression and a when-clause is that the when-clause is evaluated after all the fields have been matched.  On the other hand a check expression is evaluated after the individual field has been matched, which means it is potentially more efficient (if the check expression fails then we don't waste any time matching later fields).<br><\/br> We wanted to use the notation <span class=\"code\" >when(expr)<\/span> here, but because <span class=\"code\" >when<\/span> is a reserved word we could not do this.<br><\/br> <h3>Bind expressions<\/h3><br><\/br> A bind expression is used to change the value of a matched field.  For example: <span class=\"codepre\" > bitmatch bits with | { len : 16 : bind (len * 8); field : len : bitstring } -&gt; ... <\/span><br><\/br> In the example, after 'len' has been matched, its value would be multiplied by 8, so the width of 'field' is the matched value multiplied by 8.<br><\/br> In the general case: <span class=\"codepre\" > | { field : ... : bind (expr) } -&gt; ... <\/span> evaluates the following after the field has been matched: <span class=\"codepre\" > let field = expr in (* remaining fields *) <\/span><br><\/br> <h3>Order of evaluation of check() and bind()<\/h3><br><\/br> The choice is arbitrary, but we have chosen that check expressions are evaluated first, and bind expressions are evaluated after.<br><\/br> This means that the result of bind() is <i>not<\/i> available in the check expression.<br><\/br> Note that this rule applies regardless of the order of check() and bind() in the source code.<br><\/br> <h3>save_offset_to<\/h3><br><\/br> Use <span class=\"code\" >save_offset_to(variable)<\/span> to save the current bit offset within the match to a variable (strictly speaking, to a pattern). This variable is then made available in any <span class=\"code\" >check()<\/span> and <span class=\"code\" >bind()<\/span> clauses in the current field, <i>and<\/i> to any later fields, and to the code after the <span class=\"code\" >-&gt;<\/span>.<br><\/br> For example: <span class=\"codepre\" > bitmatch bits with | { len : 16; _ : len : bitstring; field : 16 : save_offset_to (field_offset) } -&gt; printf \"field is at bit offset %d in the match\\n\" field_offset <\/span><br><\/br> (In that example, <span class=\"code\" >field_offset<\/span> should always have the value <span class=\"code\" >len+16<\/span>).<br><\/br> <h2>Named patterns and persistent patterns<\/h2><br><\/br> Please see <a href=\"{none|Bitstring_persistent}\" ><span class=\"code\" >Bitstring_persistent<\/span><\/a> for documentation on this subject.<br><\/br> <h2>Compiling<\/h2><br><\/br> Using the compiler directly you can do:<br><\/br> <span class=\"verbatim\" >   ocamlc -I +bitstring \\ -pp \"camlp4of bitstring.cma bitstring_persistent.cma \\ `ocamlc -where`\/bitstring\/pa_bitstring.cmo\" \\ unix.cma bitstring.cma test.ml -o test <\/span><br><\/br> Simpler method using findlib:<br><\/br> <span class=\"verbatim\" >   ocamlfind ocamlc \\ -package bitstring,bitstring.syntax -syntax bitstring.syntax \\ -linkpkg test.ml -o test <\/span><br><\/br> <h2>Security and type safety<\/h2><br><\/br> <h3>Security on input<\/h3><br><\/br> The main concerns for input are buffer overflows and denial of service.<br><\/br> It is believed that this library is robust against attempted buffer overflows.  In addition to OCaml's normal bounds checks, we check that field lengths are &gt;= 0, and many additional checks.<br><\/br> Denial of service attacks are more problematic.  We only work forwards through the bitstring, thus computation will eventually terminate.  As for computed lengths, code such as this is thought to be secure:<br><\/br> <span class=\"codepre\" > bitmatch bits with | { len : 64; buffer : Int64.to_int len : bitstring } -&gt; <\/span><br><\/br> The <span class=\"code\" >len<\/span> field can be set arbitrarily large by an attacker, but when pattern-matching against the <span class=\"code\" >buffer<\/span> field this merely causes a test such as <span class=\"code\" >if len &lt;= remaining_size<\/span> to fail.  Even if the length is chosen so that <span class=\"code\" >buffer<\/span> bitstring is allocated, the allocation of sub-bitstrings is efficient and doesn't involve an arbitary-sized allocation or any copying.<br><\/br> However the above does not necessarily apply to strings used in matching, since they may cause the library to use the <a href=\"{value|Bitstring.string_of_bitstring}\" ><span class=\"code\" >Bitstring.string_of_bitstring<\/span><\/a> function, which allocates a string. So you should take care if you use the <span class=\"code\" >string<\/span> type particularly with a computed length that is derived from external input.<br><\/br> The main protection against attackers should be to ensure that the main program will only read input bitstrings up to a certain length, which is outside the scope of this library.<br><\/br> <h3>Security on output<\/h3><br><\/br> As with the input side, computed lengths are believed to be safe.  For example:<br><\/br> <span class=\"codepre\" > let len = read_untrusted_source () in let buffer = allocate_bitstring () in BITSTRING { buffer : len : bitstring } <\/span><br><\/br> This code merely causes a check that buffer's length is the same as <span class=\"code\" >len<\/span>.  However the program function <span class=\"code\" >allocate_bitstring<\/span> must refuse to allocate an oversized buffer (but that is outside the scope of this library).<br><\/br> <h3>Order of evaluation<\/h3><br><\/br> In <span class=\"code\" >bitmatch<\/span> statements, fields are evaluated left to right.<br><\/br> Note that the when-clause is evaluated <i>last<\/i>, so if you are relying on the when-clause to filter cases then your code may do a lot of extra and unncessary pattern-matching work on fields which may never be needed just to evaluate the when-clause.  Either rearrange the code to do only the first part of the match, followed by the when-clause, followed by a second inner bitmatch, or use a <span class=\"code\" >check()<\/span> qualifier within fields.<br><\/br> <h3>Safety<\/h3><br><\/br> The current implementation is believed to be fully type-safe, and makes compile and run-time checks where appropriate.  If you find a case where a check is missing please submit a bug report or a patch.<br><\/br> <h2>Limits<\/h2><br><\/br> These are thought to be the current limits:<br><\/br> Integers: [1..64] bits.<br><\/br> Bitstrings (32 bit platforms): maximum length is limited by the string size, ie. 16 MBytes.<br><\/br> Bitstrings (64 bit platforms): maximum length is thought to be limited by the string size, ie. effectively unlimited.<br><\/br> Bitstrings must be loaded into memory before we can match against them.  Thus available memory may be considered a limit for some applications.<br><\/br> <h2>Reference<\/h2> <h3>Types<\/h3>"}, {"type": {"name": "Bitstring.endian", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/bitstring.mli|22192"}, "info": "", "params": [], "kind": {"type": "variant", "private": "false", "constructors": [{"name": "BigEndian", "type": []}, {"name": "LittleEndian", "type": []}, {"name": "NativeEndian", "type": []}]}}}, {"value": {"name": "Bitstring.string_of_endian", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/bitstring.mli|22242"}, "info": {"description": "Endianness."}, "type": "Bitstring.endian -> string", "params": [{"name": "", "type": "Bitstring.endian"}]}}, {"type": {"name": "Bitstring.bitstring", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/bitstring.mli|22307"}, "info": {"description": "<span class=\"code\" >bitstring<\/span> is the basic type used to store bitstrings.<br><\/br> The type contains the underlying data (a string), the current bit offset within the string and the current bit length of the string (counting from the bit offset).  Note that the offset and length are in <b>bits<\/b>, not bytes.<br><\/br> Normally you don't need to use the bitstring type directly, since there are functions and syntax extensions which hide the details.<br><\/br> See also <a href=\"{value|Bitstring.bitstring_of_string}\" ><span class=\"code\" >Bitstring.bitstring_of_string<\/span><\/a>, <a href=\"{none|bitstring_of_file}\" ><span class=\"code\" >bitstring_of_file<\/span><\/a>, <a href=\"{value|Bitstring.hexdump_bitstring}\" ><span class=\"code\" >Bitstring.hexdump_bitstring<\/span><\/a>, <a href=\"{value|Bitstring.bitstring_length}\" ><span class=\"code\" >Bitstring.bitstring_length<\/span><\/a>."}, "params": [], "kind": {"type": "abstract"}, "manifest": "string * int * int"}}, {"type": {"name": "Bitstring.t", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/bitstring.mli|22905"}, "info": {"description": "<span class=\"code\" >t<\/span> is a synonym for the <a href=\"{type|Bitstring.bitstring}\" ><span class=\"code\" >Bitstring.bitstring<\/span><\/a> type.<br><\/br> This allows you to use this module with functors like <span class=\"code\" >Set<\/span> and <span class=\"code\" >Map<\/span> from the stdlib."}, "params": [], "kind": {"type": "abstract"}, "manifest": "Bitstring.bitstring"}}, {"comment": "<h3>Exceptions<\/h3>"}, {"exception": {"name": "Bitstring.Construct_failure", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/bitstring.mli|23090"}, "info": {"description": "<span class=\"code\" >Construct_failure (message, file, line, char)<\/span> may be raised by the <span class=\"code\" >BITSTRING<\/span> constructor.<br><\/br> Common reasons are that values are out of range of the fields that contain them, or that computed lengths are impossible (eg. negative length bitfields).<br><\/br> <span class=\"code\" >message<\/span> is the error message.<br><\/br> <span class=\"code\" >file<\/span>, <span class=\"code\" >line<\/span> and <span class=\"code\" >char<\/span> point to the original source location of the <span class=\"code\" >BITSTRING<\/span> constructor that failed."}, "exception_args": ["string", "string", "int", "int"]}}, {"comment": "<h3>Bitstring comparison<\/h3>"}, {"value": {"name": "Bitstring.compare", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/bitstring.mli|23609"}, "info": {"description": "<span class=\"code\" >compare bs1 bs2<\/span> compares two bitstrings and returns zero if they are equal, a negative number if <span class=\"code\" >bs1 &lt; bs2<\/span>, or a positive number if <span class=\"code\" >bs1 &gt; bs2<\/span>.<br><\/br> This tests \"semantic equality\" which is not affected by the offset or alignment of the underlying representation (see <a href=\"{type|Bitstring.bitstring}\" ><span class=\"code\" >Bitstring.bitstring<\/span><\/a>).<br><\/br> The ordering is total and lexicographic."}, "type": "Bitstring.bitstring -> Bitstring.bitstring -> int", "params": [{"name": "", "type": "Bitstring.bitstring"}, {"name": "", "type": "Bitstring.bitstring"}]}}, {"value": {"name": "Bitstring.equals", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/bitstring.mli|24010"}, "info": {"description": "<span class=\"code\" >equals<\/span> returns true if and only if the two bitstrings are semantically equal.  It is the same as calling <span class=\"code\" >compare<\/span> and testing if the result is <span class=\"code\" >0<\/span>, but usually more efficient."}, "type": "Bitstring.bitstring -> Bitstring.bitstring -> bool", "params": [{"name": "", "type": "Bitstring.bitstring"}, {"name": "", "type": "Bitstring.bitstring"}]}}, {"comment": "<h3>Bitstring manipulation<\/h3>"}, {"value": {"name": "Bitstring.bitstring_length", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/bitstring.mli|24284"}, "info": {"description": "<span class=\"code\" >bitstring_length bitstring<\/span> returns the length of the bitstring in bits.<br><\/br> Note this just returns the third field in the <a href=\"{type|Bitstring.bitstring}\" ><span class=\"code\" >Bitstring.bitstring<\/span><\/a> tuple."}, "type": "Bitstring.bitstring -> int", "params": [{"name": "", "type": "Bitstring.bitstring"}]}}, {"value": {"name": "Bitstring.subbitstring", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/bitstring.mli|24481"}, "info": {"description": "<span class=\"code\" >subbitstring bits off len<\/span> returns a sub-bitstring of the bitstring, starting at offset <span class=\"code\" >off<\/span> bits and with length <span class=\"code\" >len<\/span> bits.<br><\/br> If the original bitstring is not long enough to do this then the function raises <span class=\"code\" >Invalid_argument \"subbitstring\"<\/span>.<br><\/br> Note that this function just changes the offset and length fields of the <a href=\"{type|Bitstring.bitstring}\" ><span class=\"code\" >Bitstring.bitstring<\/span><\/a> tuple, so is very efficient."}, "type": "Bitstring.bitstring -> int -> int -> Bitstring.bitstring", "params": [{"name": "", "type": "Bitstring.bitstring"}, {"name": "", "type": "int"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Bitstring.dropbits", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/bitstring.mli|24930"}, "info": {"description": "Drop the first n bits of the bitstring and return a new bitstring which is shorter by n bits.<br><\/br> If the length of the original bitstring is less than n bits, this raises <span class=\"code\" >Invalid_argument \"dropbits\"<\/span>.<br><\/br> Note that this function just changes the offset and length fields of the <a href=\"{type|Bitstring.bitstring}\" ><span class=\"code\" >Bitstring.bitstring<\/span><\/a> tuple, so is very efficient."}, "type": "int -> Bitstring.bitstring -> Bitstring.bitstring", "params": [{"name": "", "type": "int"}, {"name": "", "type": "Bitstring.bitstring"}]}}, {"value": {"name": "Bitstring.takebits", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/bitstring.mli|25318"}, "info": {"description": "Take the first n bits of the bitstring and return a new bitstring which is exactly n bits long.<br><\/br> If the length of the original bitstring is less than n bits, this raises <span class=\"code\" >Invalid_argument \"takebits\"<\/span>.<br><\/br> Note that this function just changes the offset and length fields of the <a href=\"{type|Bitstring.bitstring}\" ><span class=\"code\" >Bitstring.bitstring<\/span><\/a> tuple, so is very efficient."}, "type": "int -> Bitstring.bitstring -> Bitstring.bitstring", "params": [{"name": "", "type": "int"}, {"name": "", "type": "Bitstring.bitstring"}]}}, {"value": {"name": "Bitstring.concat", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/bitstring.mli|25708"}, "info": {"description": "Concatenate a list of bitstrings together into a single bitstring."}, "type": "Bitstring.bitstring list -> Bitstring.bitstring", "params": [{"name": "", "type": "Bitstring.bitstring list"}]}}, {"comment": "<h3>Constructing bitstrings<\/h3>"}, {"value": {"name": "Bitstring.empty_bitstring", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/bitstring.mli|25864"}, "info": {"description": "<span class=\"code\" >empty_bitstring<\/span> is the empty, zero-length bitstring."}, "type": "Bitstring.bitstring", "params": []}}, {"value": {"name": "Bitstring.create_bitstring", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/bitstring.mli|25959"}, "info": {"description": "<span class=\"code\" >create_bitstring n<\/span> creates an <span class=\"code\" >n<\/span> bit bitstring containing all zeroes."}, "type": "int -> Bitstring.bitstring", "params": [{"name": "", "type": "int"}]}}, {"value": {"name": "Bitstring.make_bitstring", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/bitstring.mli|26084"}, "info": {"description": "<span class=\"code\" >make_bitstring n c<\/span> creates an <span class=\"code\" >n<\/span> bit bitstring containing the repeated 8 bit pattern in <span class=\"code\" >c<\/span>.<br><\/br> For example, <span class=\"code\" >make_bitstring 16 '\\x5a'<\/span> will create the bitstring <span class=\"code\" >0x5a5a<\/span> or in binary <span class=\"code\" >0101 1010 0101 1010<\/span>.<br><\/br> Note that the length is in bits, not bytes.  The length does NOT need to be a multiple of 8."}, "type": "int -> char -> Bitstring.bitstring", "params": [{"name": "", "type": "int"}, {"name": "", "type": "char"}]}}, {"value": {"name": "Bitstring.zeroes_bitstring", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/bitstring.mli|26460"}, "info": {"description": "<span class=\"code\" >zeroes_bitstring<\/span> creates an <span class=\"code\" >n<\/span> bit bitstring of all 0's.<br><\/br> Actually this is the same as <a href=\"{value|Bitstring.create_bitstring}\" ><span class=\"code\" >Bitstring.create_bitstring<\/span><\/a>."}, "type": "int -> Bitstring.bitstring", "params": [{"name": "", "type": "int"}]}}, {"value": {"name": "Bitstring.ones_bitstring", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/bitstring.mli|26623"}, "info": {"description": "<span class=\"code\" >ones_bitstring<\/span> creates an <span class=\"code\" >n<\/span> bit bitstring of all 1's."}, "type": "int -> Bitstring.bitstring", "params": [{"name": "", "type": "int"}]}}, {"value": {"name": "Bitstring.bitstring_of_string", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/bitstring.mli|26727"}, "info": {"description": "<span class=\"code\" >bitstring_of_string str<\/span> creates a bitstring of length <span class=\"code\" >String.length str * 8<\/span> (bits) containing the bits in <span class=\"code\" >str<\/span>.<br><\/br> Note that the bitstring uses <span class=\"code\" >str<\/span> as the underlying string (see the representation of <a href=\"{type|Bitstring.bitstring}\" ><span class=\"code\" >Bitstring.bitstring<\/span><\/a>) so you should not change <span class=\"code\" >str<\/span> after calling this."}, "type": "string -> Bitstring.bitstring", "params": [{"name": "", "type": "string"}]}}, {"value": {"name": "Bitstring.bitstring_of_chan", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/bitstring.mli|27071"}, "info": {"description": "<span class=\"code\" >bitstring_of_chan chan<\/span> loads the contents of the input channel <span class=\"code\" >chan<\/span> as a bitstring.<br><\/br> The length of the final bitstring is determined by the remaining input in <span class=\"code\" >chan<\/span>, but will always be a multiple of 8 bits.<br><\/br> See also <a href=\"{value|Bitstring.bitstring_of_chan_max}\" ><span class=\"code\" >Bitstring.bitstring_of_chan_max<\/span><\/a>."}, "type": "Pervasives.in_channel -> Bitstring.bitstring", "params": [{"name": "", "type": "Pervasives.in_channel"}]}}, {"value": {"name": "Bitstring.bitstring_of_chan_max", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/bitstring.mli|27395"}, "info": {"description": "<span class=\"code\" >bitstring_of_chan_max chan max<\/span> works like <a href=\"{value|Bitstring.bitstring_of_chan}\" ><span class=\"code\" >Bitstring.bitstring_of_chan<\/span><\/a> but will only read up to <span class=\"code\" >max<\/span> bytes from the channel (or fewer if the end of input occurs before that)."}, "type": "Pervasives.in_channel -> int -> Bitstring.bitstring", "params": [{"name": "", "type": "Pervasives.in_channel"}, {"name": "", "type": "int"}]}}, {"comment": "<h3>Converting bitstrings<\/h3>"}, {"value": {"name": "Bitstring.string_of_bitstring", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/bitstring.mli|27678"}, "info": {"description": "<span class=\"code\" >string_of_bitstring bitstring<\/span> converts a bitstring to a string (eg. to allow comparison).<br><\/br> This function is inefficient.  In the best case when the bitstring is nicely byte-aligned we do a <span class=\"code\" >String.sub<\/span> operation.  If the bitstring isn't aligned then this involves a lot of bit twiddling and is particularly inefficient.<br><\/br> If the bitstring is not a multiple of 8 bits wide then the final byte of the string contains the high bits set to the remaining bits and the low bits set to 0."}, "type": "Bitstring.bitstring -> string", "params": [{"name": "", "type": "Bitstring.bitstring"}]}}, {"value": {"name": "Bitstring.bitstring_to_chan", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/bitstring.mli|28247"}, "info": {"description": "<span class=\"code\" >bitstring_to_file bits filename<\/span> writes the bitstring <span class=\"code\" >bits<\/span> to the channel <span class=\"code\" >chan<\/span>.<br><\/br> Channels are made up of bytes, bitstrings can be any bit length including fractions of bytes.  So this function only works if the length of the bitstring is an exact multiple of 8 bits (otherwise it raises <span class=\"code\" >Invalid_argument \"bitstring_to_chan\"<\/span>).<br><\/br> Furthermore the function is efficient only in the case where the bitstring is stored fully aligned, otherwise it has to do inefficient bit twiddling like <a href=\"{value|Bitstring.string_of_bitstring}\" ><span class=\"code\" >Bitstring.string_of_bitstring<\/span><\/a>.<br><\/br> In the common case where the bitstring was generated by the <span class=\"code\" >BITSTRING<\/span> operator and is an exact multiple of 8 bits wide, then this function will always work efficiently."}, "type": "Bitstring.bitstring -> Pervasives.out_channel -> unit", "params": [{"name": "", "type": "Bitstring.bitstring"}, {"name": "", "type": "Pervasives.out_channel"}]}}, {"comment": "<h3>Printing bitstrings<\/h3>"}, {"value": {"name": "Bitstring.hexdump_bitstring", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/bitstring.mli|29072"}, "info": {"description": "<span class=\"code\" >hexdump_bitstring chan bitstring<\/span> prints the bitstring to the output channel in a format similar to the Unix command <span class=\"code\" >hexdump -C<\/span>."}, "type": "Pervasives.out_channel -> Bitstring.bitstring -> unit", "params": [{"name": "", "type": "Pervasives.out_channel"}, {"name": "", "type": "Bitstring.bitstring"}]}}, {"comment": "<h3>Bitstring buffer<\/h3>"}, {"module": {"name": "Bitstring.Buffer", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/bitstring.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/bitstring.mli|29306"}, "info": {"description": "Buffers are mainly used by the <span class=\"code\" >BITSTRING<\/span> constructor, but may also be useful for end users.  They work much like the standard library <span class=\"code\" >Buffer<\/span> module."}, "type": "sig  end", "module_structure": [{"type": {"name": "Bitstring.Buffer.t", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/bitstring.mli|29333"}, "info": "", "params": [], "kind": {"type": "abstract"}}}, {"value": {"name": "Bitstring.Buffer.create", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/bitstring.mli|29337"}, "info": "", "type": "unit -> Bitstring.Buffer.t", "params": [{"name": "", "type": "unit"}]}}, {"value": {"name": "Bitstring.Buffer.contents", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/bitstring.mli|29362"}, "info": "", "type": "Bitstring.Buffer.t -> Bitstring.bitstring", "params": [{"name": "", "type": "Bitstring.Buffer.t"}]}}, {"value": {"name": "Bitstring.Buffer.add_bits", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/bitstring.mli|29394"}, "info": "", "type": "Bitstring.Buffer.t -> string -> int -> unit", "params": [{"name": "", "type": "Bitstring.Buffer.t"}, {"name": "", "type": "string"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Bitstring.Buffer.add_bit", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/bitstring.mli|29438"}, "info": "", "type": "Bitstring.Buffer.t -> bool -> unit", "params": [{"name": "", "type": "Bitstring.Buffer.t"}, {"name": "", "type": "bool"}]}}, {"value": {"name": "Bitstring.Buffer.add_byte", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/bitstring.mli|29472"}, "info": "", "type": "Bitstring.Buffer.t -> int -> unit", "params": [{"name": "", "type": "Bitstring.Buffer.t"}, {"name": "", "type": "int"}]}}], "dependencies": {"uses": []}}}, {"comment": "<h3>Get\/set bits<\/h3><br><\/br> These functions let you manipulate individual bits in the bitstring.  However they are not particularly efficient and you should generally use the <span class=\"code\" >bitmatch<\/span> and <span class=\"code\" >BITSTRING<\/span> operators when building and parsing bitstrings.<br><\/br> These functions all raise <span class=\"code\" >Invalid_argument \"index out of bounds\"<\/span> if the index is out of range of the bitstring."}, {"value": {"name": "Bitstring.set", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/bitstring.mli|30064"}, "info": {"description": "<span class=\"code\" >set bits n<\/span> sets the <span class=\"code\" >n<\/span>th bit in the bitstring to 1."}, "type": "Bitstring.bitstring -> int -> unit", "params": [{"name": "", "type": "Bitstring.bitstring"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Bitstring.clear", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/bitstring.mli|30164"}, "info": {"description": "<span class=\"code\" >clear bits n<\/span> sets the <span class=\"code\" >n<\/span>th bit in the bitstring to 0."}, "type": "Bitstring.bitstring -> int -> unit", "params": [{"name": "", "type": "Bitstring.bitstring"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Bitstring.is_set", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/bitstring.mli|30268"}, "info": {"description": "<span class=\"code\" >is_set bits n<\/span> is true if the <span class=\"code\" >n<\/span>th bit is set to 1."}, "type": "Bitstring.bitstring -> int -> bool", "params": [{"name": "", "type": "Bitstring.bitstring"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Bitstring.is_clear", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/bitstring.mli|30370"}, "info": {"description": "<span class=\"code\" >is_clear bits n<\/span> is true if the <span class=\"code\" >n<\/span>th bit is set to 0."}, "type": "Bitstring.bitstring -> int -> bool", "params": [{"name": "", "type": "Bitstring.bitstring"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Bitstring.put", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/bitstring.mli|30476"}, "info": {"description": "<span class=\"code\" >put bits n v<\/span> sets the <span class=\"code\" >n<\/span>th bit in the bitstring to 1 if <span class=\"code\" >v<\/span> is not zero, or to 0 if <span class=\"code\" >v<\/span> is zero."}, "type": "Bitstring.bitstring -> int -> int -> unit", "params": [{"name": "", "type": "Bitstring.bitstring"}, {"name": "", "type": "int"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Bitstring.get", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/bitstring.mli|30634"}, "info": {"description": "<span class=\"code\" >get bits n<\/span> returns the <span class=\"code\" >n<\/span>th bit (returns non-zero or 0)."}, "type": "Bitstring.bitstring -> int -> int", "params": [{"name": "", "type": "Bitstring.bitstring"}, {"name": "", "type": "int"}]}}, {"comment": "<h3>Miscellaneous<\/h3>"}, {"value": {"name": "Bitstring.package", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/bitstring.mli|30764"}, "info": {"description": "The package name, always <span class=\"code\" >\"ocaml-bitstring\"<\/span>"}, "type": "string", "params": []}}, {"value": {"name": "Bitstring.version", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/bitstring.mli|30838"}, "info": {"description": "The package version as a string."}, "type": "string", "params": []}}, {"value": {"name": "Bitstring.debug", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/bitstring.mli|30900"}, "info": {"description": "Set this variable to true to enable extended debugging. This only works if debugging was also enabled in the <span class=\"code\" >pa_bitstring.ml<\/span> file at compile time, otherwise it does nothing."}, "type": "bool Pervasives.ref", "params": []}}], "dependencies": {"uses": [], "used_by": ["OS", "Net", "Block", "Dns", "Http"]}}}, "Bitstring_types": {"module": {"name": "Bitstring_types", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/bitstring_types.ml", "location": {"implementation": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/bitstring_types.ml|0", "interface": "unknown"}, "info": "", "type": "sig  end", "module_structure": [{"type": {"name": "Bitstring_types.endian", "location": {"implementation": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/bitstring_types.ml|963", "interface": "unknown"}, "info": "", "params": [], "kind": {"type": "variant", "private": "false", "constructors": [{"name": "BigEndian", "type": []}, {"name": "LittleEndian", "type": []}, {"name": "NativeEndian", "type": []}]}}}, {"value": {"name": "Bitstring_types.string_of_endian", "location": {"implementation": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/bitstring_types.ml|1013", "interface": "unknown"}, "info": "", "type": "Bitstring_types.endian -> string", "params": [{"tuple": {"type": "Bitstring_types.endian", "contents": []}}]}}], "dependencies": {"uses": [], "used_by": ["Bitstring_config"]}}}, "Bitstring_config": {"module": {"name": "Bitstring_config", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/bitstring_config.ml", "location": {"implementation": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/bitstring_config.ml|0", "interface": "unknown"}, "info": "", "type": "sig  end", "module_structure": [{"value": {"name": "Bitstring_config.nativeendian", "location": {"implementation": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/bitstring_config.ml|1133", "interface": "unknown"}, "info": "", "type": "Bitstring_types.endian", "params": []}}, {"value": {"name": "Bitstring_config.package", "location": {"implementation": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/bitstring_config.ml|1182", "interface": "unknown"}, "info": "", "type": "string", "params": []}}, {"value": {"name": "Bitstring_config.version", "location": {"implementation": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/bitstring_config.ml|1214", "interface": "unknown"}, "info": "", "type": "string", "params": []}}, {"value": {"name": "Bitstring_config.ocamllibdir", "location": {"implementation": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/bitstring_config.ml|1236", "interface": "unknown"}, "info": "", "type": "string", "params": []}}, {"value": {"name": "Bitstring_config.diff", "location": {"implementation": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/bitstring_config.ml|1272", "interface": "unknown"}, "info": "", "type": "string", "params": []}}], "dependencies": {"uses": ["Bitstring_types"], "used_by": []}}}, "Lwt": {"module": {"name": "Lwt", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt.mli|0"}, "info": {"description": "Module <span class=\"code\" >Lwt<\/span>: cooperative light-weight threads."}, "type": "sig  end", "module_structure": [{"comment": "This module defines <em>cooperative light-weight threads<\/em> with their primitives. A <em>light-weight thread<\/em> represent a computation that may be not terminated, for example because it is waiting for some event to happen.<br><\/br> Lwt threads are cooperative in the sense that switching to another thread is awlays explicit (with <a href=\"{value|Lwt.wakeup}\" ><span class=\"code\" >Lwt.wakeup<\/span><\/a> or <a href=\"{none|wekup_exn}\" ><span class=\"code\" >wekup_exn<\/span><\/a>). When a thread is running, it executes as much as possible, and then returns (a value or an eror) or sleeps.<br><\/br> Note that inside a Lwt thread, exceptions must be raised with <a href=\"{value|Lwt.fail}\" ><span class=\"code\" >Lwt.fail<\/span><\/a> instead of <span class=\"code\" >raise<\/span>. Also the <span class=\"code\" >try ... with ...<\/span> construction will not catch Lwt errors. You must use <a href=\"{value|Lwt.catch}\" ><span class=\"code\" >Lwt.catch<\/span><\/a> instead.<br><\/br> Lwt also provides the syntax extension <a href=\"{none|Pa_lwt}\" ><span class=\"code\" >Pa_lwt<\/span><\/a> to make code using Lwt more readable."}, {"comment": "<h6>Definitions and basics<\/h6>"}, {"type": {"name": "Lwt.t", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt.mli|1884"}, "info": {"description": "The type of threads returning a result of type <span class=\"code\" >'a<\/span>."}, "params": [{"covariant": "true", "contravariant": "false", "type": "'a"}], "kind": {"type": "abstract"}}}, {"value": {"name": "Lwt.return", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt.mli|1953"}, "info": {"description": "<span class=\"code\" >return e<\/span> is a thread whose return value is the value of the expression <span class=\"code\" >e<\/span>."}, "type": "'a -> 'a Lwt.t", "params": [{"name": "", "type": "'a"}]}}, {"value": {"name": "Lwt.fail", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt.mli|2071"}, "info": {"description": "<span class=\"code\" >fail e<\/span> is a thread that fails with the exception <span class=\"code\" >e<\/span>."}, "type": "exn -> 'a Lwt.t", "params": [{"name": "", "type": "exn"}]}}, {"value": {"name": "Lwt.bind", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt.mli|2160"}, "info": {"description": "<span class=\"code\" >bind t f<\/span> is a thread which first waits for the thread <span class=\"code\" >t<\/span> to terminate and then, if the thread succeeds, behaves as the application of function <span class=\"code\" >f<\/span> to the return value of <span class=\"code\" >t<\/span>.  If the thread <span class=\"code\" >t<\/span> fails, <span class=\"code\" >bind t f<\/span> also fails, with the same exception.<br><\/br> The expression <span class=\"code\" >bind t (fun x -&gt; t')<\/span> can intuitively be read as <span class=\"code\" >let x = t in t'<\/span>, and if you use the <em>lwt.syntax<\/em> syntax extension, you can write a bind operation like that: <span class=\"code\" >lwt x = t in t'<\/span>.<br><\/br> Note that <span class=\"code\" >bind<\/span> is also often used just for synchronization purpose: <span class=\"code\" >t'<\/span> will not execute before <span class=\"code\" >t<\/span> is terminated.<br><\/br> The result of a thread can be bound several time."}, "type": "'a Lwt.t -> ('a -> 'b Lwt.t) -> 'b Lwt.t", "params": [{"name": "", "type": "'a Lwt.t"}, {"name": "", "type": "'a -> 'b Lwt.t"}]}}, {"value": {"name": "Lwt.(>>=)", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt.mli|2890"}, "info": {"description": "<span class=\"code\" >t &gt;&gt;= f<\/span> is an alternative notation for <span class=\"code\" >bind t f<\/span>."}, "type": "'a Lwt.t -> ('a -> 'b Lwt.t) -> 'b Lwt.t", "params": [{"name": "", "type": "'a Lwt.t"}, {"name": "", "type": "'a -> 'b Lwt.t"}]}}, {"value": {"name": "Lwt.(=<<)", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt.mli|2994"}, "info": {"description": "<span class=\"code\" >f =&lt;&lt; t<\/span> is <span class=\"code\" >t &gt;&gt;= f<\/span>"}, "type": "('a -> 'b Lwt.t) -> 'a Lwt.t -> 'b Lwt.t", "params": [{"name": "", "type": "'a -> 'b Lwt.t"}, {"name": "", "type": "'a Lwt.t"}]}}, {"value": {"name": "Lwt.map", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt.mli|3068"}, "info": {"description": "<span class=\"code\" >map f m<\/span> map the result of a thread. This is the same as <span class=\"code\" >bind m (fun x -&gt; return (f x))<\/span>"}, "type": "('a -> 'b) -> 'a Lwt.t -> 'b Lwt.t", "params": [{"name": "", "type": "'a -> 'b"}, {"name": "", "type": "'a Lwt.t"}]}}, {"value": {"name": "Lwt.(>|=)", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt.mli|3212"}, "info": {"description": "<span class=\"code\" >m &gt;|= f<\/span> is <span class=\"code\" >map f m<\/span>"}, "type": "'a Lwt.t -> ('a -> 'b) -> 'b Lwt.t", "params": [{"name": "", "type": "'a Lwt.t"}, {"name": "", "type": "'a -> 'b"}]}}, {"value": {"name": "Lwt.(=|<)", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt.mli|3284"}, "info": {"description": "<span class=\"code\" >f =|&lt; m<\/span> is <span class=\"code\" >map f m<\/span>"}, "type": "('a -> 'b) -> 'a Lwt.t -> 'b Lwt.t", "params": [{"name": "", "type": "'a -> 'b"}, {"name": "", "type": "'a Lwt.t"}]}}, {"comment": "<h6>Thread storage<\/h6>"}, {"type": {"name": "Lwt.key", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt.mli|3387"}, "info": {"description": "Type of a key. Keys are used to store local values into threads"}, "params": [{"covariant": "true", "contravariant": "true", "type": "'b"}], "kind": {"type": "abstract"}}}, {"value": {"name": "Lwt.new_key", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt.mli|3475"}, "info": {"description": "<span class=\"code\" >new_key ()<\/span> creates a new key."}, "type": "unit -> 'a Lwt.key", "params": [{"name": "", "type": "unit"}]}}, {"value": {"name": "Lwt.get", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt.mli|3546"}, "info": {"description": "<span class=\"code\" >get key<\/span> returns the value associated with <span class=\"code\" >key<\/span> in the current thread."}, "type": "'a Lwt.key -> 'a option", "params": [{"name": "", "type": "'a Lwt.key"}]}}, {"value": {"name": "Lwt.with_value", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt.mli|3665"}, "info": {"description": "<span class=\"code\" >with_value key value f<\/span> executes <span class=\"code\" >f<\/span> with <span class=\"code\" >value<\/span> associated to <span class=\"code\" >key<\/span>. The previous value associated to <span class=\"code\" >key<\/span> is restored after <span class=\"code\" >f<\/span> terminates."}, "type": "'a Lwt.key -> 'a option -> (unit -> 'b) -> 'b", "params": [{"name": "", "type": "'a Lwt.key"}, {"name": "", "type": "'a option"}, {"name": "", "type": "unit -> 'a"}]}}, {"comment": "<h6>Exceptions handling<\/h6>"}, {"value": {"name": "Lwt.catch", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt.mli|3923"}, "info": {"description": "<span class=\"code\" >catch t f<\/span> is a thread that behaves as the thread <span class=\"code\" >t ()<\/span> if this thread succeeds.  If the thread <span class=\"code\" >t ()<\/span> fails with some exception, <span class=\"code\" >catch t f<\/span> behaves as the application of <span class=\"code\" >f<\/span> to this exception."}, "type": "(unit -> 'a Lwt.t) -> (exn -> 'a Lwt.t) -> 'a Lwt.t", "params": [{"name": "", "type": "unit -> 'a Lwt.t"}, {"name": "", "type": "exn -> 'a Lwt.t"}]}}, {"value": {"name": "Lwt.try_bind", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt.mli|4200"}, "info": {"description": "<span class=\"code\" >try_bind t f g<\/span> behaves as <span class=\"code\" >bind (t ()) f<\/span> if <span class=\"code\" >t<\/span> does not fail.  Otherwise, it behaves as the application of <span class=\"code\" >g<\/span> to the exception associated to <span class=\"code\" >t ()<\/span>."}, "type": "(unit -> 'a Lwt.t) -> ('a -> 'b Lwt.t) -> (exn -> 'b Lwt.t) -> 'b Lwt.t", "params": [{"name": "", "type": "unit -> 'a Lwt.t"}, {"name": "", "type": "'a -> 'b Lwt.t"}, {"name": "", "type": "exn -> 'a Lwt.t"}]}}, {"value": {"name": "Lwt.finalize", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt.mli|4447"}, "info": {"description": "<span class=\"code\" >finalize f g<\/span> returns the same result as <span class=\"code\" >f ()<\/span> whether it fails or not. In both cases, <span class=\"code\" >g ()<\/span> is executed after <span class=\"code\" >f<\/span>."}, "type": "(unit -> 'a Lwt.t) -> (unit -> unit Lwt.t) -> 'a Lwt.t", "params": [{"name": "", "type": "unit -> 'a Lwt.t"}, {"name": "", "type": "unit -> unit Lwt.t"}]}}, {"comment": "<h6>Multi-threads composition<\/h6>"}, {"value": {"name": "Lwt.choose", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt.mli|4678"}, "info": {"description": "<span class=\"code\" >choose l<\/span> behaves as the first thread in <span class=\"code\" >l<\/span> to terminate.  If several threads are already terminated, one is choosen at random.<br><\/br> Note: <a href=\"{value|Lwt.choose}\" ><span class=\"code\" >Lwt.choose<\/span><\/a> leaves the local values of the current thread unchanged."}, "type": "'a Lwt.t list -> 'a Lwt.t", "params": [{"name": "", "type": "'a Lwt.t list"}]}}, {"value": {"name": "Lwt.nchoose", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt.mli|4947"}, "info": {"description": "<span class=\"code\" >nchoose l<\/span> returns the value of all that have succcessfully terminated. If all threads are sleeping, it waits for at least one to terminates. If one the threads of <span class=\"code\" >l<\/span> fails, <span class=\"code\" >nchoose<\/span> fails with the same exception.<br><\/br> Note: <a href=\"{value|Lwt.nchoose}\" ><span class=\"code\" >Lwt.nchoose<\/span><\/a> leaves the local values of the current thread unchanged."}, "type": "'a Lwt.t list -> 'a list Lwt.t", "params": [{"name": "", "type": "'a Lwt.t list"}]}}, {"value": {"name": "Lwt.nchoose_split", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt.mli|5316"}, "info": {"description": "<span class=\"code\" >nchoose_split l<\/span> does the same as <a href=\"{value|Lwt.nchoose}\" ><span class=\"code\" >Lwt.nchoose<\/span><\/a> but also retrurns the list of threads that have not yet terminated."}, "type": "'a Lwt.t list -> ('a list * 'a Lwt.t list) Lwt.t", "params": [{"name": "", "type": "'a Lwt.t list"}]}}, {"value": {"name": "Lwt.join", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt.mli|5503"}, "info": {"description": "<span class=\"code\" >join l<\/span> waits for all threads in <span class=\"code\" >l<\/span> to terminate. If one of the threads fails, then <span class=\"code\" >join l<\/span> will fails with the same exception as the first one to terminate.<br><\/br> Note: <a href=\"{value|Lwt.join}\" ><span class=\"code\" >Lwt.join<\/span><\/a> leaves the local values of the current thread unchanged."}, "type": "unit Lwt.t list -> unit Lwt.t", "params": [{"name": "", "type": "unit Lwt.t list"}]}}, {"value": {"name": "Lwt.(<?>)", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt.mli|5803"}, "info": {"description": "<span class=\"code\" >t &lt;?&gt; t'<\/span> is the same as <span class=\"code\" >choose [t; t']<\/span>"}, "type": "'a Lwt.t -> 'a Lwt.t -> 'a Lwt.t", "params": [{"name": "", "type": "'a Lwt.t"}, {"name": "", "type": "'a Lwt.t"}]}}, {"value": {"name": "Lwt.(<&>)", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt.mli|5891"}, "info": {"description": "<span class=\"code\" >t &lt;&amp;&gt; t'<\/span> is the same as <span class=\"code\" >join [t; t']<\/span>"}, "type": "unit Lwt.t -> unit Lwt.t -> unit Lwt.t", "params": [{"name": "", "type": "unit Lwt.t"}, {"name": "", "type": "unit Lwt.t"}]}}, {"value": {"name": "Lwt.ignore_result", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt.mli|5983"}, "info": {"description": "<span class=\"code\" >ignore_result t<\/span> start the thread <span class=\"code\" >t<\/span> and ignores its result value if the thread terminates sucessfully.  However, if the thread <span class=\"code\" >t<\/span> fails, the exception is raised instead of being ignored.<br><\/br> You should use this function if you want to start a thread and don't care what its return value is, nor when it terminates (for instance, because it is looping).  Note that if the thread <span class=\"code\" >t<\/span> yields and later fails, the exception will not be raised at this point in the program."}, "type": "'a Lwt.t -> unit", "params": [{"name": "", "type": "'a Lwt.t"}]}}, {"comment": "<h6>Sleeping and resuming<\/h6>"}, {"type": {"name": "Lwt.u", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt.mli|6582"}, "info": {"description": "The type of thread wakeners."}, "params": [{"covariant": "true", "contravariant": "true", "type": "'b"}], "kind": {"type": "abstract"}}}, {"value": {"name": "Lwt.wait", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt.mli|6627"}, "info": {"description": "<span class=\"code\" >wait ()<\/span> is a pair of a thread which sleeps forever (unless it is resumed by one of the functions <span class=\"code\" >wakeup<\/span>, <span class=\"code\" >wakeup_exn<\/span> below) and the corresponding wakener.  This thread does not block the execution of the remainder of the program (except of course, if another thread tries to wait for its termination)."}, "type": "unit -> 'a Lwt.t * 'a Lwt.u", "params": [{"name": "", "type": "unit"}]}}, {"value": {"name": "Lwt.wakeup", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt.mli|6999"}, "info": {"description": "<span class=\"code\" >wakeup t e<\/span> makes the sleeping thread <span class=\"code\" >t<\/span> terminate and return the value of the expression <span class=\"code\" >e<\/span>."}, "type": "'a Lwt.u -> 'a -> unit", "params": [{"name": "", "type": "'a Lwt.u"}, {"name": "", "type": "'a"}]}}, {"value": {"name": "Lwt.wakeup_exn", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt.mli|7144"}, "info": {"description": "<span class=\"code\" >wakeup_exn t e<\/span> makes the sleeping thread <span class=\"code\" >t<\/span> fail with the exception <span class=\"code\" >e<\/span>."}, "type": "'a Lwt.u -> exn -> unit", "params": [{"name": "", "type": "'a Lwt.u"}, {"name": "", "type": "exn"}]}}, {"value": {"name": "Lwt.waiter_of_wakener", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt.mli|7273"}, "info": {"description": "Returns the thread associated to a wakener."}, "type": "'a Lwt.u -> 'a Lwt.t", "params": [{"name": "", "type": "'a Lwt.u"}]}}, {"comment": "<h6>Threads state<\/h6>"}, {"type": {"name": "Lwt.state", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt.mli|7419"}, "info": {"description": "State of a thread"}, "params": [{"covariant": "true", "contravariant": "false", "type": "'b"}], "kind": {"type": "variant", "private": "false", "constructors": [{"name": "Return", "description": "The thread which has successfully terminated", "type": ["'a"]}, {"name": "Fail", "description": "The thread raised an exception", "type": ["exn"]}, {"name": "Sleep", "description": "The thread is sleeping", "type": []}]}}}, {"value": {"name": "Lwt.state", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt.mli|7613"}, "info": {"description": "<span class=\"code\" >state t<\/span> returns the state of a thread"}, "type": "'a Lwt.t -> 'a Lwt.state", "params": [{"name": "", "type": "'a Lwt.t"}]}}, {"comment": "<h6>Cancelable threads<\/h6>"}, {"comment": "Cancelable threads are the same as regular threads except that they can be canceled."}, {"exception": {"name": "Lwt.Canceled", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt.mli|7820"}, "info": {"description": "Canceled threads fails with this exception"}}}, {"value": {"name": "Lwt.task", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt.mli|7892"}, "info": {"description": "<span class=\"code\" >task ()<\/span> is the same as <span class=\"code\" >wait ()<\/span> except that threads created with <span class=\"code\" >task<\/span> can be canceled."}, "type": "unit -> 'a Lwt.t * 'a Lwt.u", "params": [{"name": "", "type": "unit"}]}}, {"value": {"name": "Lwt.on_cancel", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt.mli|8031"}, "info": {"description": "<span class=\"code\" >on_cancel t f<\/span> executes <span class=\"code\" >f<\/span> when <span class=\"code\" >t<\/span> is canceled. This is the same as catching <span class=\"code\" >Canceled<\/span>."}, "type": "'a Lwt.t -> (unit -> unit) -> unit", "params": [{"name": "", "type": "'a Lwt.t"}, {"name": "", "type": "unit -> unit"}]}}, {"value": {"name": "Lwt.cancel", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt.mli|8186"}, "info": {"description": "<span class=\"code\" >cancel t<\/span> cancels the threads <span class=\"code\" >t<\/span>. This means that the deepest sleeping thread created with <span class=\"code\" >task<\/span> and connected to <span class=\"code\" >t<\/span> is wakeup with the exception <a href=\"{exception|Lwt.Canceled}\" ><span class=\"code\" >Lwt.Canceled<\/span><\/a>.<br><\/br> For example, in the following code:<br><\/br> <span class=\"codepre\" > let waiter, wakener = task () in cancel (waiter &gt;&gt; printl \"plop\") <\/span><br><\/br> <span class=\"code\" >waiter<\/span> will be waked up with <a href=\"{exception|Lwt.Canceled}\" ><span class=\"code\" >Lwt.Canceled<\/span><\/a>."}, "type": "'a Lwt.t -> unit", "params": [{"name": "", "type": "'a Lwt.t"}]}}, {"value": {"name": "Lwt.pick", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt.mli|8594"}, "info": {"description": "<span class=\"code\" >pick l<\/span> is the same as <a href=\"{value|Lwt.choose}\" ><span class=\"code\" >Lwt.choose<\/span><\/a>, except that it cancels all sleeping threads when one terminates.<br><\/br> Note: <a href=\"{value|Lwt.pick}\" ><span class=\"code\" >Lwt.pick<\/span><\/a> leaves the local values of the current thread unchanged."}, "type": "'a Lwt.t list -> 'a Lwt.t", "params": [{"name": "", "type": "'a Lwt.t list"}]}}, {"value": {"name": "Lwt.npick", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt.mli|8823"}, "info": {"description": "<span class=\"code\" >npick l<\/span> is the same as <a href=\"{value|Lwt.nchoose}\" ><span class=\"code\" >Lwt.nchoose<\/span><\/a>, except that it cancels all sleeping threads when one terminates.<br><\/br> Note: <a href=\"{value|Lwt.npick}\" ><span class=\"code\" >Lwt.npick<\/span><\/a> leaves the local values of the current thread unchanged."}, "type": "'a Lwt.t list -> 'a list Lwt.t", "params": [{"name": "", "type": "'a Lwt.t list"}]}}, {"value": {"name": "Lwt.protected", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt.mli|9061"}, "info": {"description": "<span class=\"code\" >protected thread<\/span> creates a new cancelable thread which behave as <span class=\"code\" >thread<\/span> except that cancelling it does not cancel <span class=\"code\" >thread<\/span>."}, "type": "'a Lwt.t -> 'a Lwt.t", "params": [{"name": "", "type": "'a Lwt.t"}]}}, {"comment": "<h6>Pause<\/h6>"}, {"value": {"name": "Lwt.pause", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt.mli|9258"}, "info": {"description": "<span class=\"code\" >pause ()<\/span> is a sleeping thread which is wake up on the next call to <a href=\"{value|Lwt.wakeup_paused}\" ><span class=\"code\" >Lwt.wakeup_paused<\/span><\/a>. A thread created with <span class=\"code\" >pause<\/span> can be canceled."}, "type": "unit -> unit Lwt.t", "params": [{"name": "", "type": "unit"}]}}, {"value": {"name": "Lwt.wakeup_paused", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt.mli|9441"}, "info": {"description": "<span class=\"code\" >wakeup_paused ()<\/span> wakes up all threads which suspended themselves with <a href=\"{value|Lwt.pause}\" ><span class=\"code\" >Lwt.pause<\/span><\/a>.<br><\/br> This function is called by the scheduler, before entering the main loop. You usually do not have to call it directly, except if you are writing a custom scheduler.<br><\/br> Note that if a paused thread resume and pause again, it will not be wakeup at this point."}, "type": "unit -> unit", "params": [{"name": "", "type": "unit"}]}}, {"value": {"name": "Lwt.paused_count", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt.mli|9858"}, "info": {"description": "<span class=\"code\" >paused_count ()<\/span> returns the number of thread currently paused."}, "type": "unit -> int", "params": [{"name": "", "type": "unit"}]}}, {"value": {"name": "Lwt.register_pause_notifier", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt.mli|9970"}, "info": {"description": "<span class=\"code\" >register_pause_notifier f<\/span> register a function <span class=\"code\" >f<\/span> that will be called each time pause is called. The parameter passed to <span class=\"code\" >f<\/span> is the new number of threads paused. It is usefull to be able to call <a href=\"{value|Lwt.wakeup_paused}\" ><span class=\"code\" >Lwt.wakeup_paused<\/span><\/a> when there is no scheduler"}, "type": "(int -> unit) -> unit", "params": [{"name": "", "type": "int -> unit"}]}}, {"comment": "<h6>Misc<\/h6>"}, {"value": {"name": "Lwt.on_success", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt.mli|10308"}, "info": {"description": "<span class=\"code\" >on_success t f<\/span> executes <span class=\"code\" >f<\/span> when <span class=\"code\" >t<\/span> terminates without failing. This is the same as:<br><\/br> <span class=\"codepre\" > ignore_result (bind t (fun x -&gt; f x; return ())) <\/span><br><\/br> but a bit more efficient."}, "type": "'a Lwt.t -> ('a -> unit) -> unit", "params": [{"name": "", "type": "'a Lwt.t"}, {"name": "", "type": "'a -> unit"}]}}, {"value": {"name": "Lwt.on_failure", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt.mli|10568"}, "info": {"description": "<span class=\"code\" >on_failure t f<\/span> executes <span class=\"code\" >f<\/span> when <span class=\"code\" >t<\/span> terminates and fails. This is the same as:<br><\/br> <span class=\"codepre\" > ignore_result (catch t (fun e -&gt; f e; return ())) <\/span><br><\/br> but a bit more efficient."}, "type": "'a Lwt.t -> (exn -> unit) -> unit", "params": [{"name": "", "type": "'a Lwt.t"}, {"name": "", "type": "exn -> unit"}]}}], "dependencies": {"uses": [], "used_by": ["Lwt_util", "Lwt_stream", "Lwt_mvar", "Lwt_mutex", "Lwt_list", "Lwt_pool", "Lwt_condition", "Lwt_switch", "OS", "Net", "Block", "Dns", "Http"]}}}, "Lwt_util": {"module": {"name": "Lwt_util", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_util.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_util.mli|0"}, "info": {"description": "Note: This lodule is deprecated. Use <a href=\"{module|Lwt_list}\" ><span class=\"code\" >Lwt_list<\/span><\/a> and <a href=\"{module|Lwt_pool}\" ><span class=\"code\" >Lwt_pool<\/span><\/a> instead."}, "type": "sig  end", "module_structure": [{"comment": "<h2>Lists iterators<\/h2>"}, {"value": {"name": "Lwt_util.iter", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_util.mli|1115"}, "info": {"description": "<span class=\"code\" >iter f l<\/span> start a thread for each element in <span class=\"code\" >l<\/span>.  The threads are started according to the list order, but then can run concurrently.  It terminates when all the threads are terminated, if all threads are successful.  It fails if any of the threads fail."}, "type": "('a -> unit Lwt.t) -> 'a list -> unit Lwt.t", "params": [{"name": "", "type": "'a -> unit Lwt.t"}, {"name": "", "type": "'a list"}]}}, {"value": {"name": "Lwt_util.iter_serial", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_util.mli|1471"}, "info": {"description": "Similar to <span class=\"code\" >iter<\/span> but wait for one thread to terminate before starting the next one."}, "type": "('a -> unit Lwt.t) -> 'a list -> unit Lwt.t", "params": [{"name": "", "type": "'a -> unit Lwt.t"}, {"name": "", "type": "'a list"}]}}, {"value": {"name": "Lwt_util.map", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_util.mli|1638"}, "info": {"description": "<span class=\"code\" >map f l<\/span> apply <span class=\"code\" >f<\/span> to each element in <span class=\"code\" >l<\/span> and collect the results of the threads thus created.  The threads are started according to the list order, but then can run concurrently. <span class=\"code\" >map f l<\/span> fails if any of the threads fail."}, "type": "('a -> 'b Lwt.t) -> 'a list -> 'b list Lwt.t", "params": [{"name": "", "type": "'a -> 'b Lwt.t"}, {"name": "", "type": "'a list"}]}}, {"value": {"name": "Lwt_util.map_with_waiting_action", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_util.mli|1954"}, "info": {"description": "<span class=\"code\" >map_with_waiting_action f wa l<\/span> apply <span class=\"code\" >f<\/span> to each element in <span class=\"code\" >l<\/span> and collect the results of the threads thus created. The threads are started according to the list order, but then can run concurrently.  The difference with <span class=\"code\" >map f l<\/span> is that function wa will be called on the element that the function is waiting for its termination."}, "type": "('a -> 'b Lwt.t) -> ('a -> unit) -> 'a list -> 'b list Lwt.t", "params": [{"name": "", "type": "'a -> 'b Lwt.t"}, {"name": "", "type": "'a -> unit"}, {"name": "", "type": "'a list"}]}}, {"value": {"name": "Lwt_util.map_serial", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_util.mli|2455"}, "info": {"description": "Similar to <span class=\"code\" >map<\/span> but wait for one thread to terminate before starting the next one."}, "type": "('a -> 'b Lwt.t) -> 'a list -> 'b list Lwt.t", "params": [{"name": "", "type": "'a -> 'b Lwt.t"}, {"name": "", "type": "'a list"}]}}, {"value": {"name": "Lwt_util.fold_left", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_util.mli|2621"}, "info": {"description": "Similar to <span class=\"code\" >List.fold_left<\/span>."}, "type": "('a -> 'b -> 'a Lwt.t) -> 'a -> 'b list -> 'a Lwt.t", "params": [{"name": "", "type": "'a -> 'b -> 'a Lwt.t"}, {"name": "", "type": "'a"}, {"name": "", "type": "'a list"}]}}, {"comment": "<h2>Regions<\/h2>"}, {"type": {"name": "Lwt_util.region", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_util.mli|2763"}, "info": "", "params": [], "kind": {"type": "abstract"}}}, {"value": {"name": "Lwt_util.make_region", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_util.mli|2771"}, "info": {"description": "<span class=\"code\" >make_region sz<\/span> create a region of size <span class=\"code\" >sz<\/span>."}, "type": "int -> Lwt_util.region", "params": [{"name": "", "type": "int"}]}}, {"value": {"name": "Lwt_util.resize_region", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_util.mli|2863"}, "info": {"description": "<span class=\"code\" >resize_region reg sz<\/span> resize the region <span class=\"code\" >reg<\/span> to size <span class=\"code\" >sz<\/span>."}, "type": "Lwt_util.region -> int -> unit", "params": [{"name": "", "type": "Lwt_util.region"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Lwt_util.run_in_region", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_util.mli|2979"}, "info": {"description": "<span class=\"code\" >run_in_region reg size f<\/span> execute the thread produced by the function <span class=\"code\" >f<\/span> in the region <span class=\"code\" >reg<\/span>. The thread is not started before some room is available in the region."}, "type": "Lwt_util.region -> int -> (unit -> 'a Lwt.t) -> 'a Lwt.t", "params": [{"name": "", "type": "Lwt_util.region"}, {"name": "", "type": "int"}, {"name": "", "type": "unit -> 'a Lwt.t"}]}}], "dependencies": {"uses": ["Lwt"], "used_by": []}}}, "Lwt_stream": {"module": {"name": "Lwt_stream", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_stream.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_stream.mli|0"}, "info": {"description": "Data streams"}, "type": "sig  end", "module_structure": [{"type": {"name": "Lwt_stream.t", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_stream.mli|970"}, "info": {"description": "Type of a stream holding values of type <span class=\"code\" >'a<\/span>"}, "params": [{"covariant": "true", "contravariant": "true", "type": "'b"}], "kind": {"type": "abstract"}}}, {"comment": "Naming convention: in this module all function taking a function which is applied to all element of the streams are suffixed by:<br><\/br><ul><li><span class=\"code\" >_s<\/span> when the function returns a thread and calls are serialised<\/li><li><span class=\"code\" >_p<\/span> when the function returns a thread and calls are parallelised<\/li><\/ul>"}, {"comment": "<h6>Construction<\/h6>"}, {"value": {"name": "Lwt_stream.from", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_stream.mli|1342"}, "info": {"description": "<span class=\"code\" >from f<\/span> creates an stream from the given input function. <span class=\"code\" >f<\/span> is called each time more input is needed, and the stream ends when <span class=\"code\" >f<\/span> returns <span class=\"code\" >None<\/span>."}, "type": "(unit -> 'a option Lwt.t) -> 'a Lwt_stream.t", "params": [{"name": "", "type": "unit -> 'a option Lwt.t"}]}}, {"value": {"name": "Lwt_stream.create", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_stream.mli|1558"}, "info": {"description": "<span class=\"code\" >create ()<\/span> returns a new stream and a push function"}, "type": "unit -> 'a Lwt_stream.t * ('a option -> unit)", "params": [{"name": "", "type": "unit"}]}}, {"value": {"name": "Lwt_stream.of_list", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_stream.mli|1669"}, "info": {"description": "<span class=\"code\" >of_list l<\/span> creates a stream returning all elements of <span class=\"code\" >l<\/span>"}, "type": "'a list -> 'a Lwt_stream.t", "params": [{"name": "", "type": "'a list"}]}}, {"value": {"name": "Lwt_stream.of_array", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_stream.mli|1768"}, "info": {"description": "<span class=\"code\" >of_array a<\/span> creates a stream returning all elements of <span class=\"code\" >a<\/span>"}, "type": "'a array -> 'a Lwt_stream.t", "params": [{"name": "", "type": "'a array"}]}}, {"value": {"name": "Lwt_stream.of_string", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_stream.mli|1870"}, "info": {"description": "<span class=\"code\" >of_string str<\/span> creates a stream returning all characters of <span class=\"code\" >str<\/span>"}, "type": "string -> char Lwt_stream.t", "params": [{"name": "", "type": "string"}]}}, {"value": {"name": "Lwt_stream.clone", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_stream.mli|1986"}, "info": {"description": "<span class=\"code\" >clone st<\/span> clone the given stream. Operations on each stream will not affect the other.<br><\/br> For example:<br><\/br> <span class=\"codepre\" > # let st1 = Lwt_stream.of_list [1; 2; 3];; val st1 : int Lwt_stream.t = &lt;abstr&gt; # let st2 = Lwt_stream.clone st1;; val st2 : int Lwt_stream.t = &lt;abstr&gt; # lwt x = Lwt_stream.next st1;; val x : int = 1 # lwt y = Lwt_stream.next st2;; val y : int = 1 <\/span>"}, "type": "'a Lwt_stream.t -> 'a Lwt_stream.t", "params": [{"name": "", "type": "'a Lwt_stream.t"}]}}, {"comment": "<h6>Destruction<\/h6>"}, {"value": {"name": "Lwt_stream.to_list", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_stream.mli|2492"}, "info": {"description": "Returns the list of elements of the given stream"}, "type": "'a Lwt_stream.t -> 'a list Lwt.t", "params": [{"name": "", "type": "'a Lwt_stream.t"}]}}, {"value": {"name": "Lwt_stream.to_string", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_stream.mli|2587"}, "info": {"description": "Returns the word composed of all characters of the given stream"}, "type": "char Lwt_stream.t -> string Lwt.t", "params": [{"name": "", "type": "char Lwt_stream.t"}]}}, {"comment": "<h6>Data retreival<\/h6>"}, {"exception": {"name": "Lwt_stream.Empty", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_stream.mli|2733"}, "info": {"description": "Exception raised when trying to retreive data from an empty stream."}}}, {"value": {"name": "Lwt_stream.peek", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_stream.mli|2833"}, "info": {"description": "<span class=\"code\" >peek st<\/span> returns the first element of the stream, if any, without removing it."}, "type": "'a Lwt_stream.t -> 'a option Lwt.t", "params": [{"name": "", "type": "'a Lwt_stream.t"}]}}, {"value": {"name": "Lwt_stream.npeek", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_stream.mli|2964"}, "info": {"description": "<span class=\"code\" >npeek n st<\/span> returns at most the first <span class=\"code\" >n<\/span> elements of <span class=\"code\" >st<\/span>, without removing them."}, "type": "int -> 'a Lwt_stream.t -> 'a list Lwt.t", "params": [{"name": "", "type": "int"}, {"name": "", "type": "'a Lwt_stream.t"}]}}, {"value": {"name": "Lwt_stream.get", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_stream.mli|3105"}, "info": {"description": "<span class=\"code\" >get st<\/span> remove and returns the first element of the stream, if any."}, "type": "'a Lwt_stream.t -> 'a option Lwt.t", "params": [{"name": "", "type": "'a Lwt_stream.t"}]}}, {"value": {"name": "Lwt_stream.nget", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_stream.mli|3224"}, "info": {"description": "<span class=\"code\" >nget n st<\/span> remove and returns at most the first <span class=\"code\" >n<\/span> elements of <span class=\"code\" >st<\/span>."}, "type": "int -> 'a Lwt_stream.t -> 'a list Lwt.t", "params": [{"name": "", "type": "int"}, {"name": "", "type": "'a Lwt_stream.t"}]}}, {"value": {"name": "Lwt_stream.get_while", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_stream.mli|3351"}, "info": "", "type": "('a -> bool) -> 'a Lwt_stream.t -> 'a list Lwt.t", "params": [{"name": "", "type": "'a -> bool"}, {"name": "", "type": "'a Lwt_stream.t"}]}}, {"value": {"name": "Lwt_stream.get_while_s", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_stream.mli|3405"}, "info": {"description": "<span class=\"code\" >get_while f st<\/span> returns the longest prefix of <span class=\"code\" >st<\/span> where all elements satisfy <span class=\"code\" >f<\/span>."}, "type": "('a -> bool Lwt.t) -> 'a Lwt_stream.t -> 'a list Lwt.t", "params": [{"name": "", "type": "'a -> bool Lwt.t"}, {"name": "", "type": "'a Lwt_stream.t"}]}}, {"value": {"name": "Lwt_stream.next", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_stream.mli|3567"}, "info": {"description": "<span class=\"code\" >next st<\/span> remove and returns the next element of the stream, of fail with <a href=\"{exception|Lwt_stream.Empty}\" ><span class=\"code\" >Lwt_stream.Empty<\/span><\/a> if the stream is empty."}, "type": "'a Lwt_stream.t -> 'a Lwt.t", "params": [{"name": "", "type": "'a Lwt_stream.t"}]}}, {"value": {"name": "Lwt_stream.last_new", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_stream.mli|3718"}, "info": {"description": "<span class=\"code\" >next_new st<\/span> if no element are available on <span class=\"code\" >st<\/span> without sleeping, then it is the same as <span class=\"code\" >next st<\/span>. Otherwise it removes all elements of <span class=\"code\" >st<\/span> that are ready except the last one, and return it.<br><\/br> If fails with <a href=\"{exception|Lwt_stream.Empty}\" ><span class=\"code\" >Lwt_stream.Empty<\/span><\/a> if the stream has no more elements"}, "type": "'a Lwt_stream.t -> 'a Lwt.t", "params": [{"name": "", "type": "'a Lwt_stream.t"}]}}, {"value": {"name": "Lwt_stream.junk", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_stream.mli|4038"}, "info": {"description": "<span class=\"code\" >junk st<\/span> remove the first element of <span class=\"code\" >st<\/span>."}, "type": "'a Lwt_stream.t -> unit Lwt.t", "params": [{"name": "", "type": "'a Lwt_stream.t"}]}}, {"value": {"name": "Lwt_stream.njunk", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_stream.mli|4122"}, "info": {"description": "<span class=\"code\" >njunk n st<\/span> removes at most the first <span class=\"code\" >n<\/span> elements of the stream."}, "type": "int -> 'a Lwt_stream.t -> unit Lwt.t", "params": [{"name": "", "type": "int"}, {"name": "", "type": "'a Lwt_stream.t"}]}}, {"value": {"name": "Lwt_stream.junk_while", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_stream.mli|4243"}, "info": "", "type": "('a -> bool) -> 'a Lwt_stream.t -> unit Lwt.t", "params": [{"name": "", "type": "'a -> bool"}, {"name": "", "type": "'a Lwt_stream.t"}]}}, {"value": {"name": "Lwt_stream.junk_while_s", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_stream.mli|4295"}, "info": {"description": "<span class=\"code\" >junk_while f st<\/span> removes all elements at the beginning of the streams which satisfy <span class=\"code\" >f<\/span>."}, "type": "('a -> bool Lwt.t) -> 'a Lwt_stream.t -> unit Lwt.t", "params": [{"name": "", "type": "'a -> bool Lwt.t"}, {"name": "", "type": "'a Lwt_stream.t"}]}}, {"value": {"name": "Lwt_stream.junk_old", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_stream.mli|4461"}, "info": {"description": "<span class=\"code\" >junk_old st<\/span> removes all elements that are ready to be read without yeilding from <span class=\"code\" >st<\/span>.<br><\/br> For example the <span class=\"code\" >read_password<\/span> function of <span class=\"code\" >Lwt_read_line<\/span> use that to junk key previously typed by the user."}, "type": "'a Lwt_stream.t -> unit Lwt.t", "params": [{"name": "", "type": "'a Lwt_stream.t"}]}}, {"value": {"name": "Lwt_stream.get_available", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_stream.mli|4726"}, "info": {"description": "<span class=\"code\" >get_available l<\/span> returns all available elements of <span class=\"code\" >l<\/span> without blocking"}, "type": "'a Lwt_stream.t -> 'a list", "params": [{"name": "", "type": "'a Lwt_stream.t"}]}}, {"value": {"name": "Lwt_stream.get_available_up_to", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_stream.mli|4851"}, "info": {"description": "<span class=\"code\" >get_available_up_to l n<\/span> returns up to <span class=\"code\" >n<\/span> elements of <span class=\"code\" >l<\/span> without blocking"}, "type": "int -> 'a Lwt_stream.t -> 'a list", "params": [{"name": "", "type": "int"}, {"name": "", "type": "'a Lwt_stream.t"}]}}, {"value": {"name": "Lwt_stream.is_empty", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_stream.mli|4993"}, "info": {"description": "<span class=\"code\" >is_empty enum<\/span> returns wether the given stream is empty"}, "type": "'a Lwt_stream.t -> bool Lwt.t", "params": [{"name": "", "type": "'a Lwt_stream.t"}]}}, {"comment": "<h6>Stream transversal<\/h6>"}, {"comment": "Note: all the following functions are destructive.<br><\/br> For example:<br><\/br> <span class=\"codepre\" > # let st1 = Lwt_stream.of_list [1; 2; 3];; val st1 : int Lwt_stream.t = &lt;abstr&gt; # let st2 = Lwt_stream.map string_of_int st1;; val st2 : string Lwt_stream.t = &lt;abstr&gt; # lwt x = Lwt_stream.next st1;; val x : int = 1 # lwt y = Lwt_stream.next st2;; val y : string = \"2\" <\/span>"}, {"value": {"name": "Lwt_stream.choose", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_stream.mli|5533"}, "info": {"description": "<span class=\"code\" >choose l<\/span> creates an stream from a list of streams. The resulting stream will returns elements returned by any stream of <span class=\"code\" >l<\/span> in an unspecified order."}, "type": "'a Lwt_stream.t list -> 'a Lwt_stream.t", "params": [{"name": "", "type": "'a Lwt_stream.t list"}]}}, {"value": {"name": "Lwt_stream.map", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_stream.mli|5737"}, "info": "", "type": "('a -> 'b) -> 'a Lwt_stream.t -> 'b Lwt_stream.t", "params": [{"name": "", "type": "'a -> 'b"}, {"name": "", "type": "'a Lwt_stream.t"}]}}, {"value": {"name": "Lwt_stream.map_s", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_stream.mli|5774"}, "info": {"description": "<span class=\"code\" >map f st<\/span> maps the value returned by <span class=\"code\" >st<\/span> with <span class=\"code\" >f<\/span>"}, "type": "('a -> 'b Lwt.t) -> 'a Lwt_stream.t -> 'b Lwt_stream.t", "params": [{"name": "", "type": "'a -> 'b Lwt.t"}, {"name": "", "type": "'a Lwt_stream.t"}]}}, {"value": {"name": "Lwt_stream.filter", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_stream.mli|5881"}, "info": "", "type": "('a -> bool) -> 'a Lwt_stream.t -> 'a Lwt_stream.t", "params": [{"name": "", "type": "'a -> bool"}, {"name": "", "type": "'a Lwt_stream.t"}]}}, {"value": {"name": "Lwt_stream.filter_s", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_stream.mli|5923"}, "info": {"description": "<span class=\"code\" >filter f st<\/span> keeps only value <span class=\"code\" >x<\/span> such that <span class=\"code\" >f x<\/span> is <span class=\"code\" >true<\/span>"}, "type": "('a -> bool Lwt.t) -> 'a Lwt_stream.t -> 'a Lwt_stream.t", "params": [{"name": "", "type": "'a -> bool Lwt.t"}, {"name": "", "type": "'a Lwt_stream.t"}]}}, {"value": {"name": "Lwt_stream.filter_map", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_stream.mli|6044"}, "info": "", "type": "('a -> 'b option) -> 'a Lwt_stream.t -> 'b Lwt_stream.t", "params": [{"name": "", "type": "'a -> 'b option"}, {"name": "", "type": "'a Lwt_stream.t"}]}}, {"value": {"name": "Lwt_stream.filter_map_s", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_stream.mli|6095"}, "info": {"description": "<span class=\"code\" >filter_map f st<\/span> filter and map <span class=\"code\" >st<\/span> at the same time"}, "type": "('a -> 'b option Lwt.t) -> 'a Lwt_stream.t -> 'b Lwt_stream.t", "params": [{"name": "", "type": "'a -> 'b option Lwt.t"}, {"name": "", "type": "'a Lwt_stream.t"}]}}, {"value": {"name": "Lwt_stream.map_list", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_stream.mli|6219"}, "info": "", "type": "('a -> 'b list) -> 'a Lwt_stream.t -> 'b Lwt_stream.t", "params": [{"name": "", "type": "'a -> 'b list"}, {"name": "", "type": "'a Lwt_stream.t"}]}}, {"value": {"name": "Lwt_stream.map_list_s", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_stream.mli|6266"}, "info": {"description": "<span class=\"code\" >map_list f st<\/span> applies <span class=\"code\" >f<\/span> on each element of <span class=\"code\" >st<\/span> and flattens the lists returned"}, "type": "('a -> 'b list Lwt.t) -> 'a Lwt_stream.t -> 'b Lwt_stream.t", "params": [{"name": "", "type": "'a -> 'b list Lwt.t"}, {"name": "", "type": "'a Lwt_stream.t"}]}}, {"value": {"name": "Lwt_stream.fold", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_stream.mli|6421"}, "info": "", "type": "('a -> 'b -> 'b) -> 'a Lwt_stream.t -> 'b -> 'b Lwt.t", "params": [{"name": "", "type": "'a -> 'b -> 'b"}, {"name": "", "type": "'a Lwt_stream.t"}, {"name": "", "type": "'a"}]}}, {"value": {"name": "Lwt_stream.fold_s", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_stream.mli|6475"}, "info": {"description": "<span class=\"code\" >fold f s x<\/span> fold_like function for streams."}, "type": "('a -> 'b -> 'b Lwt.t) -> 'a Lwt_stream.t -> 'b -> 'b Lwt.t", "params": [{"name": "", "type": "'a -> 'b -> 'b Lwt.t"}, {"name": "", "type": "'a Lwt_stream.t"}, {"name": "", "type": "'a"}]}}, {"value": {"name": "Lwt_stream.iter", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_stream.mli|6592"}, "info": "", "type": "('a -> unit) -> 'a Lwt_stream.t -> unit Lwt.t", "params": [{"name": "", "type": "'a -> unit"}, {"name": "", "type": "'a Lwt_stream.t"}]}}, {"value": {"name": "Lwt_stream.iter_p", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_stream.mli|6638"}, "info": "", "type": "('a -> unit Lwt.t) -> 'a Lwt_stream.t -> unit Lwt.t", "params": [{"name": "", "type": "'a -> unit Lwt.t"}, {"name": "", "type": "'a Lwt_stream.t"}]}}, {"value": {"name": "Lwt_stream.iter_s", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_stream.mli|6692"}, "info": {"description": "<span class=\"code\" >iter f s<\/span> iterates over all elements of the stream"}, "type": "('a -> unit Lwt.t) -> 'a Lwt_stream.t -> unit Lwt.t", "params": [{"name": "", "type": "'a -> unit Lwt.t"}, {"name": "", "type": "'a Lwt_stream.t"}]}}, {"value": {"name": "Lwt_stream.find", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_stream.mli|6808"}, "info": "", "type": "('a -> bool) -> 'a Lwt_stream.t -> 'a option Lwt.t", "params": [{"name": "", "type": "'a -> bool"}, {"name": "", "type": "'a Lwt_stream.t"}]}}, {"value": {"name": "Lwt_stream.find_s", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_stream.mli|6859"}, "info": {"description": "<span class=\"code\" >find f s<\/span> find an element in a stream."}, "type": "('a -> bool Lwt.t) -> 'a Lwt_stream.t -> 'a option Lwt.t", "params": [{"name": "", "type": "'a -> bool Lwt.t"}, {"name": "", "type": "'a Lwt_stream.t"}]}}, {"value": {"name": "Lwt_stream.find_map", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_stream.mli|6968"}, "info": "", "type": "('a -> 'b option) -> 'a Lwt_stream.t -> 'b option Lwt.t", "params": [{"name": "", "type": "'a -> 'b option"}, {"name": "", "type": "'a Lwt_stream.t"}]}}, {"value": {"name": "Lwt_stream.find_map_s", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_stream.mli|7028"}, "info": {"description": "<span class=\"code\" >find f s<\/span> find and map at the same time."}, "type": "('a -> 'b option Lwt.t) -> 'a Lwt_stream.t -> 'b option Lwt.t", "params": [{"name": "", "type": "'a -> 'b option Lwt.t"}, {"name": "", "type": "'a Lwt_stream.t"}]}}, {"value": {"name": "Lwt_stream.combine", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_stream.mli|7148"}, "info": {"description": "<span class=\"code\" >combine s1 s2<\/span> combine two streams. The stream will ends when the first stream ends."}, "type": "'a Lwt_stream.t -> 'b Lwt_stream.t -> ('a * 'b) Lwt_stream.t", "params": [{"name": "", "type": "'a Lwt_stream.t"}, {"name": "", "type": "'a Lwt_stream.t"}]}}, {"value": {"name": "Lwt_stream.append", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_stream.mli|7292"}, "info": {"description": "<span class=\"code\" >append s1 s2<\/span> returns a stream which returns all elements of <span class=\"code\" >s1<\/span>, then all elements of <span class=\"code\" >s2<\/span>"}, "type": "'a Lwt_stream.t -> 'a Lwt_stream.t -> 'a Lwt_stream.t", "params": [{"name": "", "type": "'a Lwt_stream.t"}, {"name": "", "type": "'a Lwt_stream.t"}]}}, {"value": {"name": "Lwt_stream.concat", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_stream.mli|7436"}, "info": {"description": "<span class=\"code\" >concat st<\/span> returns the concatenation of all streams of <span class=\"code\" >st<\/span>."}, "type": "'a Lwt_stream.t Lwt_stream.t -> 'a Lwt_stream.t", "params": [{"name": "", "type": "'a Lwt_stream.t Lwt_stream.t"}]}}, {"value": {"name": "Lwt_stream.flatten", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_stream.mli|7536"}, "info": {"description": "<span class=\"code\" >flatten st = map_list (fun l -&gt; l) st<\/span>"}, "type": "'a list Lwt_stream.t -> 'a Lwt_stream.t", "params": [{"name": "", "type": "'a list Lwt_stream.t"}]}}, {"comment": "<h6>Parsing<\/h6>"}, {"value": {"name": "Lwt_stream.parse", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_stream.mli|7638"}, "info": {"description": "<span class=\"code\" >parse st f<\/span> parses <span class=\"code\" >st<\/span> with <span class=\"code\" >f<\/span>. If <span class=\"code\" >f<\/span> raise an exception, <span class=\"code\" >st<\/span> is restored to its previous state."}, "type": "'a Lwt_stream.t -> ('a Lwt_stream.t -> 'b Lwt.t) -> 'b Lwt.t", "params": [{"name": "", "type": "'a Lwt_stream.t"}, {"name": "", "type": "'a Lwt_stream.t -> 'b Lwt.t"}]}}, {"comment": "<h6>Misc<\/h6>"}, {"value": {"name": "Lwt_stream.hexdump", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_stream.mli|7824"}, "info": {"description": "<span class=\"code\" >hexdump byte_stream<\/span> returns a stream which is the same as the output of <span class=\"code\" >hexdump -C<\/span>.<br><\/br> Basically, here is a simple implementation of <span class=\"code\" >hexdump -C<\/span>:<br><\/br> <span class=\"codepre\" > open Lwt open Lwt_io let () = Lwt_main.run (write_lines stdout (Lwt_stream.hexdump (read_lines stdin))) <\/span>"}, "type": "char Lwt_stream.t -> string Lwt_stream.t", "params": [{"name": "", "type": "char Lwt_stream.t"}]}}], "dependencies": {"uses": ["Lwt"], "used_by": ["Net", "Block", "Http"]}}}, "Lwt_sequence": {"module": {"name": "Lwt_sequence", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_sequence.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_sequence.mli|0"}, "info": {"description": "Mutable sequence of elements"}, "type": "sig  end", "module_structure": [{"comment": "A sequence is an object holding a list of elements which support the following operations:<br><\/br><ul><li>adding an element to the left or the right in time and space O(1)<\/li><li>taking an element from the left or the right in time and space O(1)<\/li><li>removing a previously added element from a sequence in time and space O(1)<\/li><li>removing an element while the sequence is being transversed.<\/li><\/ul>"}, {"type": {"name": "Lwt_sequence.t", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_sequence.mli|1389"}, "info": {"description": "Type of a sequence holding values of type <span class=\"code\" >'a<\/span>"}, "params": [{"covariant": "true", "contravariant": "true", "type": "'a"}], "kind": {"type": "abstract"}}}, {"type": {"name": "Lwt_sequence.node", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_sequence.mli|1456"}, "info": {"description": "Type of a node holding one value of type <span class=\"code\" >'a<\/span> in a sequence"}, "params": [{"covariant": "true", "contravariant": "true", "type": "'b"}], "kind": {"type": "abstract"}}}, {"comment": "<h6>Operation on nodes<\/h6>"}, {"value": {"name": "Lwt_sequence.get", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_sequence.mli|1566"}, "info": {"description": "Returns the contents of a node"}, "type": "'a Lwt_sequence.node -> 'a", "params": [{"name": "", "type": "'a Lwt_sequence.node"}]}}, {"value": {"name": "Lwt_sequence.set", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_sequence.mli|1631"}, "info": {"description": "Change the contents of a node"}, "type": "'a Lwt_sequence.node -> 'a -> unit", "params": [{"name": "", "type": "'a Lwt_sequence.node"}, {"name": "", "type": "'a"}]}}, {"value": {"name": "Lwt_sequence.remove", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_sequence.mli|1703"}, "info": {"description": "Removes a node from the sequence it is part of. It does nothing if the node has already been removed."}, "type": "'a Lwt_sequence.node -> unit", "params": [{"name": "", "type": "'a Lwt_sequence.node"}]}}, {"comment": "<h6>Operations on sequence<\/h6>"}, {"value": {"name": "Lwt_sequence.create", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_sequence.mli|1885"}, "info": {"description": "<span class=\"code\" >create ()<\/span> creates a new empty sequence"}, "type": "unit -> 'a Lwt_sequence.t", "params": [{"name": "", "type": "unit"}]}}, {"value": {"name": "Lwt_sequence.is_empty", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_sequence.mli|1962"}, "info": {"description": "Returns <span class=\"code\" >true<\/span> iff the given sequence is empty"}, "type": "'a Lwt_sequence.t -> bool", "params": [{"name": "", "type": "'a Lwt_sequence.t"}]}}, {"value": {"name": "Lwt_sequence.length", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_sequence.mli|2047"}, "info": {"description": "Returns the number of elemenets in the given sequence. This is a O(n) operation where <span class=\"code\" >n<\/span> is the number of elements in the sequence."}, "type": "'a Lwt_sequence.t -> int", "params": [{"name": "", "type": "'a Lwt_sequence.t"}]}}, {"value": {"name": "Lwt_sequence.add_l", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_sequence.mli|2227"}, "info": {"description": "<span class=\"code\" >add_l x s<\/span> adds <span class=\"code\" >x<\/span> to the left of the sequence <span class=\"code\" >s<\/span>"}, "type": "'a -> 'a Lwt_sequence.t -> 'a Lwt_sequence.node", "params": [{"name": "", "type": "'a"}, {"name": "", "type": "'a Lwt_sequence.t"}]}}, {"value": {"name": "Lwt_sequence.add_r", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_sequence.mli|2324"}, "info": {"description": "<span class=\"code\" >add_l x s<\/span> adds <span class=\"code\" >x<\/span> to the right of the sequence <span class=\"code\" >s<\/span>"}, "type": "'a -> 'a Lwt_sequence.t -> 'a Lwt_sequence.node", "params": [{"name": "", "type": "'a"}, {"name": "", "type": "'a Lwt_sequence.t"}]}}, {"exception": {"name": "Lwt_sequence.Empty", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_sequence.mli|2422"}, "info": {"description": "Exception raised by <span class=\"code\" >take_l<\/span> and <span class=\"code\" >tale_s<\/span> and when the sequence is empty"}}}, {"value": {"name": "Lwt_sequence.take_l", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_sequence.mli|2527"}, "info": {"description": "<span class=\"code\" >take_l x s<\/span> remove and returns the leftmost element of <span class=\"code\" >s<\/span>", "raised_exceptions": [{"raised_exception": "Empty", "text": "if the sequence is empty"}]}, "type": "'a Lwt_sequence.t -> 'a", "params": [{"name": "", "type": "'a Lwt_sequence.t"}]}}, {"value": {"name": "Lwt_sequence.take_r", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_sequence.mli|2666"}, "info": {"description": "<span class=\"code\" >take_l x s<\/span> remove and returns the rightmost element of <span class=\"code\" >s<\/span>", "raised_exceptions": [{"raised_exception": "Empty", "text": "if the sequence is empty"}]}, "type": "'a Lwt_sequence.t -> 'a", "params": [{"name": "", "type": "'a Lwt_sequence.t"}]}}, {"value": {"name": "Lwt_sequence.take_opt_l", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_sequence.mli|2806"}, "info": {"description": "<span class=\"code\" >take_opt_l x s<\/span> remove and returns <span class=\"code\" >Some x<\/span> where <span class=\"code\" >x<\/span> is the leftmost element of <span class=\"code\" >s<\/span> or <span class=\"code\" >None<\/span> if <span class=\"code\" >s<\/span> is empty"}, "type": "'a Lwt_sequence.t -> 'a option", "params": [{"name": "", "type": "'a Lwt_sequence.t"}]}}, {"value": {"name": "Lwt_sequence.take_opt_r", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_sequence.mli|2969"}, "info": {"description": "<span class=\"code\" >take_opt_l x s<\/span> remove and returns <span class=\"code\" >Some x<\/span> where <span class=\"code\" >x<\/span> is the rightmost element of <span class=\"code\" >s<\/span> or <span class=\"code\" >None<\/span> if <span class=\"code\" >s<\/span> is empty"}, "type": "'a Lwt_sequence.t -> 'a option", "params": [{"name": "", "type": "'a Lwt_sequence.t"}]}}, {"value": {"name": "Lwt_sequence.transfer_l", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_sequence.mli|3133"}, "info": {"description": "<span class=\"code\" >transfer_l s1 s2<\/span> removes all elements of <span class=\"code\" >s1<\/span> and add them at the left of <span class=\"code\" >s2<\/span>. This operation runs in constant time and space."}, "type": "'a Lwt_sequence.t -> 'a Lwt_sequence.t -> unit", "params": [{"name": "", "type": "'a Lwt_sequence.t"}, {"name": "", "type": "'a Lwt_sequence.t"}]}}, {"value": {"name": "Lwt_sequence.transfer_r", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_sequence.mli|3323"}, "info": {"description": "<span class=\"code\" >transfer_r s1 s2<\/span> removes all elements of <span class=\"code\" >s1<\/span> and add them at the right of <span class=\"code\" >s2<\/span>. This operation runs in constant time and space."}, "type": "'a Lwt_sequence.t -> 'a Lwt_sequence.t -> unit", "params": [{"name": "", "type": "'a Lwt_sequence.t"}, {"name": "", "type": "'a Lwt_sequence.t"}]}}, {"comment": "<h6>Sequence iterators<\/h6>"}, {"comment": "Note: it is OK to remove a node while traversing a sequence"}, {"value": {"name": "Lwt_sequence.iter_l", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_sequence.mli|3613"}, "info": {"description": "<span class=\"code\" >iter_l f s<\/span> applies <span class=\"code\" >f<\/span> on all elements of <span class=\"code\" >s<\/span> starting from the left"}, "type": "('a -> unit) -> 'a Lwt_sequence.t -> unit", "params": [{"name": "", "type": "'a -> unit"}, {"name": "", "type": "'a Lwt_sequence.t"}]}}, {"value": {"name": "Lwt_sequence.iter_r", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_sequence.mli|3742"}, "info": {"description": "<span class=\"code\" >iter_l f s<\/span> applies <span class=\"code\" >f<\/span> on all elements of <span class=\"code\" >s<\/span> starting from the right"}, "type": "('a -> unit) -> 'a Lwt_sequence.t -> unit", "params": [{"name": "", "type": "'a -> unit"}, {"name": "", "type": "'a Lwt_sequence.t"}]}}, {"value": {"name": "Lwt_sequence.iter_node_l", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_sequence.mli|3872"}, "info": {"description": "<span class=\"code\" >iter_l f s<\/span> applies <span class=\"code\" >f<\/span> on all nodes of <span class=\"code\" >s<\/span> starting from the left"}, "type": "('a Lwt_sequence.node -> unit) -> 'a Lwt_sequence.t -> unit", "params": [{"name": "", "type": "'a Lwt_sequence.node -> unit"}, {"name": "", "type": "'a Lwt_sequence.t"}]}}, {"value": {"name": "Lwt_sequence.iter_node_r", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_sequence.mli|4008"}, "info": {"description": "<span class=\"code\" >iter_l f s<\/span> applies <span class=\"code\" >f<\/span> on all nodes of <span class=\"code\" >s<\/span> starting from the right"}, "type": "('a Lwt_sequence.node -> unit) -> 'a Lwt_sequence.t -> unit", "params": [{"name": "", "type": "'a Lwt_sequence.node -> unit"}, {"name": "", "type": "'a Lwt_sequence.t"}]}}, {"value": {"name": "Lwt_sequence.fold_l", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_sequence.mli|4145"}, "info": {"description": "<span class=\"code\" >fold_l f s<\/span> is: <span class=\"codepre\" > fold_l f s x = f en (... (f e2 (f e1 x))) <\/span> where <span class=\"code\" >e1<\/span>, <span class=\"code\" >e2<\/span>, ..., <span class=\"code\" >en<\/span> are the elements of <span class=\"code\" >s<\/span>"}, "type": "('a -> 'b -> 'b) -> 'a Lwt_sequence.t -> 'b -> 'b", "params": [{"name": "", "type": "'a -> 'b -> 'b"}, {"name": "", "type": "'a Lwt_sequence.t"}, {"name": "", "type": "'a"}]}}, {"value": {"name": "Lwt_sequence.fold_r", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_sequence.mli|4350"}, "info": {"description": "<span class=\"code\" >fold_r f s<\/span> is: <span class=\"codepre\" > fold_r f s x = f e1 (f e2 (... (f en x))) <\/span> where <span class=\"code\" >e1<\/span>, <span class=\"code\" >e2<\/span>, ..., <span class=\"code\" >en<\/span> are the elements of <span class=\"code\" >s<\/span>"}, "type": "('a -> 'b -> 'b) -> 'a Lwt_sequence.t -> 'b -> 'b", "params": [{"name": "", "type": "'a -> 'b -> 'b"}, {"name": "", "type": "'a Lwt_sequence.t"}, {"name": "", "type": "'a"}]}}], "dependencies": {"uses": [], "used_by": []}}}, "Lwt_mvar": {"module": {"name": "Lwt_mvar", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_mvar.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_mvar.mli|0"}, "info": {"description": "Mailbox variables"}, "type": "sig  end", "module_structure": [{"comment": "\"Mailbox\" variables implement a synchronising variable, used for communication between concurrent threads.<br><\/br> This code adapted from <a href=\"http:\/\/eigenclass.org\/hiki.rb?cmd=view&amp;p=lightweight-threads-with-lwt\" >Comparing lightweight threads (eigenclass.org)<\/a>"}, {"type": {"name": "Lwt_mvar.t", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_mvar.mli|2032"}, "info": {"description": "The type of a mailbox variable. Mailbox variables are used to communicate values between threads in a synchronous way. The type parameter specifies the type of the value propagated from <span class=\"code\" >put<\/span> to <span class=\"code\" >take<\/span>."}, "params": [{"covariant": "true", "contravariant": "true", "type": "'b"}], "kind": {"type": "abstract"}}}, {"value": {"name": "Lwt_mvar.create", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_mvar.mli|2269"}, "info": {"description": "<span class=\"code\" >create v<\/span> creates a new mailbox variable containing value <span class=\"code\" >v<\/span>."}, "type": "'a -> 'a Lwt_mvar.t", "params": [{"name": "", "type": "'a"}]}}, {"value": {"name": "Lwt_mvar.create_empty", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_mvar.mli|2367"}, "info": {"description": "<span class=\"code\" >create ()<\/span> creates a new empty mailbox variable."}, "type": "unit -> 'a Lwt_mvar.t", "params": [{"name": "", "type": "unit"}]}}, {"value": {"name": "Lwt_mvar.put", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_mvar.mli|2459"}, "info": {"description": "<span class=\"code\" >put mvar value<\/span> puts a value into a mailbox variable. This value will remain in the mailbox until <span class=\"code\" >take<\/span> is called to remove it. If the mailbox is not empty, the current thread will block until it is emptied."}, "type": "'a Lwt_mvar.t -> 'a -> unit Lwt.t", "params": [{"name": "", "type": "'a Lwt_mvar.t"}, {"name": "", "type": "'a"}]}}, {"value": {"name": "Lwt_mvar.take", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_mvar.mli|2732"}, "info": {"description": "<span class=\"code\" >take mvar<\/span> will take any currently available value from the mailbox variable. If no value is currently available, the current thread will block, awaiting a value to be <span class=\"code\" >put<\/span> by another thread."}, "type": "'a Lwt_mvar.t -> 'a Lwt.t", "params": [{"name": "", "type": "'a Lwt_mvar.t"}]}}], "dependencies": {"uses": ["Lwt"], "used_by": []}}}, "Lwt_mutex": {"module": {"name": "Lwt_mutex", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_mutex.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_mutex.mli|0"}, "info": {"description": "Cooperative locks for mutual exclusion"}, "type": "sig  end", "module_structure": [{"type": {"name": "Lwt_mutex.t", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_mutex.mli|1054"}, "info": {"description": "Type of Lwt mutexes"}, "params": [], "kind": {"type": "abstract"}}}, {"value": {"name": "Lwt_mutex.create", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_mutex.mli|1086"}, "info": {"description": "<span class=\"code\" >create ()<\/span> creates a new mutex, which is initially unlocked"}, "type": "unit -> Lwt_mutex.t", "params": [{"name": "", "type": "unit"}]}}, {"value": {"name": "Lwt_mutex.lock", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_mutex.mli|1180"}, "info": {"description": "<span class=\"code\" >lock mutex<\/span> lockcs the mutex, that is:<br><\/br><ul><li>if the mutex is unlocked, then it is marked as locked and <a href=\"{value|Lwt_mutex.lock}\" ><span class=\"code\" >Lwt_mutex.lock<\/span><\/a> returns immediatly<\/li><\/ul><ul><li>if it is locked, then <a href=\"{value|Lwt_mutex.lock}\" ><span class=\"code\" >Lwt_mutex.lock<\/span><\/a> waits for all threads waiting on the mutex to terminate, then it resumes when the last one unlocks the mutex<\/li><\/ul> Note: threads are wake up is the same order they try to lock the mutex"}, "type": "Lwt_mutex.t -> unit Lwt.t", "params": [{"name": "", "type": "Lwt_mutex.t"}]}}, {"value": {"name": "Lwt_mutex.unlock", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_mutex.mli|1607"}, "info": {"description": "<span class=\"code\" >unlock mutex<\/span> unlock the mutex if no threads is waiting on it. Otherwise it removes the first one and resumes it."}, "type": "Lwt_mutex.t -> unit", "params": [{"name": "", "type": "Lwt_mutex.t"}]}}, {"value": {"name": "Lwt_mutex.is_locked", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_mutex.mli|1761"}, "info": {"description": "<span class=\"code\" >locked mutex<\/span> returns whether <span class=\"code\" >mutex<\/span> is currently locked"}, "type": "Lwt_mutex.t -> bool", "params": [{"name": "", "type": "Lwt_mutex.t"}]}}, {"value": {"name": "Lwt_mutex.is_empty", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_mutex.mli|1856"}, "info": {"description": "<span class=\"code\" >is_empty mutex<\/span> returns <span class=\"code\" >true<\/span> if they are no thread waiting on the mutex, and <span class=\"code\" >false<\/span> otherwise"}, "type": "Lwt_mutex.t -> bool", "params": [{"name": "", "type": "Lwt_mutex.t"}]}}, {"value": {"name": "Lwt_mutex.with_lock", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_mutex.mli|1995"}, "info": {"description": "<span class=\"code\" >with_lock lock f<\/span> is used to lock a mutex within a block scope. The function <span class=\"code\" >f ()<\/span> is called with the mutex locked, and its result is returned from the call to <div class=\"with\" >_lock<\/div>. If an exception is raised from f, the mutex is also unlocked before the scope of <div class=\"with\" >_lock<\/div> is exited."}, "type": "Lwt_mutex.t -> (unit -> 'a Lwt.t) -> 'a Lwt.t", "params": [{"name": "", "type": "Lwt_mutex.t"}, {"name": "", "type": "unit -> 'a Lwt.t"}]}}], "dependencies": {"uses": ["Lwt"], "used_by": ["Lwt_condition"]}}}, "Lwt_list": {"module": {"name": "Lwt_list", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_list.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_list.mli|0"}, "info": {"description": "List helpers"}, "type": "sig  end", "module_structure": [{"comment": "Note: this module use the same naming convention as <a href=\"{module|Lwt_stream}\" ><span class=\"code\" >Lwt_stream<\/span><\/a>."}, {"comment": "<h6>List iterators<\/h6>"}, {"value": {"name": "Lwt_list.iter_s", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_list.mli|1073"}, "info": "", "type": "('a -> unit Lwt.t) -> 'a list -> unit Lwt.t", "params": [{"name": "", "type": "'a -> unit Lwt.t"}, {"name": "", "type": "'a list"}]}}, {"value": {"name": "Lwt_list.iter_p", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_list.mli|1130"}, "info": "", "type": "('a -> unit Lwt.t) -> 'a list -> unit Lwt.t", "params": [{"name": "", "type": "'a -> unit Lwt.t"}, {"name": "", "type": "'a list"}]}}, {"value": {"name": "Lwt_list.map_s", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_list.mli|1188"}, "info": "", "type": "('a -> 'b Lwt.t) -> 'a list -> 'b list Lwt.t", "params": [{"name": "", "type": "'a -> 'b Lwt.t"}, {"name": "", "type": "'a list"}]}}, {"value": {"name": "Lwt_list.map_p", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_list.mli|1245"}, "info": "", "type": "('a -> 'b Lwt.t) -> 'a list -> 'b list Lwt.t", "params": [{"name": "", "type": "'a -> 'b Lwt.t"}, {"name": "", "type": "'a list"}]}}, {"value": {"name": "Lwt_list.rev_map_s", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_list.mli|1303"}, "info": "", "type": "('a -> 'b Lwt.t) -> 'a list -> 'b list Lwt.t", "params": [{"name": "", "type": "'a -> 'b Lwt.t"}, {"name": "", "type": "'a list"}]}}, {"value": {"name": "Lwt_list.rev_map_p", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_list.mli|1364"}, "info": "", "type": "('a -> 'b Lwt.t) -> 'a list -> 'b list Lwt.t", "params": [{"name": "", "type": "'a -> 'b Lwt.t"}, {"name": "", "type": "'a list"}]}}, {"value": {"name": "Lwt_list.fold_left_s", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_list.mli|1426"}, "info": "", "type": "('a -> 'b -> 'a Lwt.t) -> 'a -> 'b list -> 'a Lwt.t", "params": [{"name": "", "type": "'a -> 'b -> 'a Lwt.t"}, {"name": "", "type": "'a"}, {"name": "", "type": "'a list"}]}}, {"value": {"name": "Lwt_list.fold_right_s", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_list.mli|1497"}, "info": "", "type": "('a -> 'b -> 'b Lwt.t) -> 'a list -> 'b -> 'b Lwt.t", "params": [{"name": "", "type": "'a -> 'b -> 'b Lwt.t"}, {"name": "", "type": "'a list"}, {"name": "", "type": "'a"}]}}, {"comment": "<h6>List scanning<\/h6>"}, {"value": {"name": "Lwt_list.for_all_s", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_list.mli|1595"}, "info": "", "type": "('a -> bool Lwt.t) -> 'a list -> bool Lwt.t", "params": [{"name": "", "type": "'a -> bool Lwt.t"}, {"name": "", "type": "'a list"}]}}, {"value": {"name": "Lwt_list.for_all_p", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_list.mli|1655"}, "info": "", "type": "('a -> bool Lwt.t) -> 'a list -> bool Lwt.t", "params": [{"name": "", "type": "'a -> bool Lwt.t"}, {"name": "", "type": "'a list"}]}}, {"value": {"name": "Lwt_list.exists_s", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_list.mli|1716"}, "info": "", "type": "('a -> bool Lwt.t) -> 'a list -> bool Lwt.t", "params": [{"name": "", "type": "'a -> bool Lwt.t"}, {"name": "", "type": "'a list"}]}}, {"value": {"name": "Lwt_list.exists_p", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_list.mli|1775"}, "info": "", "type": "('a -> bool Lwt.t) -> 'a list -> bool Lwt.t", "params": [{"name": "", "type": "'a -> bool Lwt.t"}, {"name": "", "type": "'a list"}]}}, {"comment": "<h6>List searching<\/h6>"}, {"value": {"name": "Lwt_list.find_s", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_list.mli|1862"}, "info": "", "type": "('a -> bool Lwt.t) -> 'a list -> 'a Lwt.t", "params": [{"name": "", "type": "'a -> bool Lwt.t"}, {"name": "", "type": "'a list"}]}}, {"value": {"name": "Lwt_list.filter_s", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_list.mli|1918"}, "info": "", "type": "('a -> bool Lwt.t) -> 'a list -> 'a list Lwt.t", "params": [{"name": "", "type": "'a -> bool Lwt.t"}, {"name": "", "type": "'a list"}]}}, {"value": {"name": "Lwt_list.filter_p", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_list.mli|1980"}, "info": "", "type": "('a -> bool Lwt.t) -> 'a list -> 'a list Lwt.t", "params": [{"name": "", "type": "'a -> bool Lwt.t"}, {"name": "", "type": "'a list"}]}}, {"value": {"name": "Lwt_list.partition_s", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_list.mli|2043"}, "info": "", "type": "('a -> bool Lwt.t) -> 'a list -> ('a list * 'a list) Lwt.t", "params": [{"name": "", "type": "'a -> bool Lwt.t"}, {"name": "", "type": "'a list"}]}}, {"value": {"name": "Lwt_list.partition_p", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_list.mli|2120"}, "info": "", "type": "('a -> bool Lwt.t) -> 'a list -> ('a list * 'a list) Lwt.t", "params": [{"name": "", "type": "'a -> bool Lwt.t"}, {"name": "", "type": "'a list"}]}}], "dependencies": {"uses": ["Lwt"], "used_by": []}}}, "Lwt_pool": {"module": {"name": "Lwt_pool", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_pool.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_pool.mli|0"}, "info": {"description": "Creating pools (for example pools of connections to a database)."}, "type": "sig  end", "module_structure": [{"comment": "Instead of creating a new connection each time you need one, keep a pool of opened connections and reuse opened connections that are free."}, {"type": {"name": "Lwt_pool.t", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_pool.mli|1179"}, "info": {"description": "Type of pools"}, "params": [{"covariant": "true", "contravariant": "true", "type": "'b"}], "kind": {"type": "abstract"}}}, {"value": {"name": "Lwt_pool.create", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_pool.mli|1311"}, "info": {"description": "<span class=\"code\" >create n f<\/span> creates a new pool with at most <span class=\"code\" >n<\/span> members. <span class=\"code\" >f<\/span> is the function to use to create a new pool member."}, "type": "int ->\n  ?check:('a -> (bool -> unit) -> unit) -> (unit -> 'a Lwt.t) -> 'a Lwt_pool.t", "params": [{"name": "", "type": "int"}, {"name": "check", "type": "('a -> (bool -> unit) -> unit) option"}, {"name": "", "type": "unit -> 'a Lwt.t"}]}}, {"value": {"name": "Lwt_pool.use", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_pool.mli|1496"}, "info": {"description": "<span class=\"code\" >use p f<\/span> takes one free member of the pool <span class=\"code\" >p<\/span> and gives it to the function <span class=\"code\" >f<\/span>."}, "type": "'a Lwt_pool.t -> ('a -> 'b Lwt.t) -> 'b Lwt.t", "params": [{"name": "", "type": "'a Lwt_pool.t"}, {"name": "", "type": "'a -> 'b Lwt.t"}]}}], "dependencies": {"uses": ["Lwt", "*predef*"], "used_by": []}}}, "Lwt_condition": {"module": {"name": "Lwt_condition", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_condition.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_condition.mli|0"}, "info": {"description": "Conditions"}, "type": "sig  end", "module_structure": [{"comment": "Condition variables to synchronize between threads."}, {"type": {"name": "Lwt_condition.t", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_condition.mli|1771"}, "info": {"description": "Condition variable type. The type parameter denotes the type of value propagated from notifier to waiter."}, "params": [{"covariant": "true", "contravariant": "true", "type": "'c"}], "kind": {"type": "abstract"}}}, {"value": {"name": "Lwt_condition.create", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_condition.mli|1903"}, "info": {"description": "<span class=\"code\" >create ()<\/span> creates a new condition variable."}, "type": "unit -> 'a Lwt_condition.t", "params": [{"name": "", "type": "unit"}]}}, {"value": {"name": "Lwt_condition.wait", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_condition.mli|1987"}, "info": {"description": "<span class=\"code\" >wait mutex condvar<\/span> will cause the current thread to block, awaiting notification for a condition variable, <span class=\"code\" >condvar<\/span>. If provided, the <span class=\"code\" >mutex<\/span> must have been previously locked (within the scope of <span class=\"code\" >Lwt_mutex.with_lock<\/span>, for example) and is temporarily unlocked until the condition is notified. Upon notification, <span class=\"code\" >mutex<\/span> is re-locked before <span class=\"code\" >wait<\/span> returns and the thread's activity is resumed. When the awaited condition is notified, the value parameter passed to <span class=\"code\" >notify<\/span> is returned."}, "type": "?mutex:Lwt_mutex.t -> 'a Lwt_condition.t -> 'a Lwt.t", "params": [{"name": "mutex", "type": "Lwt_mutex.t option"}, {"name": "", "type": "'a Lwt_condition.t"}]}}, {"value": {"name": "Lwt_condition.signal", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_condition.mli|2601"}, "info": {"description": "<span class=\"code\" >signal condvar value<\/span> notifies that a condition is ready. A single waiting thread will be awoken and will receive the notification value which will be returned from <span class=\"code\" >wait<\/span>. Note that condition notification is not \"sticky\", i.e. if there is no waiter when <span class=\"code\" >notify<\/span> is called, the notification will be missed and the value discarded."}, "type": "'a Lwt_condition.t -> 'a -> unit", "params": [{"name": "", "type": "'a Lwt_condition.t"}, {"name": "", "type": "'a"}]}}, {"value": {"name": "Lwt_condition.broadcast", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_condition.mli|3018"}, "info": {"description": "<span class=\"code\" >broadcast condvar value<\/span> notifies all waiting threads. Each will be awoken in turn and will receive the same notification value."}, "type": "'a Lwt_condition.t -> 'a -> unit", "params": [{"name": "", "type": "'a Lwt_condition.t"}, {"name": "", "type": "'a"}]}}], "dependencies": {"uses": ["Lwt_mutex", "Lwt", "*predef*"], "used_by": []}}}, "Lwt_pqueue": {"module": {"name": "Lwt_pqueue", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_pqueue.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_pqueue.mli|0"}, "info": "", "type": "sig  end", "module_structure": [{"module_type": {"name": "Lwt_pqueue.OrderedType", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_pqueue.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_pqueue.mli|1003"}, "info": "", "type": "sig  end", "kind": ""}}, {"module_type": {"name": "Lwt_pqueue.S", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_pqueue.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_pqueue.mli|1084"}, "info": "", "type": "sig  end", "kind": ""}}, {"module": {"name": "Lwt_pqueue.Make", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_pqueue.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_pqueue.mli|1349"}, "info": "", "type": "functor (Ord : OrderedType) -> sig  end", "module_functor": {"parameter": {"name": "Ord"}, "module_with": "unavailable"}, "dependencies": {"uses": []}}}], "dependencies": {"uses": [], "used_by": []}}}, "Lwt_switch": {"module": {"name": "Lwt_switch", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_switch.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_switch.mli|0"}, "info": {"description": "Lwt switches"}, "type": "sig  end", "module_structure": [{"comment": "Switch have two goals:<br><\/br><ul><li>being able to free multiple resources at the same time,<\/li><li>offer a better alternative than always returning an id to free some resource.<\/li><\/ul> For example, considers the following interface:<br><\/br> <span class=\"codepre\" > type id val free : id -&gt; unit Lwt.t val f : unit -&gt; id Lwt.t val g : unit -&gt; id Lwt.t val h : unit -&gt; id Lwt.t <\/span><br><\/br> Now you want to calls <span class=\"code\" >f<\/span>, <span class=\"code\" >g<\/span> and <span class=\"code\" >h<\/span> in parallel. You can simply do:<br><\/br> <span class=\"codepre\" > lwt idf = f () and idg = g () and idh = h () in ... <\/span><br><\/br> However, one may wants to handle possible failures of <span class=\"code\" >f ()<\/span>, <span class=\"code\" >g ()<\/span> and <span class=\"code\" >h ()<\/span>, and disable all allocated resources if one of these three threads fails. This may be hard since you have to remember which one failed and which one returned correctly.<br><\/br> Now we change a little bit the interface:<br><\/br> <span class=\"codepre\" > val f : ?switch : Lwt_switch.t -&gt; unit -&gt; id Lwt.t val g : ?switch : Lwt_switch.t -&gt; unit -&gt; id Lwt.t val h : ?switch : Lwt_switch.t -&gt; unit -&gt; id Lwt.t <\/span><br><\/br> and the code becomes:<br><\/br> <span class=\"codepre\" > let switch = Lwt_switch.create () in try_lwt lwt idf = f ~switch () and idg = g ~switch () and idh = h ~switch () in ... with exn -&gt; lwt () = Lwt_switch.turn_off switch in raise_lwt exn <\/span>"}, {"type": {"name": "Lwt_switch.t", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_switch.mli|2306"}, "info": {"description": "Type of switches."}, "params": [], "kind": {"type": "abstract"}}}, {"value": {"name": "Lwt_switch.create", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_switch.mli|2336"}, "info": {"description": "<span class=\"code\" >create ()<\/span> creates a new switch."}, "type": "unit -> Lwt_switch.t", "params": [{"name": "", "type": "unit"}]}}, {"value": {"name": "Lwt_switch.is_on", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_switch.mli|2403"}, "info": {"description": "<span class=\"code\" >is_on switch<\/span> returns <span class=\"code\" >true<\/span> if the switch is currently on, and <span class=\"code\" >false<\/span> otherwise."}, "type": "Lwt_switch.t -> bool", "params": [{"name": "", "type": "Lwt_switch.t"}]}}, {"value": {"name": "Lwt_switch.turn_off", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_switch.mli|2525"}, "info": {"description": "<span class=\"code\" >turn_off switch<\/span> turns off the switch. It calls all registered hooks, waits for all of them to terminates, and the returns. If one of the hook failed, then it will fail with one of the exception raised by hooks. If the switch is already off, then it does nothing."}, "type": "Lwt_switch.t -> unit Lwt.t", "params": [{"name": "", "type": "Lwt_switch.t"}]}}, {"exception": {"name": "Lwt_switch.Off", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_switch.mli|2855"}, "info": {"description": "Exception raised when trying to add a hook to a switch that is already off."}}}, {"value": {"name": "Lwt_switch.check", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_switch.mli|2961"}, "info": {"description": "<span class=\"code\" >check switch<\/span> does nothing if <span class=\"code\" >switch<\/span> is <span class=\"code\" >None<\/span> or contains an switch that is currently on, and raise <a href=\"{exception|Lwt_switch.Off}\" ><span class=\"code\" >Lwt_switch.Off<\/span><\/a> otherwise."}, "type": "Lwt_switch.t option -> unit", "params": [{"name": "", "type": "Lwt_switch.t option"}]}}, {"value": {"name": "Lwt_switch.add_hook", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_switch.mli|3128"}, "info": {"description": "<span class=\"code\" >add_hook switch f<\/span> registers <span class=\"code\" >f<\/span> so it will be called when <a href=\"{value|Lwt_switch.turn_off}\" ><span class=\"code\" >Lwt_switch.turn_off<\/span><\/a> is invoked. It does nothing if <span class=\"code\" >switch<\/span> is <span class=\"code\" >None<\/span>. If <span class=\"code\" >switch<\/span> contains an switch that is already off then <a href=\"{exception|Lwt_switch.Off}\" ><span class=\"code\" >Lwt_switch.Off<\/span><\/a> is raised."}, "type": "Lwt_switch.t option -> (unit -> unit Lwt.t) -> unit", "params": [{"name": "", "type": "Lwt_switch.t option"}, {"name": "", "type": "unit -> unit Lwt.t"}]}}, {"value": {"name": "Lwt_switch.add_hook_or_exec", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/lwt_switch.mli|3409"}, "info": {"description": "<span class=\"code\" >add_hook_or_exec switch f<\/span> is the same as <a href=\"{value|Lwt_switch.add_hook}\" ><span class=\"code\" >Lwt_switch.add_hook<\/span><\/a> except that if the switch is already off, then <span class=\"code\" >f<\/span> is called immediatly."}, "type": "Lwt_switch.t option -> (unit -> unit Lwt.t) -> unit Lwt.t", "params": [{"name": "", "type": "Lwt_switch.t option"}, {"name": "", "type": "unit -> unit Lwt.t"}]}}], "dependencies": {"uses": ["Lwt"], "used_by": []}}}, "Regexp": {"module": {"name": "Regexp", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/regexp.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/regexp.mli|0"}, "info": {"description": "This module can be safely open for it only contains a module <span class=\"code\" >Re<\/span>. It provides regular expressions (AKA regexp, re) in pure OCaml. Although more efficient implementations exist, this one is the more portable: all of mirage backends can use it. It is based on Claude Marché's library. More information is available on the associated LICENSE file."}, "type": "sig  end", "module_structure": [{"module": {"name": "Regexp.Re", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/regexp.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/regexp.mli|367"}, "info": "", "type": "sig  end", "module_structure": [{"comment": "This module provides functions for creating and using Regular Expression.<br><\/br> It is in pure OCaml (unlike Pcre_Ocaml) and thus more portable. It is reentrant (unlike Str) but not thread-safe in case of preemptive schedulling."}, {"comment": "# Basic regexps."}, {"type": {"name": "Regexp.Re.regexp", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/regexp.mli|681"}, "info": {"description": "The type of regexps."}, "params": [], "kind": {"type": "abstract"}}}, {"comment": "## Regexp constructors."}, {"comment": "### Functional constructors."}, {"value": {"name": "Regexp.Re.empty", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/regexp.mli|804"}, "info": {"description": "The regexp denoting the absence of word."}, "type": "Regexp.Re.regexp", "params": []}}, {"value": {"name": "Regexp.Re.epsilon", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/regexp.mli|866"}, "info": {"description": "The regexp denoting the empty word."}, "type": "Regexp.Re.regexp", "params": []}}, {"value": {"name": "Regexp.Re.char", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/regexp.mli|933"}, "info": {"description": "The regexp matching a given character."}, "type": "char -> Regexp.Re.regexp", "params": [{"name": "", "type": "char"}]}}, {"value": {"name": "Regexp.Re.char_interv", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/regexp.mli|1041"}, "info": {"description": "The regexp matching any character in the given range. Bounds are included."}, "type": "char -> char -> Regexp.Re.regexp", "params": [{"name": "", "type": "char"}, {"name": "", "type": "char"}]}}, {"value": {"name": "Regexp.Re.string", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/regexp.mli|1133"}, "info": {"description": "The regexp matching the exact given string."}, "type": "string -> Regexp.Re.regexp", "params": [{"name": "", "type": "string"}]}}, {"value": {"name": "Regexp.Re.star", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/regexp.mli|1239"}, "info": {"description": "The regexp matching 0 or more words recognized by the given regexp."}, "type": "Regexp.Re.regexp -> Regexp.Re.regexp", "params": [{"name": "", "type": "Regexp.Re.regexp"}]}}, {"value": {"name": "Regexp.Re.alt", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/regexp.mli|1344"}, "info": {"description": "The regexp matching words matched by either one of the given regexps."}, "type": "Regexp.Re.regexp -> Regexp.Re.regexp -> Regexp.Re.regexp", "params": [{"name": "", "type": "Regexp.Re.regexp"}, {"name": "", "type": "Regexp.Re.regexp"}]}}, {"value": {"name": "Regexp.Re.seq", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/regexp.mli|1485"}, "info": {"description": "The regexp matching the concatenation of two words matched by each one of the given regexps."}, "type": "Regexp.Re.regexp -> Regexp.Re.regexp -> Regexp.Re.regexp", "params": [{"name": "", "type": "Regexp.Re.regexp"}, {"name": "", "type": "Regexp.Re.regexp"}]}}, {"value": {"name": "Regexp.Re.opt", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/regexp.mli|1590"}, "info": {"description": "The regexp matching 0 or 1 word matched by the given regexp."}, "type": "Regexp.Re.regexp -> Regexp.Re.regexp", "params": [{"name": "", "type": "Regexp.Re.regexp"}]}}, {"value": {"name": "Regexp.Re.some", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/regexp.mli|1689"}, "info": {"description": "The regexp matching 1 or more words matched by the given regexp."}, "type": "Regexp.Re.regexp -> Regexp.Re.regexp", "params": [{"name": "", "type": "Regexp.Re.regexp"}]}}, {"comment": "### Parsing constructor."}, {"value": {"name": "Regexp.Re.from_string_raw", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/regexp.mli|3518"}, "info": {"description": "<span class=\"code\" >from_string_raw s<\/span> parses the string <span class=\"code\" >s<\/span> and returns the associated regexp.<br><\/br> ________________________________________________________________ |                                                              | | The following constructions can be used in the string <span class=\"code\" >s<\/span>:   | |______________________________________________________________|_______________________________________________ | char             |   denotes the character char for all non-special chars                                    | | \\char            |   denotes the character char for special characters ., \\, *, +, ?, |, <span class=\"code\" >, <\/span>, ( and )       | | <span class=\"code\" >set<\/span>            |   denotes any single-character word belonging to set. Intervals may be given as in <span class=\"code\" >a-z<\/span>. | | <span class=\"code\" >^set<\/span>           |   denotes any single-character word not belonging to set.                                 | | .                |   denotes any single-character word (complete set of characters)                          | | regexp*          |   denotes the Kleene star of regexp                                                       | | regexp+          |   denotes any concatenation of one or more words of regexp                                | | regexp?          |   denotes the empty word or any word denoted by regexp                                    | | regexp1|regexp2  |   denotes any words in regexp1 or in regexp2                                              | | regexp1regexp2   |   denotes any contecatenation of a word of regexp1 and a word of regexp2                  | | (regexp)         |   parentheses, denotes the same words as regexp.                                          | |__________________|___________________________________________________________________________________________|"}, "type": "string -> Regexp.Re.regexp", "params": [{"name": "", "type": "string"}]}}, {"comment": "# Regexp compilation."}, {"comment": "In order to improve the efficiency of regexps, they are compiled to a different internal representation."}, {"type": {"name": "Regexp.Re.compiled_regexp", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/regexp.mli|3748"}, "info": {"description": "The type of compiled regexps."}, "params": [], "kind": {"type": "abstract"}}}, {"comment": "## Constructors for compiled regexps."}, {"value": {"name": "Regexp.Re.compile", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/regexp.mli|3857"}, "info": {"description": "<span class=\"code\" >compile re<\/span> compiles the regexp <span class=\"code\" >re<\/span>."}, "type": "Regexp.Re.regexp -> Regexp.Re.compiled_regexp", "params": [{"name": "", "type": "Regexp.Re.regexp"}]}}, {"value": {"name": "Regexp.Re.from_string", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/regexp.mli|3955"}, "info": {"description": "<span class=\"code\" >from_string s<\/span> is <span class=\"code\" >compile (from_string_raw s)<\/span>."}, "type": "string -> Regexp.Re.compiled_regexp", "params": [{"name": "", "type": "string"}]}}, {"comment": "# Regexp usage."}, {"value": {"name": "Regexp.Re.search_forward", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/regexp.mli|4465"}, "info": {"description": "<span class=\"code\" >search_forward cre s i<\/span> evaluates either to <span class=\"code\" >Some (b, e)<\/span> is <span class=\"code\" >String.sub s b (e - b)<\/span> is matched by <span class=\"code\" >cre<\/span> (with <span class=\"code\" >b &gt;= i<\/span> or <span class=\"code\" >None<\/span> if no such tuple exists). In other words, <span class=\"code\" >(e, b)<\/span> are the inclusive beginning and exclusive ending offset of a word of <span class=\"code\" >s<\/span> starting from <span class=\"code\" >i<\/span> matched by <span class=\"code\" >cre<\/span>. <span class=\"code\" >(b,e)<\/span> is such that <span class=\"code\" >b<\/span> is minimal among all the possible values and <span class=\"code\" >e<\/span> is maximal for the given <span class=\"code\" >b<\/span> (greediness)."}, "type": "Regexp.Re.compiled_regexp -> string -> int -> (int * int) option", "params": [{"name": "", "type": "Regexp.Re.compiled_regexp"}, {"name": "", "type": "string"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Regexp.Re.match_string", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/regexp.mli|4708"}, "info": {"description": "<span class=\"code\" >match_string cre s i<\/span> evaluates to either <span class=\"code\" >Some e<\/span> if <span class=\"code\" >String.sub s i (e - i)<\/span> is matched by <span class=\"code\" >cre<\/span> or <span class=\"code\" >None<\/span> if no such <span class=\"code\" >e<\/span> exists. Matching is greedy."}, "type": "Regexp.Re.compiled_regexp -> string -> int -> int option", "params": [{"name": "", "type": "Regexp.Re.compiled_regexp"}, {"name": "", "type": "string"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Regexp.Re.list_matches", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/regexp.mli|4973"}, "info": {"description": "<span class=\"code\" >list_matches cre s<\/span> evaluates to a list of strings in which each element is a sub-string of <span class=\"code\" >s<\/span> matched by <span class=\"code\" >cre<\/span>. None of the sub-string overlap. Moreover, they are of maximal size."}, "type": "Regexp.Re.compiled_regexp -> string -> string list", "params": [{"name": "", "type": "Regexp.Re.compiled_regexp"}, {"name": "", "type": "string"}]}}, {"value": {"name": "Regexp.Re.split_delim", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/regexp.mli|5267"}, "info": {"description": "<span class=\"code\" >split_delim cre s<\/span> evaluates to a list of string in which each element is a sub-string of the original one. Each two consecutive elements of the list of sub-string was, in <span class=\"code\" >s<\/span>, separated by a word matched by <span class=\"code\" >cre<\/span>."}, "type": "Regexp.Re.compiled_regexp -> string -> string list", "params": [{"name": "", "type": "Regexp.Re.compiled_regexp"}, {"name": "", "type": "string"}]}}, {"value": {"name": "Regexp.Re.replace", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/regexp.mli|5406"}, "info": {"description": "<span class=\"code\" >replace cre s by<\/span> replaces sub-strings of <span class=\"code\" >s<\/span> matched by <span class=\"code\" >cre<\/span> by <span class=\"code\" >by<\/span>."}, "type": "Regexp.Re.compiled_regexp -> string -> string -> string", "params": [{"name": "", "type": "Regexp.Re.compiled_regexp"}, {"name": "", "type": "string"}, {"name": "", "type": "string"}]}}, {"value": {"name": "Regexp.Re.substitute", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/regexp.mli|5591"}, "info": {"description": "<span class=\"code\" >substitute cre s map<\/span> substitutes sub-strings of <span class=\"code\" >s<\/span> matched by <span class=\"code\" >cre<\/span> by <span class=\"code\" >map w<\/span> where <span class=\"code\" >w<\/span> is the matched word."}, "type": "Regexp.Re.compiled_regexp -> string -> (string -> string) -> string", "params": [{"name": "", "type": "Regexp.Re.compiled_regexp"}, {"name": "", "type": "string"}, {"name": "", "type": "string -> string"}]}}], "dependencies": {"uses": []}}}], "dependencies": {"uses": [], "used_by": []}}}, "OS": {"module": {"name": "OS", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/oS.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/oS.mli|0"}, "info": {"description": "Operating System interfaces for UNIX"}, "type": "sig  end", "module_structure": [{"module": {"name": "OS.Activations", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/oS.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/oS.mli|45"}, "info": "", "type": "sig  end", "module_structure": [{"comment": "Activations provides an interface to wait for a file descriptor to become available for either reading or writing"}, {"type": {"name": "OS.Activations.fd", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/oS.mli|226"}, "info": {"description": "File descriptor"}, "params": [], "kind": {"type": "abstract"}, "manifest": "int"}}, {"value": {"name": "OS.Activations.read", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/oS.mli|401"}, "info": {"description": "Wait for the file descriptor to become ready for reading", "return": "a thread that blocks until the <span class=\"code\" >fd<\/span> is ready for reading"}, "type": "OS.Activations.fd -> unit Lwt.t", "params": [{"name": "", "type": "OS.Activations.fd"}]}}, {"value": {"name": "OS.Activations.write", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/oS.mli|594"}, "info": {"description": "Wait for the file descriptor to become ready for writing", "return": "a thread that blocks until the <span class=\"code\" >fd<\/span> is ready for writing"}, "type": "OS.Activations.fd -> unit Lwt.t", "params": [{"name": "", "type": "OS.Activations.fd"}]}}], "dependencies": {"uses": []}}}, {"module": {"name": "OS.Clock", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/oS.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/oS.mli|626"}, "info": "", "type": "sig  end", "module_structure": [{"comment": "Clock operations. Currently read-only to retrieve the time in various formats."}, {"type": {"name": "OS.Clock.tm", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/oS.mli|743"}, "info": "", "params": [], "kind": {"type": "record", "private": "false", "fields": [{"name": "tm_sec", "mutable": false, "description": "Seconds 0..60", "type": "int"}, {"name": "tm_min", "mutable": false, "description": "Minutes 0..59", "type": "int"}, {"name": "tm_hour", "mutable": false, "description": "Hours 0..23", "type": "int"}, {"name": "tm_mday", "mutable": false, "description": "Day of month 1..31", "type": "int"}, {"name": "tm_mon", "mutable": false, "description": "Month of year 0..11", "type": "int"}, {"name": "tm_year", "mutable": false, "description": "Year - 1900", "type": "int"}, {"name": "tm_wday", "mutable": false, "description": "Day of week (Sunday is 0)", "type": "int"}, {"name": "tm_yday", "mutable": false, "description": "Day of year 0..365", "type": "int"}, {"name": "tm_isdst", "mutable": false, "description": "Daylight time savings in effect", "type": "bool"}]}}}, {"value": {"name": "OS.Clock.time", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/oS.mli|1272"}, "info": {"description": "Return the current time since 00:00:00 GMT, Jan. 1, 1970, in seconds."}, "type": "unit -> float", "params": [{"name": "", "type": "unit"}]}}, {"value": {"name": "OS.Clock.gmtime", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/oS.mli|1402"}, "info": {"description": "Convert a time in seconds, as returned by <a href=\"{value|OS.Clock.time}\" ><span class=\"code\" >OS.Clock.time<\/span><\/a>, into a date and a time. Assumes UTC (Coordinated Universal Time), also known as GMT."}, "type": "float -> OS.Clock.tm", "params": [{"name": "", "type": "float"}]}}], "dependencies": {"uses": []}}}, {"module": {"name": "OS.Time", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/oS.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/oS.mli|1607"}, "info": "", "type": "sig  end", "module_structure": [{"value": {"name": "OS.Time.restart_threads", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/oS.mli|1627"}, "info": "", "type": "(unit -> float) -> unit", "params": [{"name": "", "type": "unit -> float"}]}}, {"value": {"name": "OS.Time.select_next", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/oS.mli|1672"}, "info": "", "type": "(unit -> float) -> float option", "params": [{"name": "", "type": "unit -> float"}]}}, {"value": {"name": "OS.Time.sleep", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/oS.mli|1722"}, "info": "", "type": "float -> unit Lwt.t", "params": [{"name": "", "type": "float"}]}}], "dependencies": {"uses": []}}}, {"module": {"name": "OS.Console", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/oS.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/oS.mli|1758"}, "info": "", "type": "sig  end", "module_structure": [{"comment": "Text console input\/output operations."}, {"type": {"name": "OS.Console.t", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/oS.mli|1875"}, "info": {"description": "Abstract type of a console instance"}, "params": [], "kind": {"type": "abstract"}}}, {"value": {"name": "OS.Console.t", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/oS.mli|1945"}, "info": {"description": "The default console, attached from the start of the program"}, "type": "OS.Console.t", "params": []}}, {"value": {"name": "OS.Console.create", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/oS.mli|2014"}, "info": {"description": "Create an additional console. Not implemented yet."}, "type": "unit -> OS.Console.t", "params": [{"name": "", "type": "unit"}]}}, {"value": {"name": "OS.Console.write", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/oS.mli|2094"}, "info": {"description": "Write a string with offset\/length to the console"}, "type": "OS.Console.t -> string -> int -> int -> unit", "params": [{"name": "", "type": "OS.Console.t"}, {"name": "", "type": "string"}, {"name": "", "type": "int"}, {"name": "", "type": "int"}]}}, {"value": {"name": "OS.Console.sync_write", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/oS.mli|2217"}, "info": {"description": "Same as <a href=\"{value|OS.Console.write}\" ><span class=\"code\" >OS.Console.write<\/span><\/a> except that the operation is synchronous"}, "type": "OS.Console.t -> string -> int -> int -> unit Lwt.t", "params": [{"name": "", "type": "OS.Console.t"}, {"name": "", "type": "string"}, {"name": "", "type": "int"}, {"name": "", "type": "int"}]}}, {"value": {"name": "OS.Console.log", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/oS.mli|2275"}, "info": "", "type": "string -> unit", "params": [{"name": "", "type": "string"}]}}, {"value": {"name": "OS.Console.log_s", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/oS.mli|2301"}, "info": "", "type": "string -> unit Lwt.t", "params": [{"name": "", "type": "string"}]}}], "dependencies": {"uses": []}}}, {"module": {"name": "OS.Netif", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/oS.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/oS.mli|2338"}, "info": "", "type": "sig  end", "module_structure": [{"type": {"name": "OS.Netif.t", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/oS.mli|2364"}, "info": "", "params": [], "kind": {"type": "abstract"}}}, {"type": {"name": "OS.Netif.id", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/oS.mli|2371"}, "info": "", "params": [], "kind": {"type": "abstract"}}}, {"value": {"name": "OS.Netif.create", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/oS.mli|2374"}, "info": "", "type": "OS.Netif.id -> OS.Netif.t Lwt.t", "params": [{"name": "", "type": "OS.Netif.id"}]}}, {"value": {"name": "OS.Netif.listen", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/oS.mli|2401"}, "info": "", "type": "OS.Netif.t -> (Bitstring.t -> unit Lwt.t) -> unit Lwt.t", "params": [{"name": "", "type": "OS.Netif.t"}, {"name": "", "type": "Bitstring.t -> unit Lwt.t"}]}}, {"value": {"name": "OS.Netif.destroy", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/oS.mli|2461"}, "info": "", "type": "OS.Netif.t -> unit Lwt.t", "params": [{"name": "", "type": "OS.Netif.t"}]}}, {"value": {"name": "OS.Netif.output", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/oS.mli|2491"}, "info": "", "type": "OS.Netif.t -> Bitstring.t list -> unit Lwt.t", "params": [{"name": "", "type": "OS.Netif.t"}, {"name": "", "type": "Bitstring.t list"}]}}, {"value": {"name": "OS.Netif.enumerate", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/oS.mli|2540"}, "info": "", "type": "unit -> OS.Netif.id list Lwt.t", "params": [{"name": "", "type": "unit"}]}}, {"value": {"name": "OS.Netif.mac", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/oS.mli|2578"}, "info": "", "type": "OS.Netif.t -> string", "params": [{"name": "", "type": "OS.Netif.t"}]}}, {"value": {"name": "OS.Netif.string_of_id", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/oS.mli|2600"}, "info": "", "type": "OS.Netif.id -> string", "params": [{"name": "", "type": "OS.Netif.id"}]}}], "dependencies": {"uses": []}}}, {"module": {"name": "OS.Main", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/oS.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/oS.mli|2636"}, "info": "", "type": "sig  end", "module_structure": [{"value": {"name": "OS.Main.run", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/oS.mli|2656"}, "info": "", "type": "unit Lwt.t -> unit", "params": [{"name": "", "type": "unit Lwt.t"}]}}, {"value": {"name": "OS.Main.set_control_thread", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/oS.mli|2685"}, "info": "", "type": "unit Lwt.t -> unit", "params": [{"name": "", "type": "unit Lwt.t"}]}}], "dependencies": {"uses": []}}}, {"module": {"name": "OS.Blkif", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/oS.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/oS.mli|2732"}, "info": "", "type": "sig  end", "module_structure": [{"comment": "Dummy Block module, not implemented yet"}, {"type": {"name": "OS.Blkif.t", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/oS.mli|2806"}, "info": "", "params": [], "kind": {"type": "abstract"}}}, {"type": {"name": "OS.Blkif.id", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/oS.mli|2813"}, "info": "", "params": [], "kind": {"type": "abstract"}}}, {"value": {"name": "OS.Blkif.enumerate", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/oS.mli|2817"}, "info": "", "type": "unit -> OS.Blkif.id list Lwt.t", "params": [{"name": "", "type": "unit"}]}}, {"value": {"name": "OS.Blkif.create", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/oS.mli|2854"}, "info": "", "type": "OS.Blkif.id -> (OS.Blkif.t * unit Lwt.t) Lwt.t", "params": [{"name": "", "type": "OS.Blkif.id"}]}}], "dependencies": {"uses": []}}}], "dependencies": {"uses": ["Lwt", "Bitstring"], "used_by": ["Block"]}}}, "Net": {"module": {"name": "Net", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|0"}, "info": "", "type": "sig  end", "module_structure": [{"module": {"name": "Net.Nettypes", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|0"}, "info": "", "type": "sig  end", "module_structure": [{"type": {"name": "Net.Nettypes.bytes", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|29"}, "info": "", "params": [], "kind": {"type": "abstract"}, "manifest": "string"}}, {"type": {"name": "Net.Nettypes.ethernet_mac", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|50"}, "info": "", "params": [], "kind": {"type": "abstract"}}}, {"value": {"name": "Net.Nettypes.ethernet_mac_of_bytes", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|63"}, "info": "", "type": "string -> Net.Nettypes.ethernet_mac", "params": [{"name": "", "type": "string"}]}}, {"value": {"name": "Net.Nettypes.ethernet_mac_of_string", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|114"}, "info": "", "type": "string -> Net.Nettypes.ethernet_mac option", "params": [{"name": "", "type": "string"}]}}, {"value": {"name": "Net.Nettypes.ethernet_mac_to_bytes", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|173"}, "info": "", "type": "Net.Nettypes.ethernet_mac -> Net.Nettypes.bytes", "params": [{"name": "", "type": "Net.Nettypes.ethernet_mac"}]}}, {"value": {"name": "Net.Nettypes.ethernet_mac_to_string", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|223"}, "info": "", "type": "Net.Nettypes.ethernet_mac -> string", "params": [{"name": "", "type": "Net.Nettypes.ethernet_mac"}]}}, {"value": {"name": "Net.Nettypes.ethernet_mac_broadcast", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|275"}, "info": "", "type": "Net.Nettypes.ethernet_mac", "params": []}}, {"type": {"name": "Net.Nettypes.ipv4_addr", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|322"}, "info": "", "params": [], "kind": {"type": "abstract"}}}, {"value": {"name": "Net.Nettypes.ipv4_addr_of_tuple", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|332"}, "info": "", "type": "int32 * int32 * int32 * int32 -> Net.Nettypes.ipv4_addr", "params": [{"tuple": {"type": "int32 * int32 * int32 * int32", "contents": [{"name": "", "type": "int32"}, {"name": "", "type": "int32"}, {"name": "", "type": "int32"}, {"name": "", "type": "int32"}]}}]}}, {"value": {"name": "Net.Nettypes.ipv4_addr_of_string", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|402"}, "info": "", "type": "string -> Net.Nettypes.ipv4_addr option", "params": [{"name": "", "type": "string"}]}}, {"value": {"name": "Net.Nettypes.ipv4_addr_to_string", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|455"}, "info": "", "type": "Net.Nettypes.ipv4_addr -> string", "params": [{"name": "", "type": "Net.Nettypes.ipv4_addr"}]}}, {"value": {"name": "Net.Nettypes.ipv4_addr_of_uint32", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|501"}, "info": "", "type": "int32 -> Net.Nettypes.ipv4_addr", "params": [{"name": "", "type": "int32"}]}}, {"value": {"name": "Net.Nettypes.ipv4_addr_to_uint32", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|546"}, "info": "", "type": "Net.Nettypes.ipv4_addr -> int32", "params": [{"name": "", "type": "Net.Nettypes.ipv4_addr"}]}}, {"value": {"name": "Net.Nettypes.ipv4_blank", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|591"}, "info": "", "type": "Net.Nettypes.ipv4_addr", "params": []}}, {"value": {"name": "Net.Nettypes.ipv4_broadcast", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|618"}, "info": "", "type": "Net.Nettypes.ipv4_addr", "params": []}}, {"value": {"name": "Net.Nettypes.ipv4_localhost", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|649"}, "info": "", "type": "Net.Nettypes.ipv4_addr", "params": []}}, {"type": {"name": "Net.Nettypes.ipv4_src", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|686"}, "info": "", "params": [], "kind": {"type": "abstract"}, "manifest": "Net.Nettypes.ipv4_addr option * int"}}, {"type": {"name": "Net.Nettypes.ipv4_dst", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|725"}, "info": "", "params": [], "kind": {"type": "abstract"}, "manifest": "Net.Nettypes.ipv4_addr * int"}}, {"type": {"name": "Net.Nettypes.arp", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|758"}, "info": "", "params": [], "kind": {"type": "record", "private": "false", "fields": [{"name": "op", "mutable": false, "type": "[ `Reply | `Request | `Unknown of int ]"}, {"name": "sha", "mutable": false, "type": "Net.Nettypes.ethernet_mac"}, {"name": "spa", "mutable": false, "type": "Net.Nettypes.ipv4_addr"}, {"name": "tha", "mutable": false, "type": "Net.Nettypes.ethernet_mac"}, {"name": "tpa", "mutable": false, "type": "Net.Nettypes.ipv4_addr"}]}}}, {"type": {"name": "Net.Nettypes.peer_uid", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|897"}, "info": "", "params": [], "kind": {"type": "abstract"}, "manifest": "int"}}, {"exception": {"name": "Net.Nettypes.Closed", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|913"}, "info": ""}}, {"module_type": {"name": "Net.Nettypes.FLOW", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|931"}, "info": "", "type": "sig  end", "kind": ""}}, {"module_type": {"name": "Net.Nettypes.DATAGRAM", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|1318"}, "info": "", "type": "sig  end", "kind": ""}}, {"module_type": {"name": "Net.Nettypes.CHANNEL", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|1522"}, "info": "", "type": "sig  end", "kind": ""}}, {"module_type": {"name": "Net.Nettypes.RPC", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|2233"}, "info": "", "type": "sig  end", "kind": ""}}], "dependencies": {"uses": []}}}, {"module": {"name": "Net.Manager", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|2490"}, "info": "", "type": "sig  end", "module_structure": [{"exception": {"name": "Net.Manager.Error", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|2513"}, "info": "", "exception_args": ["string"]}}, {"module": {"name": "Net.Manager.Unix", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|2539"}, "info": "", "type": "sig  end", "module_structure": [{"type": {"name": "Net.Manager.Unix.ipv4", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|2568"}, "info": "", "params": [], "kind": {"type": "abstract"}, "manifest": "int32"}}, {"type": {"name": "Net.Manager.Unix.port", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|2590"}, "info": "", "params": [], "kind": {"type": "abstract"}, "manifest": "int"}}, {"type": {"name": "Net.Manager.Unix.uid", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|2610"}, "info": "", "params": [], "kind": {"type": "abstract"}, "manifest": "int"}}, {"type": {"name": "Net.Manager.Unix.fd", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|2628"}, "info": "", "params": [{"covariant": "true", "contravariant": "true", "type": "'a"}], "kind": {"type": "abstract"}}}, {"type": {"name": "Net.Manager.Unix.resp", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|2643"}, "info": "", "params": [{"covariant": "true", "contravariant": "false", "type": "'b"}], "kind": {"type": "variant", "private": "false", "constructors": [{"name": "OK", "type": ["'a"]}, {"name": "Err", "type": ["string"]}, {"name": "Retry", "type": []}]}}}, {"value": {"name": "Net.Manager.Unix.tcpv4_connect", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|2691"}, "info": "", "type": "Net.Manager.Unix.ipv4 ->\n  Net.Manager.Unix.port -> [ `tcpv4 ] Net.Manager.Unix.fd Net.Manager.Unix.resp", "params": [{"name": "", "type": "Net.Manager.Unix.ipv4"}, {"name": "", "type": "Net.Manager.Unix.port"}]}}, {"value": {"name": "Net.Manager.Unix.tcpv4_bind", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|2778"}, "info": "", "type": "Net.Manager.Unix.ipv4 ->\n  Net.Manager.Unix.port -> [ `tcpv4 ] Net.Manager.Unix.fd Net.Manager.Unix.resp", "params": [{"name": "", "type": "Net.Manager.Unix.ipv4"}, {"name": "", "type": "Net.Manager.Unix.port"}]}}, {"value": {"name": "Net.Manager.Unix.tcpv4_listen", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|2859"}, "info": "", "type": "[ `tcpv4 ] Net.Manager.Unix.fd -> unit Net.Manager.Unix.resp", "params": [{"name": "", "type": "[ `tcpv4 ] Net.Manager.Unix.fd"}]}}, {"value": {"name": "Net.Manager.Unix.tcpv4_accept", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|2937"}, "info": "", "type": "[ `tcpv4 ] Net.Manager.Unix.fd ->\n  ([ `tcpv4 ] Net.Manager.Unix.fd * Net.Manager.Unix.ipv4 *\n   Net.Manager.Unix.port)\n  Net.Manager.Unix.resp", "params": [{"name": "", "type": "[ `tcpv4 ] Net.Manager.Unix.fd"}]}}, {"value": {"name": "Net.Manager.Unix.udpv4_socket", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|3039"}, "info": "", "type": "unit -> [ `udpv4 ] Net.Manager.Unix.fd", "params": [{"name": "", "type": "unit"}]}}, {"value": {"name": "Net.Manager.Unix.udpv4_bind", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|3111"}, "info": "", "type": "Net.Manager.Unix.ipv4 ->\n  Net.Manager.Unix.port -> [ `udpv4 ] Net.Manager.Unix.fd Net.Manager.Unix.resp", "params": [{"name": "", "type": "Net.Manager.Unix.ipv4"}, {"name": "", "type": "Net.Manager.Unix.port"}]}}, {"value": {"name": "Net.Manager.Unix.udpv4_recvfrom", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|3192"}, "info": "", "type": "[ `udpv4 ] Net.Manager.Unix.fd ->\n  string ->\n  int ->\n  int ->\n  (Net.Manager.Unix.ipv4 * Net.Manager.Unix.port * int) Net.Manager.Unix.resp", "params": [{"name": "", "type": "[ `udpv4 ] Net.Manager.Unix.fd"}, {"name": "", "type": "string"}, {"name": "", "type": "int"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Net.Manager.Unix.udpv4_sendto", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|3312"}, "info": "", "type": "[ `udpv4 ] Net.Manager.Unix.fd ->\n  string ->\n  int ->\n  int ->\n  Net.Manager.Unix.ipv4 * Net.Manager.Unix.port -> int Net.Manager.Unix.resp", "params": [{"name": "", "type": "[ `udpv4 ] Net.Manager.Unix.fd"}, {"name": "", "type": "string"}, {"name": "", "type": "int"}, {"name": "", "type": "int"}, {"tuple": {"type": "Net.Manager.Unix.ipv4 * Net.Manager.Unix.port", "contents": [{"name": "", "type": "Net.Manager.Unix.ipv4"}, {"name": "", "type": "Net.Manager.Unix.port"}]}}]}}, {"value": {"name": "Net.Manager.Unix.domain_uid", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|3427"}, "info": "", "type": "unit -> Net.Manager.Unix.uid", "params": [{"name": "", "type": "unit"}]}}, {"value": {"name": "Net.Manager.Unix.domain_bind", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|3486"}, "info": "", "type": "Net.Manager.Unix.uid -> [ `domain ] Net.Manager.Unix.fd Net.Manager.Unix.resp", "params": [{"name": "", "type": "Net.Manager.Unix.uid"}]}}, {"value": {"name": "Net.Manager.Unix.domain_connect", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|3561"}, "info": "", "type": "Net.Manager.Unix.uid -> [ `domain ] Net.Manager.Unix.fd Net.Manager.Unix.resp", "params": [{"name": "", "type": "Net.Manager.Unix.uid"}]}}, {"value": {"name": "Net.Manager.Unix.domain_accept", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|3642"}, "info": "", "type": "[ `domain ] Net.Manager.Unix.fd ->\n  [ `domain ] Net.Manager.Unix.fd Net.Manager.Unix.resp", "params": [{"name": "", "type": "[ `domain ] Net.Manager.Unix.fd"}]}}, {"value": {"name": "Net.Manager.Unix.domain_list", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|3732"}, "info": "", "type": "unit -> Net.Manager.Unix.uid list", "params": [{"name": "", "type": "unit"}]}}, {"value": {"name": "Net.Manager.Unix.domain_read", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|3797"}, "info": "", "type": "[ `domain ] Net.Manager.Unix.fd -> string Net.Manager.Unix.resp", "params": [{"name": "", "type": "[ `domain ] Net.Manager.Unix.fd"}]}}, {"value": {"name": "Net.Manager.Unix.domain_write", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|3875"}, "info": "", "type": "[ `domain ] Net.Manager.Unix.fd -> string -> unit Net.Manager.Unix.resp", "params": [{"name": "", "type": "[ `domain ] Net.Manager.Unix.fd"}, {"name": "", "type": "string"}]}}, {"value": {"name": "Net.Manager.Unix.domain_send_pipe", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|3963"}, "info": "", "type": "[ `domain ] Net.Manager.Unix.fd ->\n  [< `rd_pipe | `wr_pipe ] Net.Manager.Unix.fd -> unit Net.Manager.Unix.resp", "params": [{"name": "", "type": "[ `domain ] Net.Manager.Unix.fd"}, {"name": "", "type": "[< `rd_pipe | `wr_pipe ] Net.Manager.Unix.fd"}]}}, {"value": {"name": "Net.Manager.Unix.domain_recv_pipe", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|4078"}, "info": "", "type": "[ `domain ] Net.Manager.Unix.fd ->\n  [< `rd_pipe | `wr_pipe ] Net.Manager.Unix.fd Net.Manager.Unix.resp", "params": [{"name": "", "type": "[ `domain ] Net.Manager.Unix.fd"}]}}, {"value": {"name": "Net.Manager.Unix.pipe", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|4185"}, "info": "", "type": "unit ->\n  ([ `rd_pipe ] Net.Manager.Unix.fd * [ `wr_pipe ] Net.Manager.Unix.fd)\n  Net.Manager.Unix.resp", "params": [{"name": "", "type": "unit"}]}}, {"value": {"name": "Net.Manager.Unix.connect_result", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|4274"}, "info": "", "type": "[< `domain | `tcpv4 ] Net.Manager.Unix.fd -> unit Net.Manager.Unix.resp", "params": [{"name": "", "type": "[< `domain | `tcpv4 ] Net.Manager.Unix.fd"}]}}, {"value": {"name": "Net.Manager.Unix.read", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|4373"}, "info": "", "type": "[< `rd_pipe | `tcpv4 | `udpv4 ] Net.Manager.Unix.fd ->\n  string -> int -> int -> int Net.Manager.Unix.resp", "params": [{"name": "", "type": "[< `rd_pipe | `tcpv4 | `udpv4 ] Net.Manager.Unix.fd"}, {"name": "", "type": "string"}, {"name": "", "type": "int"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Net.Manager.Unix.write", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|4485"}, "info": "", "type": "[< `tcpv4 | `udpv4 | `wr_pipe ] Net.Manager.Unix.fd ->\n  string -> int -> int -> int Net.Manager.Unix.resp", "params": [{"name": "", "type": "[< `tcpv4 | `udpv4 | `wr_pipe ] Net.Manager.Unix.fd"}, {"name": "", "type": "string"}, {"name": "", "type": "int"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Net.Manager.Unix.close", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|4599"}, "info": "", "type": "[< `domain | `rd_pipe | `tcpv4 | `udpv4 | `wr_pipe ] Net.Manager.Unix.fd ->\n  unit", "params": [{"name": "", "type": "[< `domain | `rd_pipe | `tcpv4 | `udpv4 | `wr_pipe ] Net.Manager.Unix.fd"}]}}, {"value": {"name": "Net.Manager.Unix.fd_to_int", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|4706"}, "info": "", "type": "'a Net.Manager.Unix.fd -> int", "params": [{"name": "", "type": "'a Net.Manager.Unix.fd"}]}}, {"value": {"name": "Net.Manager.Unix.fdbind", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|4758"}, "info": "", "type": "(int -> 'a Lwt.t) ->\n  ('b Net.Manager.Unix.fd -> 'c Net.Manager.Unix.resp) ->\n  'b Net.Manager.Unix.fd -> 'c Lwt.t", "params": [{"name": "", "type": "int -> 'a Lwt.t"}, {"name": "", "type": "'a Net.Manager.Unix.fd -> 'b Net.Manager.Unix.resp"}, {"name": "", "type": "'a Net.Manager.Unix.fd"}]}}, {"value": {"name": "Net.Manager.Unix.iobind", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|4836"}, "info": "", "type": "('a -> 'b Net.Manager.Unix.resp) -> 'a -> 'b Lwt.t", "params": [{"name": "", "type": "'a -> 'b Net.Manager.Unix.resp"}, {"name": "", "type": "'a"}]}}], "dependencies": {"uses": []}}}, {"type": {"name": "Net.Manager.t", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|4895"}, "info": "", "params": [], "kind": {"type": "abstract"}}}, {"value": {"name": "Net.Manager.local_peers", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|4897"}, "info": "", "type": "'a -> Net.Manager.Unix.uid list", "params": [{"name": "", "type": "'a"}]}}, {"value": {"name": "Net.Manager.local_uid", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|4935"}, "info": "", "type": "'a -> Net.Manager.Unix.uid", "params": [{"name": "", "type": "'a"}]}}, {"value": {"name": "Net.Manager.connect_to_peer", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|4966"}, "info": "", "type": "Net.Manager.t ->\n  Net.Nettypes.peer_uid -> [ `domain ] Net.Manager.Unix.fd option Lwt.t", "params": [{"name": "", "type": "Net.Manager.t"}, {"name": "", "type": "Net.Nettypes.peer_uid"}]}}, {"value": {"name": "Net.Manager.listen_to_peers", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|5047"}, "info": "", "type": "Net.Manager.t ->\n  (int ->\n   [< `rd_pipe | `wr_pipe ] Net.Manager.Unix.fd *\n   [< `rd_pipe | `wr_pipe ] Net.Manager.Unix.fd -> unit Lwt.t) ->\n  unit Lwt.t", "params": [{"name": "", "type": "Net.Manager.t"}, {"name": "", "type": "int ->\n  [< `rd_pipe | `wr_pipe ] Net.Manager.Unix.fd *\n  [< `rd_pipe | `wr_pipe ] Net.Manager.Unix.fd -> unit Lwt.t"}]}}, {"value": {"name": "Net.Manager.connect", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|5179"}, "info": "", "type": "Net.Manager.t ->\n  Net.Nettypes.peer_uid ->\n  ([ `rd_pipe ] Net.Manager.Unix.fd * [ `wr_pipe ] Net.Manager.Unix.fd ->\n   'a Lwt.t) ->\n  'a Lwt.t", "params": [{"name": "", "type": "Net.Manager.t"}, {"name": "", "type": "Net.Nettypes.peer_uid"}, {"name": "", "type": "[ `rd_pipe ] Net.Manager.Unix.fd * [ `wr_pipe ] Net.Manager.Unix.fd ->\n  'a Lwt.t"}]}}, {"value": {"name": "Net.Manager.create", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|5289"}, "info": "", "type": "unit -> (Net.Manager.t * 'a Lwt.t) Lwt.t", "params": [{"name": "", "type": "unit"}]}}, {"value": {"name": "Net.Manager.get_udpv4", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|5331"}, "info": "", "type": "Net.Manager.t -> [ `udpv4 ] Net.Manager.Unix.fd", "params": [{"name": "", "type": "Net.Manager.t"}]}}, {"value": {"name": "Net.Manager.register_udpv4_listener", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|5371"}, "info": "", "type": "Net.Manager.t ->\n  Net.Nettypes.ipv4_addr option * int -> [ `udpv4 ] Net.Manager.Unix.fd -> unit", "params": [{"name": "", "type": "Net.Manager.t"}, {"tuple": {"type": "Net.Nettypes.ipv4_addr option * int", "contents": [{"name": "", "type": "Net.Nettypes.ipv4_addr option"}, {"name": "", "type": "int"}]}}, {"name": "", "type": "[ `udpv4 ] Net.Manager.Unix.fd"}]}}, {"value": {"name": "Net.Manager.get_udpv4_listener", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|5468"}, "info": "", "type": "Net.Manager.t ->\n  Net.Nettypes.ipv4_addr option * Net.Manager.Unix.port ->\n  [ `udpv4 ] Net.Manager.Unix.fd Lwt.t", "params": [{"name": "", "type": "Net.Manager.t"}, {"tuple": {"type": "Net.Nettypes.ipv4_addr option * Net.Manager.Unix.port", "contents": [{"name": "", "type": "Net.Nettypes.ipv4_addr option"}, {"name": "", "type": "Net.Manager.Unix.port"}]}}]}}], "dependencies": {"uses": []}}}, {"module": {"name": "Net.Flow", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|5568"}, "info": "", "type": "sig  end", "module_structure": [{"module": {"name": "Net.Flow.TCPv4", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|5603"}, "info": "", "type": "sig  end", "module_with": "unavailable", "dependencies": {"uses": []}}}, {"module": {"name": "Net.Flow.Pipe", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|5708"}, "info": "", "type": "sig  end", "module_with": "unavailable", "dependencies": {"uses": []}}}, {"type": {"name": "Net.Flow.t", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|5817"}, "info": "", "params": [], "kind": {"type": "abstract"}}}, {"value": {"name": "Net.Flow.read", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|5819"}, "info": "", "type": "Net.Flow.t -> Bitstring.t option Lwt.t", "params": [{"name": "", "type": "Net.Flow.t"}]}}, {"value": {"name": "Net.Flow.write", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|5859"}, "info": "", "type": "Net.Flow.t -> Bitstring.t -> unit Lwt.t", "params": [{"name": "", "type": "Net.Flow.t"}, {"name": "", "type": "Bitstring.t"}]}}, {"value": {"name": "Net.Flow.close", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|5901"}, "info": "", "type": "Net.Flow.t -> unit Lwt.t", "params": [{"name": "", "type": "Net.Flow.t"}]}}, {"value": {"name": "Net.Flow.connect", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|5929"}, "info": "", "type": "Net.Manager.t ->\n  [> `Pipe of\n       Net.Nettypes.peer_uid option * Net.Nettypes.peer_uid *\n       (Net.Flow.t -> 'a Lwt.t)\n   | `TCPv4 of\n       Net.Nettypes.ipv4_src option * Net.Nettypes.ipv4_dst *\n       (Net.Flow.t -> 'a Lwt.t) ] ->\n  'a Lwt.t", "params": [{"name": "", "type": "Net.Manager.t"}, {"name": "", "type": "[> `Pipe of\n       Net.Nettypes.peer_uid option * Net.Nettypes.peer_uid *\n       (Net.Flow.t -> 'a Lwt.t)\n   | `TCPv4 of\n       Net.Nettypes.ipv4_src option * Net.Nettypes.ipv4_dst *\n       (Net.Flow.t -> 'a Lwt.t) ]"}]}}, {"value": {"name": "Net.Flow.listen", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|6098"}, "info": "", "type": "Net.Manager.t ->\n  [> `Pipe of\n       Net.Nettypes.peer_uid *\n       (Net.Nettypes.peer_uid -> Net.Flow.t -> unit Lwt.t)\n   | `TCPv4 of\n       Net.Nettypes.ipv4_src *\n       (Net.Nettypes.ipv4_dst -> Net.Flow.t -> unit Lwt.t) ] ->\n  unit Lwt.t", "params": [{"name": "", "type": "Net.Manager.t"}, {"name": "", "type": "[> `Pipe of\n       Net.Nettypes.peer_uid *\n       (Net.Nettypes.peer_uid -> Net.Flow.t -> unit Lwt.t)\n   | `TCPv4 of\n       Net.Nettypes.ipv4_src *\n       (Net.Nettypes.ipv4_dst -> Net.Flow.t -> unit Lwt.t) ]"}]}}], "dependencies": {"uses": []}}}, {"module": {"name": "Net.Datagram", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|6264"}, "info": "", "type": "sig  end", "module_structure": [{"module": {"name": "Net.Datagram.UDPv4", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|6288"}, "info": "", "type": "sig  end", "module_with": "unavailable", "dependencies": {"uses": []}}}], "dependencies": {"uses": []}}}, {"module": {"name": "Net.Channel", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|6457"}, "info": "", "type": "sig  end", "module_structure": [{"module": {"name": "Net.Channel.TCPv4", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|6495"}, "info": "", "type": "sig  end", "module_with": "unavailable", "dependencies": {"uses": []}}}, {"module": {"name": "Net.Channel.Pipe", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|6603"}, "info": "", "type": "sig  end", "module_with": "unavailable", "dependencies": {"uses": []}}}, {"type": {"name": "Net.Channel.t", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|6715"}, "info": "", "params": [], "kind": {"type": "abstract"}}}, {"value": {"name": "Net.Channel.read_char", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|6718"}, "info": "", "type": "Net.Channel.t -> char Lwt.t", "params": [{"name": "", "type": "Net.Channel.t"}]}}, {"value": {"name": "Net.Channel.read_some", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|6749"}, "info": "", "type": "?len:int -> Net.Channel.t -> Bitstring.t Lwt.t", "params": [{"name": "len", "type": "int option"}, {"name": "", "type": "Net.Channel.t"}]}}, {"value": {"name": "Net.Channel.read_until", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|6799"}, "info": "", "type": "Net.Channel.t -> char -> (bool * Bitstring.t) Lwt.t", "params": [{"name": "", "type": "Net.Channel.t"}, {"name": "", "type": "char"}]}}, {"value": {"name": "Net.Channel.read_stream", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|6855"}, "info": "", "type": "?len:int -> Net.Channel.t -> Bitstring.t Lwt_stream.t", "params": [{"name": "len", "type": "int option"}, {"name": "", "type": "Net.Channel.t"}]}}, {"value": {"name": "Net.Channel.read_crlf", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|6914"}, "info": "", "type": "Net.Channel.t -> Bitstring.t Lwt.t", "params": [{"name": "", "type": "Net.Channel.t"}]}}, {"value": {"name": "Net.Channel.write_char", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|6953"}, "info": "", "type": "Net.Channel.t -> char -> unit Lwt.t", "params": [{"name": "", "type": "Net.Channel.t"}, {"name": "", "type": "char"}]}}, {"value": {"name": "Net.Channel.write_string", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|6994"}, "info": "", "type": "Net.Channel.t -> string -> unit Lwt.t", "params": [{"name": "", "type": "Net.Channel.t"}, {"name": "", "type": "string"}]}}, {"value": {"name": "Net.Channel.write_bitstring", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|7039"}, "info": "", "type": "Net.Channel.t -> Bitstring.t -> unit Lwt.t", "params": [{"name": "", "type": "Net.Channel.t"}, {"name": "", "type": "Bitstring.t"}]}}, {"value": {"name": "Net.Channel.write_line", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|7092"}, "info": "", "type": "Net.Channel.t -> string -> unit Lwt.t", "params": [{"name": "", "type": "Net.Channel.t"}, {"name": "", "type": "string"}]}}, {"value": {"name": "Net.Channel.flush", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|7136"}, "info": "", "type": "Net.Channel.t -> unit Lwt.t", "params": [{"name": "", "type": "Net.Channel.t"}]}}, {"value": {"name": "Net.Channel.close", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|7164"}, "info": "", "type": "Net.Channel.t -> unit Lwt.t", "params": [{"name": "", "type": "Net.Channel.t"}]}}, {"value": {"name": "Net.Channel.connect", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|7193"}, "info": "", "type": "Net.Manager.t ->\n  [> `Pipe of\n       Net.Nettypes.peer_uid option * Net.Nettypes.peer_uid *\n       (Net.Channel.t -> 'a Lwt.t)\n   | `TCPv4 of\n       Net.Nettypes.ipv4_src option * Net.Nettypes.ipv4_dst *\n       (Net.Channel.t -> 'a Lwt.t) ] ->\n  'a Lwt.t", "params": [{"name": "", "type": "Net.Manager.t"}, {"name": "", "type": "[> `Pipe of\n       Net.Nettypes.peer_uid option * Net.Nettypes.peer_uid *\n       (Net.Channel.t -> 'a Lwt.t)\n   | `TCPv4 of\n       Net.Nettypes.ipv4_src option * Net.Nettypes.ipv4_dst *\n       (Net.Channel.t -> 'a Lwt.t) ]"}]}}, {"value": {"name": "Net.Channel.listen", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/net.mli|7362"}, "info": "", "type": "Net.Manager.t ->\n  [> `Pipe of\n       Net.Nettypes.peer_uid *\n       (Net.Nettypes.peer_uid -> Net.Channel.t -> unit Lwt.t)\n   | `TCPv4 of\n       Net.Nettypes.ipv4_src *\n       (Net.Nettypes.ipv4_dst -> Net.Channel.t -> unit Lwt.t) ] ->\n  unit Lwt.t", "params": [{"name": "", "type": "Net.Manager.t"}, {"name": "", "type": "[> `Pipe of\n       Net.Nettypes.peer_uid *\n       (Net.Nettypes.peer_uid -> Net.Channel.t -> unit Lwt.t)\n   | `TCPv4 of\n       Net.Nettypes.ipv4_src *\n       (Net.Nettypes.ipv4_dst -> Net.Channel.t -> unit Lwt.t) ]"}]}}], "dependencies": {"uses": []}}}], "dependencies": {"uses": ["Lwt_stream", "Lwt", "Bitstring", "*predef*"], "used_by": ["Dns", "Http"]}}}, "Block": {"module": {"name": "Block", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/block.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/block.mli|0"}, "info": "", "type": "sig  end", "module_structure": [{"module": {"name": "Block.Manager", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/block.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/block.mli|0"}, "info": "", "type": "sig  end", "module_structure": [{"exception": {"name": "Block.Manager.Error", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/block.mli|23"}, "info": "", "exception_args": ["string"]}}, {"module": {"name": "Block.Manager.Unix", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/block.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/block.mli|49"}, "info": "", "type": "sig  end", "module_structure": [{"type": {"name": "Block.Manager.Unix.fd", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/block.mli|75"}, "info": "", "params": [{"covariant": "true", "contravariant": "true", "type": "'a"}], "kind": {"type": "abstract"}}}, {"type": {"name": "Block.Manager.Unix.resp", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/block.mli|90"}, "info": "", "params": [{"covariant": "true", "contravariant": "false", "type": "'b"}], "kind": {"type": "variant", "private": "false", "constructors": [{"name": "OK", "type": ["'a"]}, {"name": "Err", "type": ["string"]}, {"name": "Retry", "type": []}]}}}, {"value": {"name": "Block.Manager.Unix.file_open_readonly", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/block.mli|138"}, "info": "", "type": "string -> [ `ro_file ] Block.Manager.Unix.fd Block.Manager.Unix.resp", "params": [{"name": "", "type": "string"}]}}, {"value": {"name": "Block.Manager.Unix.read", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/block.mli|231"}, "info": "", "type": "[ `ro_file ] Block.Manager.Unix.fd ->\n  string -> int -> int -> int Block.Manager.Unix.resp", "params": [{"name": "", "type": "[ `ro_file ] Block.Manager.Unix.fd"}, {"name": "", "type": "string"}, {"name": "", "type": "int"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Block.Manager.Unix.close", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/block.mli|324"}, "info": "", "type": "[ `ro_file ] Block.Manager.Unix.fd -> unit", "params": [{"name": "", "type": "[ `ro_file ] Block.Manager.Unix.fd"}]}}, {"value": {"name": "Block.Manager.Unix.iobind", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/block.mli|391"}, "info": "", "type": "('a -> 'b Block.Manager.Unix.resp) -> 'a -> 'b Lwt.t", "params": [{"name": "", "type": "'a -> 'b Block.Manager.Unix.resp"}, {"name": "", "type": "'a"}]}}], "dependencies": {"uses": []}}}], "dependencies": {"uses": []}}}, {"module": {"name": "Block.RO", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/block.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/block.mli|446"}, "info": "", "type": "sig  end", "module_structure": [{"type": {"name": "Block.RO.t", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/block.mli|469"}, "info": "", "params": [], "kind": {"type": "abstract"}}}, {"exception": {"name": "Block.RO.Error", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/block.mli|472"}, "info": "", "exception_args": ["string"]}}, {"value": {"name": "Block.RO.create", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/block.mli|499"}, "info": "", "type": "OS.Blkif.t -> Block.RO.t Lwt.t", "params": [{"name": "", "type": "OS.Blkif.t"}]}}, {"value": {"name": "Block.RO.read", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/block.mli|534"}, "info": "", "type": "Block.RO.t -> string -> Bitstring.t Lwt_stream.t Lwt.t", "params": [{"name": "", "type": "Block.RO.t"}, {"name": "", "type": "string"}]}}], "dependencies": {"uses": []}}}], "dependencies": {"uses": ["OS", "Lwt_stream", "Lwt", "Bitstring"], "used_by": []}}}, "Dns": {"module": {"name": "Dns", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|0"}, "info": {"description": "<span class=\"code\" >create n<\/span> creates an empty table of initial size <span class=\"code\" >n<\/span>. The table will grow as needed."}, "type": "sig  end", "module_structure": [{"module": {"name": "Dns.Hashcons", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|0"}, "info": "", "type": "sig  end", "module_structure": [{"type": {"name": "Dns.Hashcons.hash_consed", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|592"}, "info": "", "params": [{"covariant": "true", "contravariant": "true", "type": "'a"}], "kind": {"type": "record", "private": "true", "fields": [{"name": "hkey", "mutable": false, "type": "int"}, {"name": "tag", "mutable": false, "type": "int"}, {"name": "node", "mutable": false, "type": "'a"}]}}}, {"type": {"name": "Dns.Hashcons.t", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|737"}, "info": "", "params": [{"covariant": "true", "contravariant": "true", "type": "'b"}], "kind": {"type": "abstract"}}}, {"value": {"name": "Dns.Hashcons.create", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|744"}, "info": {"description": "<span class=\"code\" >create n<\/span> creates an empty table of initial size <span class=\"code\" >n<\/span>. The table will grow as needed."}, "type": "int -> 'a Dns.Hashcons.t", "params": [{"name": "", "type": "int"}]}}, {"value": {"name": "Dns.Hashcons.clear", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|872"}, "info": {"description": "Removes all elements from the table."}, "type": "'a Dns.Hashcons.t -> unit", "params": [{"name": "", "type": "'a Dns.Hashcons.t"}]}}, {"value": {"name": "Dns.Hashcons.hashcons", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|943"}, "info": {"description": "<span class=\"code\" >hashcons t n<\/span> hash-cons the value <span class=\"code\" >n<\/span> using table <span class=\"code\" >t<\/span> i.e. returns any existing value in <span class=\"code\" >t<\/span> equal to <span class=\"code\" >n<\/span>, if any; otherwise, allocates a new one hash-consed value of node <span class=\"code\" >n<\/span> and returns it.  As a consequence the returned value is physically equal to any equal value already hash-consed using table <span class=\"code\" >t<\/span>."}, "type": "'a Dns.Hashcons.t -> 'a -> 'a Dns.Hashcons.hash_consed", "params": [{"name": "", "type": "'a Dns.Hashcons.t"}, {"name": "", "type": "'a"}]}}, {"value": {"name": "Dns.Hashcons.iter", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|1326"}, "info": {"description": "<span class=\"code\" >iter f t<\/span> iterates <span class=\"code\" >f<\/span> over all elements of <span class=\"code\" >t<\/span>."}, "type": "('a Dns.Hashcons.hash_consed -> unit) -> 'a Dns.Hashcons.t -> unit", "params": [{"name": "", "type": "'a Dns.Hashcons.hash_consed -> unit"}, {"name": "", "type": "'a Dns.Hashcons.t"}]}}, {"value": {"name": "Dns.Hashcons.stats", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|1437"}, "info": {"description": "Return statistics on the table.  The numbers are, in order: table length, number of entries, sum of bucket lengths, smallest bucket length, median bucket length, biggest bucket length."}, "type": "'a Dns.Hashcons.t -> int * int * int * int * int * int", "params": [{"name": "", "type": "'a Dns.Hashcons.t"}]}}, {"module_type": {"name": "Dns.Hashcons.HashedType", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|1729"}, "info": "", "type": "sig  end", "kind": ""}}, {"module_type": {"name": "Dns.Hashcons.S", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|1833"}, "info": "", "type": "sig  end", "kind": ""}}, {"module": {"name": "Dns.Hashcons.Make", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|2094"}, "info": "", "type": "functor (H : HashedType) -> sig  end", "module_functor": {"parameter": {"name": "H"}, "module_with": "unavailable"}, "dependencies": {"uses": []}}}], "dependencies": {"uses": []}}}, {"module": {"name": "Dns.Dnsrr", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|2152"}, "info": "", "type": "sig  end", "module_structure": [{"type": {"name": "Dns.Dnsrr.serial", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|2178"}, "info": "", "params": [], "kind": {"type": "abstract"}, "manifest": "int32"}}, {"type": {"name": "Dns.Dnsrr.ipv4", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|2198"}, "info": "", "params": [], "kind": {"type": "abstract"}, "manifest": "int32"}}, {"type": {"name": "Dns.Dnsrr.cstr", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|2215"}, "info": "", "params": [], "kind": {"type": "abstract"}, "manifest": "string Dns.Hashcons.hash_consed"}}, {"type": {"name": "Dns.Dnsrr.dnsnode", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|2254"}, "info": "", "params": [], "kind": {"type": "record", "private": "false", "fields": [{"name": "owner", "mutable": false, "type": "string list Dns.Hashcons.hash_consed"}, {"name": "rrsets", "mutable": true, "type": "Dns.Dnsrr.rrset list"}]}}}, {"type": {"name": "Dns.Dnsrr.rrset", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|2346"}, "info": "", "params": [], "kind": {"type": "record", "private": "false", "fields": [{"name": "ttl", "mutable": false, "type": "int32"}, {"name": "rdata", "mutable": false, "type": "Dns.Dnsrr.rdata"}]}}}, {"type": {"name": "Dns.Dnsrr.rdata", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|2390"}, "info": "", "params": [], "kind": {"type": "variant", "private": "false", "constructors": [{"name": "A", "type": ["Dns.Dnsrr.ipv4 list"]}, {"name": "NS", "type": ["Dns.Dnsrr.dnsnode list"]}, {"name": "CNAME", "type": ["Dns.Dnsrr.dnsnode list"]}, {"name": "SOA", "type": ["(Dns.Dnsrr.dnsnode * Dns.Dnsrr.dnsnode * Dns.Dnsrr.serial * int32 * int32 *\n   int32 * int32)\n  list"]}, {"name": "MB", "type": ["Dns.Dnsrr.dnsnode list"]}, {"name": "MG", "type": ["Dns.Dnsrr.dnsnode list"]}, {"name": "MR", "type": ["Dns.Dnsrr.dnsnode list"]}, {"name": "WKS", "type": ["(int32 * int * Dns.Dnsrr.cstr) list"]}, {"name": "PTR", "type": ["Dns.Dnsrr.dnsnode list"]}, {"name": "HINFO", "type": ["(Dns.Dnsrr.cstr * Dns.Dnsrr.cstr) list"]}, {"name": "MINFO", "type": ["(Dns.Dnsrr.dnsnode * Dns.Dnsrr.dnsnode) list"]}, {"name": "MX", "type": ["(int * Dns.Dnsrr.dnsnode) list"]}, {"name": "TXT", "type": ["Dns.Dnsrr.cstr list list"]}, {"name": "RP", "type": ["(Dns.Dnsrr.dnsnode * Dns.Dnsrr.dnsnode) list"]}, {"name": "AFSDB", "type": ["(int * Dns.Dnsrr.dnsnode) list"]}, {"name": "X25", "type": ["Dns.Dnsrr.cstr list"]}, {"name": "ISDN", "type": ["(Dns.Dnsrr.cstr * Dns.Dnsrr.cstr option) list"]}, {"name": "RT", "type": ["(int * Dns.Dnsrr.dnsnode) list"]}, {"name": "AAAA", "type": ["Dns.Dnsrr.cstr list"]}, {"name": "SRV", "type": ["(int * int * int * Dns.Dnsrr.dnsnode) list"]}, {"name": "UNSPEC", "type": ["Dns.Dnsrr.cstr list"]}, {"name": "Unknown", "type": ["int", "Dns.Dnsrr.cstr list"]}]}}}, {"value": {"name": "Dns.Dnsrr.hashcons_charstring", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|3103"}, "info": "", "type": "string -> Dns.Dnsrr.cstr", "params": [{"name": "", "type": "string"}]}}, {"value": {"name": "Dns.Dnsrr.hashcons_domainname", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|3144"}, "info": "", "type": "string list -> string list Dns.Hashcons.hash_consed", "params": [{"name": "", "type": "string list"}]}}, {"value": {"name": "Dns.Dnsrr.clear_cons_tables", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|3218"}, "info": "", "type": "unit -> unit", "params": [{"name": "", "type": "unit"}]}}, {"value": {"name": "Dns.Dnsrr.get_rrsets", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|3373"}, "info": "", "type": "[> `A\n   | `AAAA\n   | `AFSDB\n   | `ANY\n   | `CNAME\n   | `HINFO\n   | `ISDN\n   | `MAILB\n   | `MB\n   | `MG\n   | `MINFO\n   | `MR\n   | `MX\n   | `NS\n   | `PTR\n   | `RP\n   | `RT\n   | `SOA\n   | `SRV\n   | `TXT\n   | `UNSPEC\n   | `Unknown of int * string\n   | `WKS\n   | `X25 ] ->\n  Dns.Dnsrr.rrset list -> bool -> Dns.Dnsrr.rrset list", "params": [{"name": "", "type": "[> `A\n   | `AAAA\n   | `AFSDB\n   | `ANY\n   | `CNAME\n   | `HINFO\n   | `ISDN\n   | `MAILB\n   | `MB\n   | `MG\n   | `MINFO\n   | `MR\n   | `MX\n   | `NS\n   | `PTR\n   | `RP\n   | `RT\n   | `SOA\n   | `SRV\n   | `TXT\n   | `UNSPEC\n   | `Unknown of int * string\n   | `WKS\n   | `X25 ]"}, {"name": "", "type": "Dns.Dnsrr.rrset list"}, {"name": "", "type": "bool"}]}}, {"value": {"name": "Dns.Dnsrr.merge_rrset", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|3799"}, "info": "", "type": "Dns.Dnsrr.rrset -> Dns.Dnsrr.rrset list -> int32 * Dns.Dnsrr.rrset list", "params": [{"name": "", "type": "Dns.Dnsrr.rrset"}, {"name": "", "type": "Dns.Dnsrr.rrset list"}]}}], "dependencies": {"uses": []}}}, {"module": {"name": "Dns.Dnstrie", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|3863"}, "info": "", "type": "sig  end", "module_structure": [{"type": {"name": "Dns.Dnstrie.dnstrie", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|3891"}, "info": "", "params": [], "kind": {"type": "abstract"}}}, {"type": {"name": "Dns.Dnstrie.key", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|3931"}, "info": "", "params": [], "kind": {"type": "abstract"}}}, {"exception": {"name": "Dns.Dnstrie.BadDomainName", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|3970"}, "info": "", "exception_args": ["string"]}}, {"exception": {"name": "Dns.Dnstrie.TrieCorrupt", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|4039"}, "info": ""}}, {"value": {"name": "Dns.Dnstrie.canon2key", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|4237"}, "info": "", "type": "string list -> Dns.Dnstrie.key", "params": [{"name": "", "type": "string list"}]}}, {"value": {"name": "Dns.Dnstrie.new_trie", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|4304"}, "info": "", "type": "unit -> Dns.Dnstrie.dnstrie", "params": [{"name": "", "type": "unit"}]}}, {"value": {"name": "Dns.Dnstrie.simple_lookup", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|4385"}, "info": "", "type": "Dns.Dnstrie.key -> Dns.Dnstrie.dnstrie -> Dns.Dnsrr.dnsnode option", "params": [{"name": "", "type": "Dns.Dnstrie.key"}, {"name": "", "type": "Dns.Dnstrie.dnstrie"}]}}, {"value": {"name": "Dns.Dnstrie.lookup", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|4501"}, "info": "", "type": "Dns.Dnstrie.key ->\n  Dns.Dnstrie.dnstrie ->\n  [> `Delegated of bool * Dns.Dnsrr.dnsnode\n   | `Found of bool * Dns.Dnsrr.dnsnode * Dns.Dnsrr.dnsnode\n   | `NXDomain of Dns.Dnsrr.dnsnode\n   | `NXDomainNSEC of Dns.Dnsrr.dnsnode * Dns.Dnsrr.dnsnode * Dns.Dnsrr.dnsnode\n   | `NoError of Dns.Dnsrr.dnsnode\n   | `NoErrorNSEC of Dns.Dnsrr.dnsnode * Dns.Dnsrr.dnsnode\n   | `Wildcard of Dns.Dnsrr.dnsnode * Dns.Dnsrr.dnsnode\n   | `WildcardNSEC of Dns.Dnsrr.dnsnode * Dns.Dnsrr.dnsnode * Dns.Dnsrr.dnsnode ]", "params": [{"name": "", "type": "Dns.Dnstrie.key"}, {"name": "", "type": "Dns.Dnstrie.dnstrie"}]}}, {"value": {"name": "Dns.Dnstrie.lookup_or_insert", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|5032"}, "info": "", "type": "Dns.Dnstrie.key ->\n  Dns.Dnstrie.dnstrie ->\n  ?parent:Dns.Dnstrie.dnstrie ->\n  (unit -> Dns.Dnsrr.dnsnode) -> Dns.Dnsrr.dnsnode", "params": [{"name": "", "type": "Dns.Dnstrie.key"}, {"name": "", "type": "Dns.Dnstrie.dnstrie"}, {"name": "parent", "type": "Dns.Dnstrie.dnstrie option"}, {"name": "", "type": "unit -> Dns.Dnsrr.dnsnode"}]}}, {"value": {"name": "Dns.Dnstrie.fix_flags", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|5235"}, "info": "", "type": "Dns.Dnstrie.key -> Dns.Dnstrie.dnstrie -> unit", "params": [{"name": "", "type": "Dns.Dnstrie.key"}, {"name": "", "type": "Dns.Dnstrie.dnstrie"}]}}], "dependencies": {"uses": []}}}, {"module": {"name": "Dns.Dnsloader", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|5279"}, "info": "", "type": "sig  end", "module_structure": [{"type": {"name": "Dns.Dnsloader.db", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|5385"}, "info": "", "params": [], "kind": {"type": "record", "private": "false", "fields": [{"name": "trie", "mutable": false, "type": "Dns.Dnstrie.dnstrie"}, {"name": "names", "mutable": true, "type": "(Dns.Dnstrie.key, Dns.Dnsrr.dnsnode) Hashtbl.t"}]}}}, {"value": {"name": "Dns.Dnsloader.new_db", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|5515"}, "info": "", "type": "unit -> Dns.Dnsloader.db", "params": [{"name": "", "type": "unit"}]}}, {"value": {"name": "Dns.Dnsloader.no_more_updates", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|5597"}, "info": "", "type": "Dns.Dnsloader.db -> unit", "params": [{"name": "", "type": "Dns.Dnsloader.db"}]}}, {"value": {"name": "Dns.Dnsloader.add_generic_rr", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|5696"}, "info": "", "type": "int -> string -> int32 -> string list -> Dns.Dnsloader.db -> unit", "params": [{"name": "", "type": "int"}, {"name": "", "type": "string"}, {"name": "", "type": "int32"}, {"name": "", "type": "string list"}, {"name": "", "type": "Dns.Dnsloader.db"}]}}, {"value": {"name": "Dns.Dnsloader.add_a_rr", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|5769"}, "info": "", "type": "Dns.Dnsrr.ipv4 -> int32 -> string list -> Dns.Dnsloader.db -> unit", "params": [{"name": "", "type": "Dns.Dnsrr.ipv4"}, {"name": "", "type": "int32"}, {"name": "", "type": "string list"}, {"name": "", "type": "Dns.Dnsloader.db"}]}}, {"value": {"name": "Dns.Dnsloader.add_ns_rr", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|5833"}, "info": "", "type": "string list -> int32 -> string list -> Dns.Dnsloader.db -> unit", "params": [{"name": "", "type": "string list"}, {"name": "", "type": "int32"}, {"name": "", "type": "string list"}, {"name": "", "type": "Dns.Dnsloader.db"}]}}, {"value": {"name": "Dns.Dnsloader.add_cname_rr", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|5899"}, "info": "", "type": "string list -> int32 -> string list -> Dns.Dnsloader.db -> unit", "params": [{"name": "", "type": "string list"}, {"name": "", "type": "int32"}, {"name": "", "type": "string list"}, {"name": "", "type": "Dns.Dnsloader.db"}]}}, {"value": {"name": "Dns.Dnsloader.add_soa_rr", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|5968"}, "info": "", "type": "string list ->\n  string list ->\n  Dns.Dnsrr.serial ->\n  int32 ->\n  int32 -> int32 -> int32 -> int32 -> string list -> Dns.Dnsloader.db -> unit", "params": [{"name": "", "type": "string list"}, {"name": "", "type": "string list"}, {"name": "", "type": "Dns.Dnsrr.serial"}, {"name": "", "type": "int32"}, {"name": "", "type": "int32"}, {"name": "", "type": "int32"}, {"name": "", "type": "int32"}, {"name": "", "type": "int32"}, {"name": "", "type": "string list"}, {"name": "", "type": "Dns.Dnsloader.db"}]}}, {"value": {"name": "Dns.Dnsloader.add_mb_rr", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|6116"}, "info": "", "type": "string list -> int32 -> string list -> Dns.Dnsloader.db -> unit", "params": [{"name": "", "type": "string list"}, {"name": "", "type": "int32"}, {"name": "", "type": "string list"}, {"name": "", "type": "Dns.Dnsloader.db"}]}}, {"value": {"name": "Dns.Dnsloader.add_mg_rr", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|6182"}, "info": "", "type": "string list -> int32 -> string list -> Dns.Dnsloader.db -> unit", "params": [{"name": "", "type": "string list"}, {"name": "", "type": "int32"}, {"name": "", "type": "string list"}, {"name": "", "type": "Dns.Dnsloader.db"}]}}, {"value": {"name": "Dns.Dnsloader.add_mr_rr", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|6248"}, "info": "", "type": "string list -> int32 -> string list -> Dns.Dnsloader.db -> unit", "params": [{"name": "", "type": "string list"}, {"name": "", "type": "int32"}, {"name": "", "type": "string list"}, {"name": "", "type": "Dns.Dnsloader.db"}]}}, {"value": {"name": "Dns.Dnsloader.add_wks_rr", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|6314"}, "info": "", "type": "int32 -> int -> string -> int32 -> string list -> Dns.Dnsloader.db -> unit", "params": [{"name": "", "type": "int32"}, {"name": "", "type": "int"}, {"name": "", "type": "string"}, {"name": "", "type": "int32"}, {"name": "", "type": "string list"}, {"name": "", "type": "Dns.Dnsloader.db"}]}}, {"value": {"name": "Dns.Dnsloader.add_ptr_rr", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|6392"}, "info": "", "type": "string list -> int32 -> string list -> Dns.Dnsloader.db -> unit", "params": [{"name": "", "type": "string list"}, {"name": "", "type": "int32"}, {"name": "", "type": "string list"}, {"name": "", "type": "Dns.Dnsloader.db"}]}}, {"value": {"name": "Dns.Dnsloader.add_hinfo_rr", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|6459"}, "info": "", "type": "string -> string -> int32 -> string list -> Dns.Dnsloader.db -> unit", "params": [{"name": "", "type": "string"}, {"name": "", "type": "string"}, {"name": "", "type": "int32"}, {"name": "", "type": "string list"}, {"name": "", "type": "Dns.Dnsloader.db"}]}}, {"value": {"name": "Dns.Dnsloader.add_minfo_rr", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|6533"}, "info": "", "type": "string list ->\n  string list -> int32 -> string list -> Dns.Dnsloader.db -> unit", "params": [{"name": "", "type": "string list"}, {"name": "", "type": "string list"}, {"name": "", "type": "int32"}, {"name": "", "type": "string list"}, {"name": "", "type": "Dns.Dnsloader.db"}]}}, {"value": {"name": "Dns.Dnsloader.add_mx_rr", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|6622"}, "info": "", "type": "int -> string list -> int32 -> string list -> Dns.Dnsloader.db -> unit", "params": [{"name": "", "type": "int"}, {"name": "", "type": "string list"}, {"name": "", "type": "int32"}, {"name": "", "type": "string list"}, {"name": "", "type": "Dns.Dnsloader.db"}]}}, {"value": {"name": "Dns.Dnsloader.add_txt_rr", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|6695"}, "info": "", "type": "string list -> int32 -> string list -> Dns.Dnsloader.db -> unit", "params": [{"name": "", "type": "string list"}, {"name": "", "type": "int32"}, {"name": "", "type": "string list"}, {"name": "", "type": "Dns.Dnsloader.db"}]}}, {"value": {"name": "Dns.Dnsloader.add_rp_rr", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|6762"}, "info": "", "type": "string list ->\n  string list -> int32 -> string list -> Dns.Dnsloader.db -> unit", "params": [{"name": "", "type": "string list"}, {"name": "", "type": "string list"}, {"name": "", "type": "int32"}, {"name": "", "type": "string list"}, {"name": "", "type": "Dns.Dnsloader.db"}]}}, {"value": {"name": "Dns.Dnsloader.add_afsdb_rr", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|6847"}, "info": "", "type": "int -> string list -> int32 -> string list -> Dns.Dnsloader.db -> unit", "params": [{"name": "", "type": "int"}, {"name": "", "type": "string list"}, {"name": "", "type": "int32"}, {"name": "", "type": "string list"}, {"name": "", "type": "Dns.Dnsloader.db"}]}}, {"value": {"name": "Dns.Dnsloader.add_x25_rr", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|6923"}, "info": "", "type": "string -> int32 -> string list -> Dns.Dnsloader.db -> unit", "params": [{"name": "", "type": "string"}, {"name": "", "type": "int32"}, {"name": "", "type": "string list"}, {"name": "", "type": "Dns.Dnsloader.db"}]}}, {"value": {"name": "Dns.Dnsloader.add_isdn_rr", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|6985"}, "info": "", "type": "string -> string option -> int32 -> string list -> Dns.Dnsloader.db -> unit", "params": [{"name": "", "type": "string"}, {"name": "", "type": "string option"}, {"name": "", "type": "int32"}, {"name": "", "type": "string list"}, {"name": "", "type": "Dns.Dnsloader.db"}]}}, {"value": {"name": "Dns.Dnsloader.add_rt_rr", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|7065"}, "info": "", "type": "int -> string list -> int32 -> string list -> Dns.Dnsloader.db -> unit", "params": [{"name": "", "type": "int"}, {"name": "", "type": "string list"}, {"name": "", "type": "int32"}, {"name": "", "type": "string list"}, {"name": "", "type": "Dns.Dnsloader.db"}]}}, {"value": {"name": "Dns.Dnsloader.add_aaaa_rr", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|7138"}, "info": "", "type": "string -> int32 -> string list -> Dns.Dnsloader.db -> unit", "params": [{"name": "", "type": "string"}, {"name": "", "type": "int32"}, {"name": "", "type": "string list"}, {"name": "", "type": "Dns.Dnsloader.db"}]}}, {"value": {"name": "Dns.Dnsloader.add_srv_rr", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|7201"}, "info": "", "type": "int ->\n  int -> int -> string list -> int32 -> string list -> Dns.Dnsloader.db -> unit", "params": [{"name": "", "type": "int"}, {"name": "", "type": "int"}, {"name": "", "type": "int"}, {"name": "", "type": "string list"}, {"name": "", "type": "int32"}, {"name": "", "type": "string list"}, {"name": "", "type": "Dns.Dnsloader.db"}]}}, {"value": {"name": "Dns.Dnsloader.add_unspec_rr", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|7291"}, "info": "", "type": "string -> int32 -> string list -> Dns.Dnsloader.db -> unit", "params": [{"name": "", "type": "string"}, {"name": "", "type": "int32"}, {"name": "", "type": "string list"}, {"name": "", "type": "Dns.Dnsloader.db"}]}}, {"exception": {"name": "Dns.Dnsloader.TTLMismatch", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|7594"}, "info": ""}}, {"type": {"name": "Dns.Dnsloader.parserstate", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|7670"}, "info": "", "params": [], "kind": {"type": "record", "private": "false", "fields": [{"name": "db", "mutable": true, "type": "Dns.Dnsloader.db"}, {"name": "paren", "mutable": true, "type": "int"}, {"name": "filename", "mutable": true, "type": "string"}, {"name": "lineno", "mutable": true, "type": "int"}, {"name": "origin", "mutable": true, "type": "string list"}, {"name": "ttl", "mutable": true, "type": "int32"}, {"name": "owner", "mutable": true, "type": "string list"}]}}}, {"value": {"name": "Dns.Dnsloader.state", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|7878"}, "info": "", "type": "Dns.Dnsloader.parserstate", "params": []}}], "dependencies": {"uses": []}}}, {"module": {"name": "Dns.Dnspacket", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|7906"}, "info": "", "type": "sig  end", "module_structure": [{"exception": {"name": "Dns.Dnspacket.Unparsable", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|7931"}, "info": "", "exception_args": ["string", "Bitstring.bitstring"]}}, {"value": {"name": "Dns.Dnspacket.(|>)", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|7985"}, "info": "", "type": "'a -> ('a -> 'b) -> 'b", "params": [{"name": "", "type": "'a"}, {"name": "", "type": "'a -> 'b"}]}}, {"value": {"name": "Dns.Dnspacket.(>>)", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|8021"}, "info": "", "type": "('a -> 'b) -> ('b -> 'c) -> 'a -> 'c", "params": [{"name": "", "type": "'a -> 'b"}, {"name": "", "type": "'a -> 'b"}, {"name": "", "type": "'a"}]}}, {"value": {"name": "Dns.Dnspacket.(||>)", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|8071"}, "info": "", "type": "'a list -> ('a -> 'b) -> 'b list", "params": [{"name": "", "type": "'a list"}, {"name": "", "type": "'a -> 'b"}]}}, {"value": {"name": "Dns.Dnspacket.(+++)", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|8118"}, "info": "", "type": "int32 -> int32 -> int32", "params": [{"name": "", "type": "int32"}, {"name": "", "type": "int32"}]}}, {"value": {"name": "Dns.Dnspacket.(&&&)", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|8156"}, "info": "", "type": "int32 -> int32 -> int32", "params": [{"name": "", "type": "int32"}, {"name": "", "type": "int32"}]}}, {"value": {"name": "Dns.Dnspacket.(|||)", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|8194"}, "info": "", "type": "int32 -> int32 -> int32", "params": [{"name": "", "type": "int32"}, {"name": "", "type": "int32"}]}}, {"value": {"name": "Dns.Dnspacket.(^^^)", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|8232"}, "info": "", "type": "int32 -> int32 -> int32", "params": [{"name": "", "type": "int32"}, {"name": "", "type": "int32"}]}}, {"value": {"name": "Dns.Dnspacket.(<<<)", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|8270"}, "info": "", "type": "int32 -> int -> int32", "params": [{"name": "", "type": "int32"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Dns.Dnspacket.(>>>)", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|8306"}, "info": "", "type": "int32 -> int -> int32", "params": [{"name": "", "type": "int32"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Dns.Dnspacket.join", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|8342"}, "info": "", "type": "string -> string list -> string", "params": [{"name": "", "type": "string"}, {"name": "", "type": "string list"}]}}, {"value": {"name": "Dns.Dnspacket.stop", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|8385"}, "info": "", "type": "'a * 'b -> 'a", "params": [{"tuple": {"type": "'a * 'b", "contents": [{"name": "", "type": "'a"}, {"name": "", "type": "'a"}]}}]}}, {"type": {"name": "Dns.Dnspacket.domain_name", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|8415"}, "info": "", "params": [], "kind": {"type": "abstract"}, "manifest": "string list"}}, {"type": {"name": "Dns.Dnspacket.int16", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|8446"}, "info": "", "params": [], "kind": {"type": "abstract"}, "manifest": "int"}}, {"type": {"name": "Dns.Dnspacket.ipv4", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|8463"}, "info": "", "params": [], "kind": {"type": "abstract"}, "manifest": "int32"}}, {"value": {"name": "Dns.Dnspacket.ipv4_to_string", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|8476"}, "info": "", "type": "int32 -> string", "params": [{"name": "", "type": "int32"}]}}, {"type": {"name": "Dns.Dnspacket.byte", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|8518"}, "info": "", "params": [], "kind": {"type": "abstract"}, "manifest": "char"}}, {"value": {"name": "Dns.Dnspacket.byte", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|8530"}, "info": "", "type": "int -> Dns.Dnspacket.byte", "params": [{"name": "", "type": "int"}]}}, {"value": {"name": "Dns.Dnspacket.int_of_byte", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|8553"}, "info": "", "type": "char -> int", "params": [{"name": "", "type": "char"}]}}, {"value": {"name": "Dns.Dnspacket.int32_of_byte", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|8583"}, "info": "", "type": "char -> int32", "params": [{"name": "", "type": "char"}]}}, {"value": {"name": "Dns.Dnspacket.int32_of_int", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|8617"}, "info": "", "type": "int -> int32", "params": [{"name": "", "type": "int"}]}}, {"type": {"name": "Dns.Dnspacket.bytes", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|8654"}, "info": "", "params": [], "kind": {"type": "abstract"}, "manifest": "string"}}, {"value": {"name": "Dns.Dnspacket.bytes_to_hex_string", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|8669"}, "info": "", "type": "char array -> string array", "params": [{"name": "", "type": "char array"}]}}, {"value": {"name": "Dns.Dnspacket.bytes_of_bitstring", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|8722"}, "info": "", "type": "Bitstring.bitstring -> string", "params": [{"name": "", "type": "Bitstring.bitstring"}]}}, {"value": {"name": "Dns.Dnspacket.ipv4_addr_of_bytes", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|8777"}, "info": "", "type": "string -> int32", "params": [{"name": "", "type": "string"}]}}, {"type": {"name": "Dns.Dnspacket.label", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|8823"}, "info": "", "params": [], "kind": {"type": "variant", "private": "false", "constructors": [{"name": "L", "type": ["string", "int"]}, {"name": "P", "type": ["int", "int"]}, {"name": "Z", "type": ["int"]}]}}}, {"value": {"name": "Dns.Dnspacket.parse_charstr", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|8877"}, "info": "", "type": "string * int * int -> string * (string * int * int)", "params": [{"tuple": {"type": "string * int * int", "contents": [{"name": "", "type": "string"}, {"name": "", "type": "int"}, {"name": "", "type": "int"}]}}]}}, {"value": {"name": "Dns.Dnspacket.parse_label", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|8949"}, "info": "", "type": "int -> Bitstring.bitstring -> Dns.Dnspacket.label * (string * int * int)", "params": [{"name": "", "type": "int"}, {"name": "", "type": "Bitstring.bitstring"}]}}, {"value": {"name": "Dns.Dnspacket.parse_name", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|9026"}, "info": "", "type": "(int, Dns.Dnspacket.label) Hashtbl.t ->\n  int -> Bitstring.bitstring -> string list * Bitstring.bitstring", "params": [{"name": "", "type": "(int, Dns.Dnspacket.label) Hashtbl.t"}, {"name": "", "type": "int"}, {"name": "", "type": "Bitstring.bitstring"}]}}, {"type": {"name": "Dns.Dnspacket.rr_type", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|9138"}, "info": "", "params": [], "kind": {"type": "abstract"}, "manifest": "[ `A\n  | `A6\n  | `AAAA\n  | `AFSDB\n  | `APL\n  | `ATMA\n  | `CERT\n  | `CNAME\n  | `DNAME\n  | `DNSKEY\n  | `DS\n  | `EID\n  | `GID\n  | `GPOS\n  | `HINFO\n  | `IPSECKEY\n  | `ISDN\n  | `KEY\n  | `KM\n  | `LOC\n  | `MB\n  | `MD\n  | `MF\n  | `MG\n  | `MINFO\n  | `MR\n  | `MX\n  | `NAPTR\n  | `NIMLOC\n  | `NS\n  | `NSAP\n  | `NSAP_PTR\n  | `NSEC\n  | `NULL\n  | `NXT\n  | `OPT\n  | `PTR\n  | `PX\n  | `RP\n  | `RRSIG\n  | `RT\n  | `SIG\n  | `SINK\n  | `SOA\n  | `SPF\n  | `SRV\n  | `SSHFP\n  | `TXT\n  | `UID\n  | `UINFO\n  | `UNSPEC\n  | `Unknown of int * Dns.Dnspacket.bytes\n  | `WKS\n  | `X25 ]"}}, {"value": {"name": "Dns.Dnspacket.int_of_rr_type", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|9794"}, "info": "", "type": "Dns.Dnspacket.rr_type -> int", "params": [{"name": "", "type": "Dns.Dnspacket.rr_type"}]}}, {"value": {"name": "Dns.Dnspacket.rr_type_of_int", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|9830"}, "info": "", "type": "int -> Dns.Dnspacket.rr_type", "params": [{"name": "", "type": "int"}]}}, {"value": {"name": "Dns.Dnspacket.string_of_rr_type", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|9866"}, "info": "", "type": "Dns.Dnspacket.rr_type -> string", "params": [{"name": "", "type": "Dns.Dnspacket.rr_type"}]}}, {"type": {"name": "Dns.Dnspacket.rr_rdata", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|9913"}, "info": "", "params": [], "kind": {"type": "abstract"}, "manifest": "[ `A of int32\n  | `AAAA of Dns.Dnspacket.bytes\n  | `AFSDB of Dns.Dnspacket.int16 * Dns.Dnspacket.domain_name\n  | `CNAME of Dns.Dnspacket.domain_name\n  | `HINFO of string * string\n  | `ISDN of string\n  | `MB of Dns.Dnspacket.domain_name\n  | `MD of Dns.Dnspacket.domain_name\n  | `MF of Dns.Dnspacket.domain_name\n  | `MG of Dns.Dnspacket.domain_name\n  | `MINFO of Dns.Dnspacket.domain_name * Dns.Dnspacket.domain_name\n  | `MR of Dns.Dnspacket.domain_name\n  | `MX of Dns.Dnspacket.int16 * Dns.Dnspacket.domain_name\n  | `NS of Dns.Dnspacket.domain_name\n  | `PTR of Dns.Dnspacket.domain_name\n  | `RP of Dns.Dnspacket.domain_name * Dns.Dnspacket.domain_name\n  | `RT of Dns.Dnspacket.int16 * Dns.Dnspacket.domain_name\n  | `SOA of\n      Dns.Dnspacket.domain_name * Dns.Dnspacket.domain_name * int32 * int32 *\n      int32 * int32 * int32\n  | `SRV of\n      Dns.Dnspacket.int16 * Dns.Dnspacket.int16 * Dns.Dnspacket.int16 *\n      Dns.Dnspacket.domain_name\n  | `TXT of string list\n  | `UNKNOWN of int * Dns.Dnspacket.bytes\n  | `UNSPEC of Dns.Dnspacket.bytes\n  | `WKS of int32 * Dns.Dnspacket.byte * string\n  | `X25 of string ]"}}, {"value": {"name": "Dns.Dnspacket.string_of_rdata", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|10680"}, "info": "", "type": "[> `A of int32 | `NS of string list ] -> string", "params": [{"name": "", "type": "[> `A of int32 | `NS of string list ]"}]}}, {"value": {"name": "Dns.Dnspacket.parse_rdata", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|10750"}, "info": "", "type": "(int, Dns.Dnspacket.label) Hashtbl.t ->\n  int ->\n  Dns.Dnspacket.rr_type ->\n  Bitstring.bitstring ->\n  [> `A of int32\n   | `CNAME of string list\n   | `HINFO of string * string\n   | `MINFO of string list * string list\n   | `MX of int * string list\n   | `NS of string list\n   | `PTR of string list\n   | `SOA of string list * string list * int32 * int32 * int32 * int32 * int32\n   | `TXT of 'a\n   | `UNKNOWN of int * string\n   | `WKS of int32 * Dns.Dnspacket.byte * string ]", "params": [{"name": "", "type": "(int, Dns.Dnspacket.label) Hashtbl.t"}, {"name": "", "type": "int"}, {"name": "", "type": "Dns.Dnspacket.rr_type"}, {"name": "", "type": "Bitstring.bitstring"}]}}, {"type": {"name": "Dns.Dnspacket.rr_class", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|11197"}, "info": "", "params": [], "kind": {"type": "abstract"}, "manifest": "[ `CH | `CS | `HS | `IN ]"}}, {"value": {"name": "Dns.Dnspacket.int_of_rr_class", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|11234"}, "info": "", "type": "Dns.Dnspacket.rr_class -> int", "params": [{"name": "", "type": "Dns.Dnspacket.rr_class"}]}}, {"value": {"name": "Dns.Dnspacket.rr_class_of_int", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|11272"}, "info": "", "type": "int -> Dns.Dnspacket.rr_class", "params": [{"name": "", "type": "int"}]}}, {"value": {"name": "Dns.Dnspacket.string_of_rr_class", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|11310"}, "info": "", "type": "Dns.Dnspacket.rr_class -> string", "params": [{"name": "", "type": "Dns.Dnspacket.rr_class"}]}}, {"type": {"name": "Dns.Dnspacket.rsrc_record", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|11359"}, "info": "", "params": [], "kind": {"type": "record", "private": "false", "fields": [{"name": "rr_name", "mutable": false, "type": "Dns.Dnspacket.domain_name"}, {"name": "rr_class", "mutable": false, "type": "Dns.Dnspacket.rr_class"}, {"name": "rr_ttl", "mutable": false, "type": "int32"}, {"name": "rr_rdata", "mutable": false, "type": "Dns.Dnspacket.rr_rdata"}]}}}, {"value": {"name": "Dns.Dnspacket.rr_to_string", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|11466"}, "info": "", "type": "Dns.Dnspacket.rsrc_record -> string", "params": [{"name": "", "type": "Dns.Dnspacket.rsrc_record"}]}}, {"value": {"name": "Dns.Dnspacket.parse_rr", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|11507"}, "info": "", "type": "(int, Dns.Dnspacket.label) Hashtbl.t ->\n  int ->\n  Bitstring.bitstring -> Dns.Dnspacket.rsrc_record * (string * int * int)", "params": [{"name": "", "type": "(int, Dns.Dnspacket.label) Hashtbl.t"}, {"name": "", "type": "int"}, {"name": "", "type": "Bitstring.bitstring"}]}}, {"type": {"name": "Dns.Dnspacket.q_type", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|11618"}, "info": "", "params": [], "kind": {"type": "abstract"}, "manifest": "[ `A\n  | `A6\n  | `AAAA\n  | `AFSDB\n  | `ANY\n  | `APL\n  | `ATMA\n  | `AXFR\n  | `CERT\n  | `CNAME\n  | `DLV\n  | `DNAME\n  | `DNSKEY\n  | `DS\n  | `EID\n  | `GID\n  | `GPOS\n  | `HINFO\n  | `IPSECKEY\n  | `ISDN\n  | `KEY\n  | `KM\n  | `LOC\n  | `MAILA\n  | `MAILB\n  | `MB\n  | `MD\n  | `MF\n  | `MG\n  | `MINFO\n  | `MR\n  | `MX\n  | `NAPTR\n  | `NIMLOC\n  | `NS\n  | `NSAP\n  | `NSAP_PTR\n  | `NSEC\n  | `NULL\n  | `NXT\n  | `OPT\n  | `PTR\n  | `PX\n  | `RP\n  | `RRSIG\n  | `RT\n  | `SIG\n  | `SINK\n  | `SOA\n  | `SPF\n  | `SRV\n  | `SSHFP\n  | `TA\n  | `TXT\n  | `UID\n  | `UINFO\n  | `UNSPEC\n  | `Unknown of int * Dns.Dnspacket.bytes\n  | `WKS\n  | `X25 ]"}}, {"value": {"name": "Dns.Dnspacket.int_of_q_type", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|12343"}, "info": "", "type": "Dns.Dnspacket.q_type -> int", "params": [{"name": "", "type": "Dns.Dnspacket.q_type"}]}}, {"value": {"name": "Dns.Dnspacket.q_type_of_int", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|12377"}, "info": "", "type": "int -> Dns.Dnspacket.q_type", "params": [{"name": "", "type": "int"}]}}, {"value": {"name": "Dns.Dnspacket.string_of_q_type", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|12411"}, "info": "", "type": "Dns.Dnspacket.q_type -> string", "params": [{"name": "", "type": "Dns.Dnspacket.q_type"}]}}, {"type": {"name": "Dns.Dnspacket.q_class", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|12456"}, "info": "", "params": [], "kind": {"type": "abstract"}, "manifest": "[ `ANY | `CH | `CS | `HS | `IN | `NONE ]"}}, {"value": {"name": "Dns.Dnspacket.int_of_q_class", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|12507"}, "info": "", "type": "Dns.Dnspacket.q_class -> int", "params": [{"name": "", "type": "Dns.Dnspacket.q_class"}]}}, {"value": {"name": "Dns.Dnspacket.q_class_of_int", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|12543"}, "info": "", "type": "int -> Dns.Dnspacket.q_class", "params": [{"name": "", "type": "int"}]}}, {"value": {"name": "Dns.Dnspacket.string_of_q_class", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|12579"}, "info": "", "type": "Dns.Dnspacket.q_class -> string", "params": [{"name": "", "type": "Dns.Dnspacket.q_class"}]}}, {"type": {"name": "Dns.Dnspacket.question", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|12626"}, "info": "", "params": [], "kind": {"type": "record", "private": "false", "fields": [{"name": "q_name", "mutable": false, "type": "Dns.Dnspacket.domain_name"}, {"name": "q_type", "mutable": false, "type": "Dns.Dnspacket.q_type"}, {"name": "q_class", "mutable": false, "type": "Dns.Dnspacket.q_class"}]}}}, {"value": {"name": "Dns.Dnspacket.question_to_string", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|12699"}, "info": "", "type": "Dns.Dnspacket.question -> string", "params": [{"name": "", "type": "Dns.Dnspacket.question"}]}}, {"value": {"name": "Dns.Dnspacket.parse_question", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|12743"}, "info": "", "type": "(int, Dns.Dnspacket.label) Hashtbl.t ->\n  int -> Bitstring.bitstring -> Dns.Dnspacket.question * (string * int * int)", "params": [{"name": "", "type": "(int, Dns.Dnspacket.label) Hashtbl.t"}, {"name": "", "type": "int"}, {"name": "", "type": "Bitstring.bitstring"}]}}, {"type": {"name": "Dns.Dnspacket.qr", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|12857"}, "info": "", "params": [], "kind": {"type": "abstract"}, "manifest": "[ `Answer | `Query ]"}}, {"value": {"name": "Dns.Dnspacket.qr_of_bool", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|12883"}, "info": "", "type": "bool -> [> `Answer | `Query ]", "params": [{"name": "", "type": "bool"}]}}, {"value": {"name": "Dns.Dnspacket.bool_of_qr", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|12930"}, "info": "", "type": "[< `Answer | `Query ] -> bool", "params": [{"name": "", "type": "[< `Answer | `Query ]"}]}}, {"type": {"name": "Dns.Dnspacket.opcode", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|12982"}, "info": "", "params": [], "kind": {"type": "abstract"}, "manifest": "[ `Answer | `Notify | `Query | `Reserved | `Status | `Update ]"}}, {"value": {"name": "Dns.Dnspacket.opcode_of_int", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|13054"}, "info": "", "type": "int -> [> `Answer | `Notify | `Query | `Reserved | `Status | `Update ]", "params": [{"name": "", "type": "int"}]}}, {"value": {"name": "Dns.Dnspacket.int_of_opcode", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|13145"}, "info": "", "type": "[> `Answer | `Notify | `Query | `Reserved | `Status | `Update ] -> int", "params": [{"name": "", "type": "[> `Answer | `Notify | `Query | `Reserved | `Status | `Update ]"}]}}, {"type": {"name": "Dns.Dnspacket.rcode", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|13241"}, "info": "", "params": [], "kind": {"type": "abstract"}, "manifest": "[ `BadAlg\n  | `BadKey\n  | `BadMode\n  | `BadName\n  | `BadTime\n  | `BadVers\n  | `FormErr\n  | `NXDomain\n  | `NXRRSet\n  | `NoError\n  | `NotAuth\n  | `NotImp\n  | `NotZone\n  | `Refused\n  | `ServFail\n  | `YXDomain\n  | `YXRRSet ]"}}, {"value": {"name": "Dns.Dnspacket.rcode_of_int", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|13506"}, "info": "", "type": "int ->\n  [> `BadAlg\n   | `BadKey\n   | `BadMode\n   | `BadName\n   | `BadTime\n   | `BadVers\n   | `FormErr\n   | `NXDomain\n   | `NXRRSet\n   | `NoError\n   | `NotAuth\n   | `NotImp\n   | `NotZone\n   | `Refused\n   | `ServFail\n   | `YXDomain\n   | `YXRRSet ]", "params": [{"name": "", "type": "int"}]}}, {"value": {"name": "Dns.Dnspacket.int_of_rcode", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|13774"}, "info": "", "type": "[> `BadAlg\n   | `BadKey\n   | `BadMode\n   | `BadName\n   | `BadTime\n   | `BadVers\n   | `FormErr\n   | `NXDomain\n   | `NXRRSet\n   | `NoError\n   | `NotAuth\n   | `NotImp\n   | `NotZone\n   | `Refused\n   | `ServFail\n   | `YXDomain\n   | `YXRRSet ] ->\n  int", "params": [{"name": "", "type": "[> `BadAlg\n   | `BadKey\n   | `BadMode\n   | `BadName\n   | `BadTime\n   | `BadVers\n   | `FormErr\n   | `NXDomain\n   | `NXRRSet\n   | `NoError\n   | `NotAuth\n   | `NotImp\n   | `NotZone\n   | `Refused\n   | `ServFail\n   | `YXDomain\n   | `YXRRSet ]"}]}}, {"type": {"name": "Dns.Dnspacket.detail", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|14047"}, "info": "", "params": [], "kind": {"type": "record", "private": "false", "fields": [{"name": "qr", "mutable": false, "type": "Dns.Dnspacket.qr"}, {"name": "opcode", "mutable": false, "type": "Dns.Dnspacket.opcode"}, {"name": "aa", "mutable": false, "type": "bool"}, {"name": "tc", "mutable": false, "type": "bool"}, {"name": "rd", "mutable": false, "type": "bool"}, {"name": "ra", "mutable": false, "type": "bool"}, {"name": "rcode", "mutable": false, "type": "Dns.Dnspacket.rcode"}]}}}, {"value": {"name": "Dns.Dnspacket.detail_to_string", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|14159"}, "info": "", "type": "Dns.Dnspacket.detail -> string", "params": [{"name": "", "type": "Dns.Dnspacket.detail"}]}}, {"value": {"name": "Dns.Dnspacket.parse_detail", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|14199"}, "info": "", "type": "string * int * int -> Dns.Dnspacket.detail", "params": [{"tuple": {"type": "string * int * int", "contents": [{"name": "", "type": "string"}, {"name": "", "type": "int"}, {"name": "", "type": "int"}]}}]}}, {"value": {"name": "Dns.Dnspacket.build_detail", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|14247"}, "info": "", "type": "Dns.Dnspacket.detail -> Bitstring.bitstring", "params": [{"name": "", "type": "Dns.Dnspacket.detail"}]}}, {"type": {"name": "Dns.Dnspacket.dns", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|14301"}, "info": "", "params": [], "kind": {"type": "record", "private": "false", "fields": [{"name": "id", "mutable": false, "type": "Dns.Dnspacket.int16"}, {"name": "detail", "mutable": false, "type": "Bitstring.t"}, {"name": "questions", "mutable": false, "type": "Dns.Dnspacket.question list"}, {"name": "answers", "mutable": false, "type": "Dns.Dnspacket.rsrc_record list"}, {"name": "authorities", "mutable": false, "type": "Dns.Dnspacket.rsrc_record list"}, {"name": "additionals", "mutable": false, "type": "Dns.Dnspacket.rsrc_record list"}]}}}, {"value": {"name": "Dns.Dnspacket.dns_to_string", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|14476"}, "info": "", "type": "Dns.Dnspacket.dns -> string", "params": [{"name": "", "type": "Dns.Dnspacket.dns"}]}}, {"value": {"name": "Dns.Dnspacket.parse_dns", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|14510"}, "info": "", "type": "(int, Dns.Dnspacket.label) Hashtbl.t ->\n  Bitstring.bitstring -> Dns.Dnspacket.dns", "params": [{"name": "", "type": "(int, Dns.Dnspacket.label) Hashtbl.t"}, {"name": "", "type": "Bitstring.bitstring"}]}}, {"value": {"name": "Dns.Dnspacket.marshal", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|14579"}, "info": "", "type": "Dns.Dnspacket.dns -> Bitstring.bitstring", "params": [{"name": "", "type": "Dns.Dnspacket.dns"}]}}], "dependencies": {"uses": []}}}, {"module": {"name": "Dns.Dnsquery", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|14624"}, "info": "", "type": "sig  end", "module_structure": [{"type": {"name": "Dns.Dnsquery.query_answer", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|14653"}, "info": "", "params": [], "kind": {"type": "record", "private": "false", "fields": [{"name": "rcode", "mutable": false, "type": "Dns.Dnspacket.rcode"}, {"name": "aa", "mutable": false, "type": "bool"}, {"name": "answer", "mutable": false, "type": "Dns.Dnspacket.rsrc_record list"}, {"name": "authority", "mutable": false, "type": "Dns.Dnspacket.rsrc_record list"}, {"name": "additional", "mutable": false, "type": "Dns.Dnspacket.rsrc_record list"}]}}}, {"value": {"name": "Dns.Dnsquery.answer_query", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|14833"}, "info": "", "type": "string list ->\n  Dns.Dnspacket.q_type -> Dns.Dnstrie.dnstrie -> Dns.Dnsquery.query_answer", "params": [{"name": "", "type": "string list"}, {"name": "", "type": "Dns.Dnspacket.q_type"}, {"name": "", "type": "Dns.Dnstrie.dnstrie"}]}}], "dependencies": {"uses": []}}}, {"module": {"name": "Dns.Dnsparser", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|14926"}, "info": "", "type": "sig  end", "module_structure": [{"type": {"name": "Dns.Dnsparser.token", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|14954"}, "info": "", "params": [], "kind": {"type": "variant", "private": "false", "constructors": [{"name": "EOF", "type": []}, {"name": "EOL", "type": []}, {"name": "SORIGIN", "type": []}, {"name": "STTL", "type": []}, {"name": "AT", "type": []}, {"name": "DOT", "type": []}, {"name": "SPACE", "type": []}, {"name": "GENERIC", "type": []}, {"name": "NUMBER", "type": ["string"]}, {"name": "CHARSTRING", "type": ["string"]}, {"name": "TYPE_A", "type": ["string"]}, {"name": "TYPE_NS", "type": ["string"]}, {"name": "TYPE_MD", "type": ["string"]}, {"name": "TYPE_MF", "type": ["string"]}, {"name": "TYPE_CNAME", "type": ["string"]}, {"name": "TYPE_SOA", "type": ["string"]}, {"name": "TYPE_MB", "type": ["string"]}, {"name": "TYPE_MG", "type": ["string"]}, {"name": "TYPE_MR", "type": ["string"]}, {"name": "TYPE_NULL", "type": ["string"]}, {"name": "TYPE_WKS", "type": ["string"]}, {"name": "TYPE_PTR", "type": ["string"]}, {"name": "TYPE_HINFO", "type": ["string"]}, {"name": "TYPE_MINFO", "type": ["string"]}, {"name": "TYPE_MX", "type": ["string"]}, {"name": "TYPE_TXT", "type": ["string"]}, {"name": "TYPE_RP", "type": ["string"]}, {"name": "TYPE_AFSDB", "type": ["string"]}, {"name": "TYPE_X25", "type": ["string"]}, {"name": "TYPE_ISDN", "type": ["string"]}, {"name": "TYPE_RT", "type": ["string"]}, {"name": "TYPE_NSAP", "type": ["string"]}, {"name": "TYPE_NSAP_PTR", "type": ["string"]}, {"name": "TYPE_SIG", "type": ["string"]}, {"name": "TYPE_KEY", "type": ["string"]}, {"name": "TYPE_PX", "type": ["string"]}, {"name": "TYPE_GPOS", "type": ["string"]}, {"name": "TYPE_AAAA", "type": ["string"]}, {"name": "TYPE_LOC", "type": ["string"]}, {"name": "TYPE_NXT", "type": ["string"]}, {"name": "TYPE_EID", "type": ["string"]}, {"name": "TYPE_NIMLOC", "type": ["string"]}, {"name": "TYPE_SRV", "type": ["string"]}, {"name": "TYPE_ATMA", "type": ["string"]}, {"name": "TYPE_NAPTR", "type": ["string"]}, {"name": "TYPE_KX", "type": ["string"]}, {"name": "TYPE_CERT", "type": ["string"]}, {"name": "TYPE_A6", "type": ["string"]}, {"name": "TYPE_DNAME", "type": ["string"]}, {"name": "TYPE_SINK", "type": ["string"]}, {"name": "TYPE_OPT", "type": ["string"]}, {"name": "TYPE_APL", "type": ["string"]}, {"name": "TYPE_DS", "type": ["string"]}, {"name": "TYPE_SSHFP", "type": ["string"]}, {"name": "TYPE_IPSECKEY", "type": ["string"]}, {"name": "TYPE_RRSIG", "type": ["string"]}, {"name": "TYPE_NSEC", "type": ["string"]}, {"name": "TYPE_DNSKEY", "type": ["string"]}, {"name": "TYPE_SPF", "type": ["string"]}, {"name": "TYPE_UINFO", "type": ["string"]}, {"name": "TYPE_UID", "type": ["string"]}, {"name": "TYPE_GID", "type": ["string"]}, {"name": "TYPE_UNSPEC", "type": ["string"]}, {"name": "TYPE_TKEY", "type": ["string"]}, {"name": "TYPE_TSIG", "type": ["string"]}, {"name": "TYPE_MAILB", "type": ["string"]}, {"name": "TYPE_MAILA", "type": ["string"]}, {"name": "TYPE_GENERIC", "type": ["string"]}, {"name": "CLASS_IN", "type": ["string"]}, {"name": "CLASS_CS", "type": ["string"]}, {"name": "CLASS_CH", "type": ["string"]}, {"name": "CLASS_HS", "type": ["string"]}]}}}, {"value": {"name": "Dns.Dnsparser.zfile", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|16678"}, "info": "", "type": "(Lexing.lexbuf -> Dns.Dnsparser.token) -> Lexing.lexbuf -> unit", "params": [{"name": "", "type": "Lexing.lexbuf -> Dns.Dnsparser.token"}, {"name": "", "type": "Lexing.lexbuf"}]}}], "dependencies": {"uses": []}}}, {"module": {"name": "Dns.Dnsserver", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|16747"}, "info": "", "type": "sig  end", "module_structure": [{"value": {"name": "Dns.Dnsserver.load_zone", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|16772"}, "info": "", "type": "string list -> string -> unit", "params": [{"name": "", "type": "string list"}, {"name": "", "type": "string"}]}}], "dependencies": {"uses": []}}}, {"module": {"name": "Dns.Server", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|16822"}, "info": "", "type": "sig  end", "module_structure": [{"value": {"name": "Dns.Server.listen", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dns.mli|16965"}, "info": "", "type": "?mode:[< `leaky | `none > `none ] ->\n  zonebuf:string ->\n  Net.Datagram.UDPv4.mgr -> Net.Datagram.UDPv4.src -> unit Lwt.t", "params": [{"name": "mode", "type": "[< `leaky | `none > `none ] option"}, {"name": "zonebuf", "type": "string"}, {"name": "", "type": "Net.Datagram.UDPv4.mgr"}, {"name": "", "type": "Net.Datagram.UDPv4.src"}]}}], "dependencies": {"uses": []}}}], "dependencies": {"uses": ["Net", "Lwt", "Lexing", "Hashtbl", "Bitstring", "*predef*"], "used_by": []}}}, "Http": {"module": {"name": "Http", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|0"}, "info": {"description": "Type definitions"}, "type": "sig  end", "module_structure": [{"module": {"name": "Http.Types", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|0"}, "info": "", "type": "sig  end", "module_structure": [{"comment": "Type definitions"}, {"type": {"name": "Http.Types.version", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|1061"}, "info": {"description": "HTTP version, actually only 1.0 and 1.1 are supported. Note that 'supported' here means only 'accepted inside a HTTP request line', no different behaviours are actually implemented depending on HTTP version"}, "params": [], "kind": {"type": "abstract"}, "manifest": "[ `HTTP_1_0 | `HTTP_1_1 ]"}}, {"type": {"name": "Http.Types.meth", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|1180"}, "info": {"description": "HTTP method, actually only GET and POST methods are supported"}, "params": [], "kind": {"type": "abstract"}, "manifest": "[ `DELETE | `GET | `HEAD | `POST ]"}}, {"type": {"name": "Http.Types.auth_info", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|1274"}, "info": {"description": "authentication information"}, "params": [], "kind": {"type": "abstract"}, "manifest": "[ `Basic of string * (string -> string -> bool) | `None ]"}}, {"type": {"name": "Http.Types.informational_status", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|1496"}, "info": {"see": [{"doc": "RFC2616", "text": "informational HTTP status"}]}, "params": [], "kind": {"type": "abstract"}, "manifest": "[ `Continue | `Switching_protocols ]"}}, {"type": {"name": "Http.Types.success_status", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|1612"}, "info": {"see": [{"doc": "RFC2616", "text": "success HTTP status"}]}, "params": [], "kind": {"type": "abstract"}, "manifest": "[ `Accepted\n  | `Created\n  | `No_content\n  | `Non_authoritative_information\n  | `OK\n  | `Partial_content\n  | `Reset_content ]"}}, {"type": {"name": "Http.Types.redirection_status", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|1813"}, "info": {"see": [{"doc": "RFC2616", "text": "redirection HTTP status"}]}, "params": [], "kind": {"type": "abstract"}, "manifest": "[ `Found\n  | `Moved_permanently\n  | `Multiple_choices\n  | `Not_modified\n  | `See_other\n  | `Temporary_redirect\n  | `Use_proxy ]"}}, {"type": {"name": "Http.Types.client_error_status", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|2021"}, "info": {"see": [{"doc": "RFC2616", "text": "client error HTTP status"}]}, "params": [], "kind": {"type": "abstract"}, "manifest": "[ `Bad_request\n  | `Conflict\n  | `Expectation_failed\n  | `Forbidden\n  | `Gone\n  | `Length_required\n  | `Method_not_allowed\n  | `Not_acceptable\n  | `Not_found\n  | `Payment_required\n  | `Precondition_failed\n  | `Proxy_authentication_required\n  | `Request_URI_too_large\n  | `Request_entity_too_large\n  | `Request_time_out\n  | `Requested_range_not_satisfiable\n  | `Unauthorized\n  | `Unsupported_media_type ]"}}, {"type": {"name": "Http.Types.server_error_status", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|2506"}, "info": {"see": [{"doc": "RFC2616", "text": "server error HTTP status"}]}, "params": [], "kind": {"type": "abstract"}, "manifest": "[ `Bad_gateway\n  | `Gateway_time_out\n  | `HTTP_version_not_supported\n  | `Internal_server_error\n  | `Not_implemented\n  | `Service_unavailable ]"}}, {"type": {"name": "Http.Types.error_status", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|2682"}, "info": "", "params": [], "kind": {"type": "abstract"}, "manifest": "[ `Bad_gateway\n  | `Bad_request\n  | `Conflict\n  | `Expectation_failed\n  | `Forbidden\n  | `Gateway_time_out\n  | `Gone\n  | `HTTP_version_not_supported\n  | `Internal_server_error\n  | `Length_required\n  | `Method_not_allowed\n  | `Not_acceptable\n  | `Not_found\n  | `Not_implemented\n  | `Payment_required\n  | `Precondition_failed\n  | `Proxy_authentication_required\n  | `Request_URI_too_large\n  | `Request_entity_too_large\n  | `Request_time_out\n  | `Requested_range_not_satisfiable\n  | `Service_unavailable\n  | `Unauthorized\n  | `Unsupported_media_type ]"}}, {"type": {"name": "Http.Types.status", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|2776"}, "info": {"description": "HTTP status"}, "params": [], "kind": {"type": "abstract"}, "manifest": "[ `Accepted\n  | `Bad_gateway\n  | `Bad_request\n  | `Conflict\n  | `Continue\n  | `Created\n  | `Expectation_failed\n  | `Forbidden\n  | `Found\n  | `Gateway_time_out\n  | `Gone\n  | `HTTP_version_not_supported\n  | `Internal_server_error\n  | `Length_required\n  | `Method_not_allowed\n  | `Moved_permanently\n  | `Multiple_choices\n  | `No_content\n  | `Non_authoritative_information\n  | `Not_acceptable\n  | `Not_found\n  | `Not_implemented\n  | `Not_modified\n  | `OK\n  | `Partial_content\n  | `Payment_required\n  | `Precondition_failed\n  | `Proxy_authentication_required\n  | `Request_URI_too_large\n  | `Request_entity_too_large\n  | `Request_time_out\n  | `Requested_range_not_satisfiable\n  | `Reset_content\n  | `See_other\n  | `Service_unavailable\n  | `Switching_protocols\n  | `Temporary_redirect\n  | `Unauthorized\n  | `Unsupported_media_type\n  | `Use_proxy ]"}}, {"type": {"name": "Http.Types.status_code", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|2910"}, "info": "", "params": [], "kind": {"type": "abstract"}, "manifest": "[ `Accepted\n  | `Bad_gateway\n  | `Bad_request\n  | `Code of int\n  | `Conflict\n  | `Continue\n  | `Created\n  | `Expectation_failed\n  | `Forbidden\n  | `Found\n  | `Gateway_time_out\n  | `Gone\n  | `HTTP_version_not_supported\n  | `Internal_server_error\n  | `Length_required\n  | `Method_not_allowed\n  | `Moved_permanently\n  | `Multiple_choices\n  | `No_content\n  | `Non_authoritative_information\n  | `Not_acceptable\n  | `Not_found\n  | `Not_implemented\n  | `Not_modified\n  | `OK\n  | `Partial_content\n  | `Payment_required\n  | `Precondition_failed\n  | `Proxy_authentication_required\n  | `Request_URI_too_large\n  | `Request_entity_too_large\n  | `Request_time_out\n  | `Requested_range_not_satisfiable\n  | `Reset_content\n  | `See_other\n  | `Service_unavailable\n  | `Switching_protocols\n  | `Temporary_redirect\n  | `Unauthorized\n  | `Unsupported_media_type\n  | `Use_proxy ]"}}, {"comment": "<h2>Exceptions<\/h2>"}, {"exception": {"name": "Http.Types.Invalid_header", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|3012"}, "info": {"description": "invalid header encountered"}, "exception_args": ["string"]}}, {"exception": {"name": "Http.Types.Invalid_header_name", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|3089"}, "info": {"description": "invalid header name encountered"}, "exception_args": ["string"]}}, {"exception": {"name": "Http.Types.Invalid_header_value", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|3172"}, "info": {"description": "invalid header value encountered"}, "exception_args": ["string"]}}, {"exception": {"name": "Http.Types.Invalid_HTTP_version", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|3271"}, "info": {"description": "unsupported or invalid HTTP version encountered"}, "exception_args": ["string"]}}, {"exception": {"name": "Http.Types.Invalid_HTTP_method", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|3369"}, "info": {"description": "unsupported or invalid HTTP method encountered"}, "exception_args": ["string"]}}, {"exception": {"name": "Http.Types.Invalid_code", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|3479"}, "info": {"description": "invalid HTTP status code integer representation encountered"}, "exception_args": ["int"]}}, {"exception": {"name": "Http.Types.Malformed_URL", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|3543"}, "info": {"description": "invalid URL encountered"}, "exception_args": ["string"]}}, {"exception": {"name": "Http.Types.Malformed_query", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|3620"}, "info": {"description": "invalid query string encountered"}, "exception_args": ["string"]}}, {"exception": {"name": "Http.Types.Malformed_query_part", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|3756"}, "info": {"description": "invalid query string part encountered, arguments are parameter name and parameter value"}, "exception_args": ["string", "string"]}}, {"exception": {"name": "Http.Types.Malformed_request_URI", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|3848"}, "info": {"description": "invalid request URI encountered"}, "exception_args": ["string"]}}, {"exception": {"name": "Http.Types.Malformed_request", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|3927"}, "info": {"description": "malformed request received"}, "exception_args": ["string"]}}, {"exception": {"name": "Http.Types.Malformed_response", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|4038"}, "info": {"description": "malformed response received, argument is response's first line"}, "exception_args": ["string"]}}, {"exception": {"name": "Http.Types.Param_not_found", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|4134"}, "info": {"description": "a parameter you were looking for was not found"}, "exception_args": ["string"]}}, {"exception": {"name": "Http.Types.Invalid_status_line", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|4217"}, "info": {"description": "invalid HTTP status line encountered"}, "exception_args": ["string"]}}, {"exception": {"name": "Http.Types.Header_not_found", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|4312"}, "info": {"description": "an header you were looking for was not found"}, "exception_args": ["string"]}}, {"exception": {"name": "Http.Types.Unauthorized", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|4590"}, "info": {"description": "raisable by callbacks to force a 401 (unauthorized) HTTP answer. This exception should be raised _before_ sending any data over given out channel."}, "exception_args": ["string"]}}], "dependencies": {"uses": []}}}, {"module": {"name": "Http.Misc", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|4627"}, "info": "", "type": "sig  end", "module_structure": [{"comment": "Helpers and other not better classified functions which should not be exposed in the final API"}, {"value": {"name": "Http.Misc.date_822", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|5654"}, "info": {"return": "the current date compliant to RFC 1123, which updates RFC 822 zone info are retrieved from UTC"}, "type": "unit -> string", "params": [{"name": "", "type": "unit"}]}}, {"value": {"name": "Http.Misc.rfc822_of_float", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|5752"}, "info": {"description": "Convert a number of seconds to a date compliant with RFC 822"}, "type": "float -> string", "params": [{"name": "", "type": "float"}]}}, {"value": {"name": "Http.Misc.strip_trailing_slash", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|5869"}, "info": {"description": "strip trailing '\/', if any, from a string and", "return": "the new string"}, "type": "string -> string", "params": [{"name": "", "type": "string"}]}}, {"value": {"name": "Http.Misc.strip_heading_slash", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|5990"}, "info": {"description": "strip heading '\/', if any, from a string and", "return": "the new string"}, "type": "string -> string", "params": [{"name": "", "type": "string"}]}}, {"value": {"name": "Http.Misc.reason_phrase_of_code", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|6109"}, "info": {"description": "given an HTTP response code return the corresponding reason phrase"}, "type": "int -> string", "params": [{"name": "", "type": "int"}]}}, {"value": {"name": "Http.Misc.list_assoc_all", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|6250"}, "info": {"description": "like List.assoc but return all bindings of a given key instead of the leftmost one only"}, "type": "'a -> ('a * 'b) list -> 'b list", "params": [{"name": "", "type": "'a"}, {"name": "", "type": "('a * 'b) list"}]}}, {"value": {"name": "Http.Misc.warn", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|6303"}, "info": {"description": "print a warning msg to stderr. Adds trailing \\n"}, "type": "string -> unit", "params": [{"name": "", "type": "string"}]}}, {"value": {"name": "Http.Misc.error", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|6383"}, "info": {"description": "print an error msg to stderr. Adds trailing \\n"}, "type": "string -> unit", "params": [{"name": "", "type": "string"}]}}], "dependencies": {"uses": []}}}, {"module": {"name": "Http.Url", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|6468"}, "info": "", "type": "sig  end", "module_structure": [{"type": {"name": "Http.Url.t", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|6508"}, "info": {"description": "URL type"}, "params": [], "kind": {"type": "record", "private": "false", "fields": [{"name": "scheme", "mutable": false, "type": "string option"}, {"name": "userinfo", "mutable": false, "type": "string option"}, {"name": "host", "mutable": false, "type": "string option"}, {"name": "port", "mutable": false, "type": "int option"}, {"name": "path", "mutable": false, "type": "string list option"}, {"name": "path_string", "mutable": false, "type": "string option"}, {"name": "query", "mutable": false, "type": "(string * string) list option"}, {"name": "query_string", "mutable": false, "type": "string option"}, {"name": "fragment", "mutable": false, "type": "string option"}]}}}, {"value": {"name": "Http.Url.full_path", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|6906"}, "info": {"description": "Get the full path of an url (ie. including leading \/, queries and fragments"}, "type": "Http.Url.t -> string", "params": [{"name": "", "type": "Http.Url.t"}]}}, {"value": {"name": "Http.Url.to_string", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|6978"}, "info": {"description": "Build an encoded string from an URL"}, "type": "Http.Url.t -> string", "params": [{"name": "", "type": "Http.Url.t"}]}}, {"value": {"name": "Http.Url.of_string", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|7050"}, "info": {"description": "Build an URL from an encoded string"}, "type": "string -> Http.Url.t", "params": [{"name": "", "type": "string"}]}}, {"value": {"name": "Http.Url.encode", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|7108"}, "info": {"description": "URL encode the string"}, "type": "string -> string", "params": [{"name": "", "type": "string"}]}}, {"value": {"name": "Http.Url.decode", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|7168"}, "info": {"description": "URL decode the string"}, "type": "string -> string", "params": [{"name": "", "type": "string"}]}}], "dependencies": {"uses": []}}}, {"module": {"name": "Http.Common", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|7202"}, "info": "", "type": "sig  end", "module_structure": [{"comment": "Common functionalities shared by other OCaml HTTP modules"}, {"value": {"name": "Http.Common.string_of_version", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|8132"}, "info": {"description": "pretty print an HTTP version"}, "type": "Http.Types.version -> string", "params": [{"name": "", "type": "Http.Types.version"}]}}, {"value": {"name": "Http.Common.version_of_string", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|8310"}, "info": {"description": "parse an HTTP version from a string", "raised_exceptions": [{"raised_exception": "Invalid_HTTP_version", "text": "if given string doesn't represent a supported HTTP version"}]}, "type": "string -> Http.Types.version", "params": [{"name": "", "type": "string"}]}}, {"value": {"name": "Http.Common.string_of_method", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|8389"}, "info": {"description": "pretty print an HTTP method"}, "type": "Http.Types.meth -> string", "params": [{"name": "", "type": "Http.Types.meth"}]}}, {"value": {"name": "Http.Common.method_of_string", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|8555"}, "info": {"description": "parse an HTTP method from a string", "raised_exceptions": [{"raised_exception": "Invalid_HTTP_method", "text": "if given string doesn't represent a supported method"}]}, "type": "string -> Http.Types.meth", "params": [{"name": "", "type": "string"}]}}, {"value": {"name": "Http.Common.status_of_code", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|8738"}, "info": {"description": "converts an integer HTTP status to the corresponding status value", "raised_exceptions": [{"raised_exception": "Invalid_code", "text": "if given integer isn't a valid HTTP status code"}]}, "type": "int -> Http.Types.status", "params": [{"name": "", "type": "int"}]}}, {"value": {"name": "Http.Common.code_of_status", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|8841"}, "info": {"description": "converts an HTTP status to the corresponding integer value"}, "type": "[< Http.Types.status ] -> int", "params": [{"name": "", "type": "[< Http.Types.status ]"}]}}, {"value": {"name": "Http.Common.is_informational", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|8951"}, "info": {"return": "true on \"informational\" status codes, false elsewhere"}, "type": "int -> bool", "params": [{"name": "", "type": "int"}]}}, {"value": {"name": "Http.Common.is_success", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|9051"}, "info": {"return": "true on \"success\" status codes, false elsewhere"}, "type": "int -> bool", "params": [{"name": "", "type": "int"}]}}, {"value": {"name": "Http.Common.is_redirection", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|9149"}, "info": {"return": "true on \"redirection\" status codes, false elsewhere"}, "type": "int -> bool", "params": [{"name": "", "type": "int"}]}}, {"value": {"name": "Http.Common.is_client_error", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|9252"}, "info": {"return": "true on \"client error\" status codes, false elsewhere"}, "type": "int -> bool", "params": [{"name": "", "type": "int"}]}}, {"value": {"name": "Http.Common.is_server_error", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|9356"}, "info": {"return": "true on \"server error\" status codes, false elsewhere"}, "type": "int -> bool", "params": [{"name": "", "type": "int"}]}}, {"value": {"name": "Http.Common.is_error", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|9480"}, "info": {"return": "true on \"client error\" and \"server error\" status code, false elsewhere"}, "type": "int -> bool", "params": [{"name": "", "type": "int"}]}}], "dependencies": {"uses": []}}}, {"module": {"name": "Http.Constants", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|9511"}, "info": "", "type": "sig  end", "module_structure": [{"comment": "Constants"}, {"value": {"name": "Http.Constants.default_version", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|10344"}, "info": "", "type": "Http.Types.version", "params": []}}, {"value": {"name": "Http.Constants.server_string", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|10380"}, "info": "", "type": "string", "params": []}}, {"value": {"name": "Http.Constants.crlf", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|10407"}, "info": "", "type": "string", "params": []}}], "dependencies": {"uses": []}}}, {"module": {"name": "Http.Message", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|10428"}, "info": "", "type": "sig  end", "module_structure": [{"type": {"name": "Http.Message.contents", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|10454"}, "info": "", "params": [], "kind": {"type": "abstract"}, "manifest": "[ `Inchan of int64 * Bitstring.t Lwt_stream.t | `String of string ]"}}, {"type": {"name": "Http.Message.message", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|10543"}, "info": "", "params": [], "kind": {"type": "abstract"}}}, {"value": {"name": "Http.Message.body", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|10551"}, "info": "", "type": "Http.Message.message -> Http.Message.contents list", "params": [{"name": "", "type": "Http.Message.message"}]}}, {"value": {"name": "Http.Message.body_size", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|10587"}, "info": "", "type": "Http.Message.contents list -> int64", "params": [{"name": "", "type": "Http.Message.contents list"}]}}, {"value": {"name": "Http.Message.set_body", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|10626"}, "info": "", "type": "Http.Message.message -> Http.Message.contents -> unit", "params": [{"name": "", "type": "Http.Message.message"}, {"name": "", "type": "Http.Message.contents"}]}}, {"value": {"name": "Http.Message.add_body", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|10669"}, "info": "", "type": "Http.Message.message -> Http.Message.contents -> unit", "params": [{"name": "", "type": "Http.Message.message"}, {"name": "", "type": "Http.Message.contents"}]}}, {"value": {"name": "Http.Message.add_header", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|10712"}, "info": "", "type": "Http.Message.message -> name:string -> value:string -> unit", "params": [{"name": "", "type": "Http.Message.message"}, {"name": "name", "type": "string"}, {"name": "value", "type": "string"}]}}, {"value": {"name": "Http.Message.add_headers", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|10776"}, "info": "", "type": "Http.Message.message -> (string * string) list -> unit", "params": [{"name": "", "type": "Http.Message.message"}, {"name": "", "type": "(string * string) list"}]}}, {"value": {"name": "Http.Message.replace_header", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|10836"}, "info": "", "type": "Http.Message.message -> name:string -> value:string -> unit", "params": [{"name": "", "type": "Http.Message.message"}, {"name": "name", "type": "string"}, {"name": "value", "type": "string"}]}}, {"value": {"name": "Http.Message.replace_headers", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|10904"}, "info": "", "type": "Http.Message.message -> (string * string) list -> unit", "params": [{"name": "", "type": "Http.Message.message"}, {"name": "", "type": "(string * string) list"}]}}, {"value": {"name": "Http.Message.remove_header", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|10968"}, "info": "", "type": "Http.Message.message -> name:string -> unit", "params": [{"name": "", "type": "Http.Message.message"}, {"name": "name", "type": "string"}]}}, {"value": {"name": "Http.Message.has_header", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|11019"}, "info": "", "type": "Http.Message.message -> name:string -> bool", "params": [{"name": "", "type": "Http.Message.message"}, {"name": "name", "type": "string"}]}}, {"value": {"name": "Http.Message.header", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|11067"}, "info": "", "type": "Http.Message.message -> name:string -> string list", "params": [{"name": "", "type": "Http.Message.message"}, {"name": "name", "type": "string"}]}}, {"value": {"name": "Http.Message.headers", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|11118"}, "info": "", "type": "Http.Message.message -> (string * string) list", "params": [{"name": "", "type": "Http.Message.message"}]}}, {"value": {"name": "Http.Message.version", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|11166"}, "info": "", "type": "Http.Message.message -> Http.Types.version", "params": [{"name": "", "type": "Http.Message.message"}]}}, {"value": {"name": "Http.Message.init", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|11205"}, "info": "", "type": "body:Http.Message.contents list ->\n  headers:(string * string) list ->\n  version:Http.Types.version -> Http.Message.message", "params": [{"name": "body", "type": "Http.Message.contents list"}, {"name": "headers", "type": "(string * string) list"}, {"name": "version", "type": "Http.Types.version"}]}}, {"value": {"name": "Http.Message.serialize_to_channel", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|11311"}, "info": "", "type": "Http.Message.message -> fstLineToString:string -> Net.Channel.t -> unit Lwt.t", "params": [{"name": "", "type": "Http.Message.message"}, {"name": "fstLineToString", "type": "string"}, {"name": "", "type": "Net.Channel.t"}]}}], "dependencies": {"uses": []}}}, {"module": {"name": "Http.Parser", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|11409"}, "info": "", "type": "sig  end", "module_structure": [{"comment": "HTTP messages parsing"}, {"value": {"name": "Http.Parser.parse_request_fst_line", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|12673"}, "info": {"description": "parse 1st line of an HTTP request", "raised_exceptions": [{"raised_exception": "Malformed_request", "text": "if request 1st linst isn't well formed"}, {"raised_exception": "Malformed_request_URI", "text": "if requested URI isn't well formed"}], "return": "a triple meth * url * version, meth is the HTTP method invoked, url is the requested url, version is the HTTP version specified or None if no version was specified"}, "type": "(unit -> string Lwt.t) ->\n  (Http.Types.meth * Http.Url.t * Http.Types.version) Lwt.t", "params": [{"name": "", "type": "unit -> string Lwt.t"}]}}, {"value": {"name": "Http.Parser.parse_response_fst_line", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|12927"}, "info": {"description": "parse 1st line of an HTTP response ", "raised_exceptions": [{"raised_exception": "Malformed_response", "text": "if first line isn't well formed"}]}, "type": "(unit -> string Lwt.t) -> (Http.Types.version * Http.Types.status) Lwt.t", "params": [{"name": "", "type": "unit -> string Lwt.t"}]}}, {"value": {"name": "Http.Parser.parse_headers", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|13266"}, "info": {"description": "parse HTTP headers. Consumes also trailing CRLF at the end of header list", "raised_exceptions": [{"raised_exception": "Invalid_header", "text": "if a not well formed header is encountered"}], "return": "a list of pairs header_name * header_value"}, "type": "(unit -> string Lwt.t) -> (string * string) list Lwt.t", "params": [{"name": "", "type": "unit -> string Lwt.t"}]}}, {"value": {"name": "Http.Parser.parse_request", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|13581"}, "info": {"description": "given an input channel, reads from it a GET HTTP request and", "return": "a pair &lt;path, query_params&gt; where path is a string representing the requested path and query_params is a list of pairs &lt;name, value&gt; (the GET parameters)"}, "type": "(unit -> string Lwt.t) -> (string * (string * string) list) Lwt.t", "params": [{"name": "", "type": "unit -> string Lwt.t"}]}}, {"value": {"name": "Http.Parser.parse_content_range", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|13793"}, "info": {"description": "parse content-range header in a request", "return": "number of bytes to read, or None if all available should be read"}, "type": "(string * string) list -> int option", "params": [{"name": "", "type": "(string * string) list"}]}}], "dependencies": {"uses": []}}}, {"module": {"name": "Http.Request", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|13859"}, "info": "", "type": "sig  end", "module_structure": [{"type": {"name": "Http.Request.request", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|13904"}, "info": "", "params": [], "kind": {"type": "abstract"}}}, {"value": {"name": "Http.Request.init_request", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|13912"}, "info": "", "type": "unit Lwt.u -> (unit -> string Lwt.t) -> Http.Request.request Lwt.t", "params": [{"name": "", "type": "unit Lwt.u"}, {"name": "", "type": "unit -> string Lwt.t"}]}}, {"value": {"name": "Http.Request.meth", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|13985"}, "info": "", "type": "Http.Request.request -> Http.Types.meth", "params": [{"name": "", "type": "Http.Request.request"}]}}, {"value": {"name": "Http.Request.uri", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|14018"}, "info": "", "type": "Http.Request.request -> string", "params": [{"name": "", "type": "Http.Request.request"}]}}, {"value": {"name": "Http.Request.path", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|14046"}, "info": "", "type": "Http.Request.request -> string", "params": [{"name": "", "type": "Http.Request.request"}]}}, {"value": {"name": "Http.Request.body", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|14075"}, "info": "", "type": "Http.Request.request -> Http.Message.contents list", "params": [{"name": "", "type": "Http.Request.request"}]}}, {"value": {"name": "Http.Request.param", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|14119"}, "info": "", "type": "?meth:[< `GET | `POST ] ->\n  ?default:string -> Http.Request.request -> string -> string", "params": [{"name": "meth", "type": "[< `GET | `POST ] option"}, {"name": "default", "type": "string option"}, {"name": "", "type": "Http.Request.request"}, {"name": "", "type": "string"}]}}, {"value": {"name": "Http.Request.param_all", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|14207"}, "info": "", "type": "?meth:Http.Types.meth -> Http.Request.request -> string -> string list", "params": [{"name": "meth", "type": "Http.Types.meth option"}, {"name": "", "type": "Http.Request.request"}, {"name": "", "type": "string"}]}}, {"value": {"name": "Http.Request.params", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|14276"}, "info": "", "type": "Http.Request.request -> (string, string) Hashtbl.t", "params": [{"name": "", "type": "Http.Request.request"}]}}, {"value": {"name": "Http.Request.params_get", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|14327"}, "info": "", "type": "Http.Request.request -> (string * string) list", "params": [{"name": "", "type": "Http.Request.request"}]}}, {"value": {"name": "Http.Request.params_post", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|14378"}, "info": "", "type": "Http.Request.request -> (string * string) list", "params": [{"name": "", "type": "Http.Request.request"}]}}, {"value": {"name": "Http.Request.authorization", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|14430"}, "info": "", "type": "Http.Request.request -> [> `Basic of string * string ] option", "params": [{"name": "", "type": "Http.Request.request"}]}}, {"value": {"name": "Http.Request.header", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|14499"}, "info": "", "type": "Http.Request.request -> name:string -> string list", "params": [{"name": "", "type": "Http.Request.request"}, {"name": "name", "type": "string"}]}}], "dependencies": {"uses": []}}}, {"module": {"name": "Http.Response", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|14554"}, "info": "", "type": "sig  end", "module_structure": [{"type": {"name": "Http.Response.response", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|14600"}, "info": "", "params": [], "kind": {"type": "abstract"}}}, {"value": {"name": "Http.Response.init", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|14609"}, "info": "", "type": "?body:Http.Message.contents list ->\n  ?headers:(string * string) list ->\n  ?version:Http.Types.version ->\n  ?status:Http.Types.status_code ->\n  ?reason:string -> unit -> Http.Response.response", "params": [{"name": "body", "type": "Http.Message.contents list option"}, {"name": "headers", "type": "(string * string) list option"}, {"name": "version", "type": "Http.Types.version option"}, {"name": "status", "type": "Http.Types.status_code option"}, {"name": "reason", "type": "string option"}, {"name": "", "type": "unit"}]}}, {"value": {"name": "Http.Response.version_string", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|14788"}, "info": "", "type": "Http.Response.response -> string", "params": [{"name": "", "type": "Http.Response.response"}]}}, {"value": {"name": "Http.Response.code", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|14828"}, "info": "", "type": "Http.Response.response -> int", "params": [{"name": "", "type": "Http.Response.response"}]}}, {"value": {"name": "Http.Response.set_code", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|14855"}, "info": "", "type": "Http.Response.response -> int -> unit", "params": [{"name": "", "type": "Http.Response.response"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Http.Response.status", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|14894"}, "info": "", "type": "Http.Response.response -> Http.Types.status", "params": [{"name": "", "type": "Http.Response.response"}]}}, {"value": {"name": "Http.Response.set_status", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|14932"}, "info": "", "type": "Http.Response.response -> Http.Types.status -> unit", "params": [{"name": "", "type": "Http.Response.response"}, {"name": "", "type": "Http.Types.status"}]}}, {"value": {"name": "Http.Response.reason", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|14982"}, "info": "", "type": "Http.Response.response -> string", "params": [{"name": "", "type": "Http.Response.response"}]}}, {"value": {"name": "Http.Response.set_reason", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|15014"}, "info": "", "type": "Http.Response.response -> string -> unit", "params": [{"name": "", "type": "Http.Response.response"}, {"name": "", "type": "string"}]}}, {"value": {"name": "Http.Response.status_line", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|15058"}, "info": "", "type": "Http.Response.response -> string", "params": [{"name": "", "type": "Http.Response.response"}]}}, {"value": {"name": "Http.Response.is_informational", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|15095"}, "info": "", "type": "Http.Response.response -> bool", "params": [{"name": "", "type": "Http.Response.response"}]}}, {"value": {"name": "Http.Response.is_success", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|15135"}, "info": "", "type": "Http.Response.response -> bool", "params": [{"name": "", "type": "Http.Response.response"}]}}, {"value": {"name": "Http.Response.is_redirection", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|15169"}, "info": "", "type": "Http.Response.response -> bool", "params": [{"name": "", "type": "Http.Response.response"}]}}, {"value": {"name": "Http.Response.is_client_error", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|15207"}, "info": "", "type": "Http.Response.response -> bool", "params": [{"name": "", "type": "Http.Response.response"}]}}, {"value": {"name": "Http.Response.is_server_error", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|15246"}, "info": "", "type": "Http.Response.response -> bool", "params": [{"name": "", "type": "Http.Response.response"}]}}, {"value": {"name": "Http.Response.is_error", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|15285"}, "info": "", "type": "Http.Response.response -> bool", "params": [{"name": "", "type": "Http.Response.response"}]}}, {"value": {"name": "Http.Response.add_basic_headers", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|15317"}, "info": "", "type": "Http.Response.response -> unit", "params": [{"name": "", "type": "Http.Response.response"}]}}, {"value": {"name": "Http.Response.content_type", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|15358"}, "info": "", "type": "Http.Response.response -> string option", "params": [{"name": "", "type": "Http.Response.response"}]}}, {"value": {"name": "Http.Response.set_content_type", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|15403"}, "info": "", "type": "Http.Response.response -> value:string -> unit", "params": [{"name": "", "type": "Http.Response.response"}, {"name": "value", "type": "string"}]}}, {"value": {"name": "Http.Response.content_encoding", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|15459"}, "info": "", "type": "Http.Response.response -> string option", "params": [{"name": "", "type": "Http.Response.response"}]}}, {"value": {"name": "Http.Response.set_content_encoding", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|15508"}, "info": "", "type": "Http.Response.response -> value:string -> unit", "params": [{"name": "", "type": "Http.Response.response"}, {"name": "value", "type": "string"}]}}, {"value": {"name": "Http.Response.date", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|15568"}, "info": "", "type": "Http.Response.response -> string option", "params": [{"name": "", "type": "Http.Response.response"}]}}, {"value": {"name": "Http.Response.set_date", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|15605"}, "info": "", "type": "Http.Response.response -> value:string -> unit", "params": [{"name": "", "type": "Http.Response.response"}, {"name": "value", "type": "string"}]}}, {"value": {"name": "Http.Response.expires", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|15653"}, "info": "", "type": "Http.Response.response -> string option", "params": [{"name": "", "type": "Http.Response.response"}]}}, {"value": {"name": "Http.Response.set_expires", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|15693"}, "info": "", "type": "Http.Response.response -> value:string -> unit", "params": [{"name": "", "type": "Http.Response.response"}, {"name": "value", "type": "string"}]}}, {"value": {"name": "Http.Response.server", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|15744"}, "info": "", "type": "Http.Response.response -> string option", "params": [{"name": "", "type": "Http.Response.response"}]}}, {"value": {"name": "Http.Response.set_server", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|15783"}, "info": "", "type": "Http.Response.response -> value:string -> unit", "params": [{"name": "", "type": "Http.Response.response"}, {"name": "value", "type": "string"}]}}, {"value": {"name": "Http.Response.serialize_to_channel", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|15833"}, "info": "", "type": "Http.Response.response -> Net.Channel.t -> unit Lwt.t", "params": [{"name": "", "type": "Http.Response.response"}, {"name": "", "type": "Net.Channel.t"}]}}], "dependencies": {"uses": []}}}, {"module": {"name": "Http.Cookie", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|15904"}, "info": "", "type": "sig  end", "module_structure": [{"type": {"name": "Http.Cookie.time", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|15929"}, "info": "", "params": [], "kind": {"type": "abstract"}, "manifest": "[ `Day of int | `Hour of int | `Minute of int | `Second of int ] list"}}, {"type": {"name": "Http.Cookie.expiration", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|16015"}, "info": "", "params": [], "kind": {"type": "abstract"}, "manifest": "[ `Age of Http.Cookie.time | `Discard | `Session | `Until of float ]"}}, {"type": {"name": "Http.Cookie.cookie", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|16090"}, "info": "", "params": [], "kind": {"type": "abstract"}}}, {"value": {"name": "Http.Cookie.make", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|16098"}, "info": "", "type": "?expiry:Http.Cookie.expiration ->\n  ?path:string ->\n  ?domain:string ->\n  ?secure:bool -> string -> string -> string * Http.Cookie.cookie", "params": [{"name": "expiry", "type": "Http.Cookie.expiration option"}, {"name": "path", "type": "string option"}, {"name": "domain", "type": "string option"}, {"name": "secure", "type": "bool option"}, {"name": "", "type": "string"}, {"name": "", "type": "string"}]}}, {"value": {"name": "Http.Cookie.serialize", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|16223"}, "info": "", "type": "?version:[ `HTTP_1_0 | `HTTP_1_1 ] ->\n  string * Http.Cookie.cookie -> string * string", "params": [{"name": "version", "type": "[ `HTTP_1_0 | `HTTP_1_1 ] option"}, {"tuple": {"type": "string * Http.Cookie.cookie", "contents": [{"name": "", "type": "string"}, {"name": "", "type": "Http.Cookie.cookie"}]}}]}}, {"value": {"name": "Http.Cookie.extract", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/http.mli|16316"}, "info": "", "type": "Http.Request.request -> (string * string) list", "params": [{"name": "", "type": "Http.Request.request"}]}}], "dependencies": {"uses": []}}}], "dependencies": {"uses": ["Net", "Lwt_stream", "Lwt", "Hashtbl", "Bitstring", "*predef*"], "used_by": []}}}, "Utf8": {"module": {"name": "Utf8", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/utf8.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/utf8.mli|0"}, "info": "", "type": "sig  end", "module_structure": [{"exception": {"name": "Utf8.MalFormed", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/utf8.mli|0"}, "info": ""}}, {"value": {"name": "Utf8.width", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/utf8.mli|21"}, "info": "", "type": "int array", "params": []}}, {"value": {"name": "Utf8.next", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/utf8.mli|42"}, "info": "", "type": "string -> int -> int", "params": [{"name": "", "type": "string"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Utf8.compute_len", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/utf8.mli|73"}, "info": "", "type": "string -> int -> int -> int", "params": [{"name": "", "type": "string"}, {"name": "", "type": "int"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Utf8.blit_to_int", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/utf8.mli|118"}, "info": "", "type": "string -> int -> int array -> int -> int -> unit", "params": [{"name": "", "type": "string"}, {"name": "", "type": "int"}, {"name": "", "type": "int array"}, {"name": "", "type": "int"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Utf8.to_int_array", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/utf8.mli|184"}, "info": "", "type": "string -> int -> int -> int array", "params": [{"name": "", "type": "string"}, {"name": "", "type": "int"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Utf8.store", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/utf8.mli|237"}, "info": "", "type": "Buffer.t -> int -> unit", "params": [{"name": "", "type": "Buffer.t"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Utf8.from_int_array", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/utf8.mli|272"}, "info": "", "type": "int array -> int -> int -> string", "params": [{"name": "", "type": "int array"}, {"name": "", "type": "int"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Utf8.from_stream", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/utf8.mli|327"}, "info": "", "type": "char Stream.t -> int", "params": [{"name": "", "type": "char Stream.t"}]}}, {"value": {"name": "Utf8.stream_from_char_stream", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/utf8.mli|365"}, "info": "", "type": "char Stream.t -> int Stream.t", "params": [{"name": "", "type": "char Stream.t"}]}}], "dependencies": {"uses": ["Stream", "Buffer"], "used_by": []}}}, "Utf16": {"module": {"name": "Utf16", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/utf16.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/utf16.mli|0"}, "info": {"description": "UTF-16 support for Ulex. Implementation as described in \"http:\/\/www.ietf.org\/rfc\/rfc2781.txt\"."}, "type": "sig  end", "module_structure": [{"exception": {"name": "Utf16.MalFormed", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/utf16.mli|108"}, "info": ""}}, {"comment": "UTF-16 can be encoded in little endian format (0xabcd -&gt; (0xcd|0xab)) or big endian format (0xabcd -&gt; (0xab|0xcd)."}, {"type": {"name": "Utf16.byte_order", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/utf16.mli|261"}, "info": "", "params": [], "kind": {"type": "variant", "private": "false", "constructors": [{"name": "Little_endian", "type": []}, {"name": "Big_endian", "type": []}]}}}, {"comment": "<h6>Interface <\/h6>"}, {"value": {"name": "Utf16.to_int_array", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/utf16.mli|703"}, "info": {"description": "<span class=\"code\" >to_int_array opt_bo str spos bytes<\/span> decodes the string <span class=\"code\" >str<\/span> of length <span class=\"code\" >bytes<\/span> starting in position <span class=\"code\" >spos<\/span>. If <span class=\"code\" >opt_bo<\/span> matches with <span class=\"code\" >None<\/span> the functions tries to detect a BOM, if it can't it assumes big endian byte order. If <span class=\"code\" >opt_bo<\/span> matches with <span class=\"code\" >Some bo<\/span> byte order <span class=\"code\" >bo<\/span> is assumed and potential byte order marks are interpreted as code points 0xfeff."}, "type": "Utf16.byte_order option -> string -> int -> int -> int array", "params": [{"name": "", "type": "Utf16.byte_order option"}, {"name": "", "type": "string"}, {"name": "", "type": "int"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Utf16.from_int_array", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/utf16.mli|986"}, "info": {"description": "<span class=\"code\" >from_int_array bo a apos len bom<\/span> encodes an int array <span class=\"code\" >a<\/span> containing <span class=\"code\" >len<\/span> code points from position <span class=\"code\" >apos<\/span> into a string with byte order <span class=\"code\" >bo<\/span>. The results starts with a BOM if <span class=\"code\" >bom = true<\/span>."}, "type": "Utf16.byte_order -> int array -> int -> int -> bool -> string", "params": [{"name": "", "type": "Utf16.byte_order"}, {"name": "", "type": "int array"}, {"name": "", "type": "int"}, {"name": "", "type": "int"}, {"name": "", "type": "bool"}]}}, {"value": {"name": "Utf16.stream_from_char_stream", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/utf16.mli|1216"}, "info": {"description": "<span class=\"code\" >stream_from_char_stream opt_stro<\/span> creates a new int stream containing the code points encoded in <span class=\"code\" >str<\/span>. Treats <span class=\"code\" >opt_bo<\/span> as <span class=\"code\" >to_int_array<\/span>."}, "type": "Utf16.byte_order option -> char Stream.t -> int Stream.t", "params": [{"name": "", "type": "Utf16.byte_order option"}, {"name": "", "type": "char Stream.t"}]}}, {"comment": "<h6>Low level<\/h6>"}, {"value": {"name": "Utf16.get_byte_order", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/utf16.mli|1424"}, "info": {"description": "<span class=\"code\" >get_byte_order c1 c2<\/span> determines the byte order by a pair of bytes\/characters <span class=\"code\" >c1<\/span> and <span class=\"code\" >c2<\/span>."}, "type": "char -> char -> Utf16.byte_order", "params": [{"name": "", "type": "char"}, {"name": "", "type": "char"}]}}, {"value": {"name": "Utf16.from_stream", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/utf16.mli|1570"}, "info": {"description": "<span class=\"code\" >from_stream bo s<\/span> reads the next code point from a stream encoded in byte order <span class=\"code\" >bo<\/span>."}, "type": "Utf16.byte_order -> char Stream.t -> int", "params": [{"name": "", "type": "Utf16.byte_order"}, {"name": "", "type": "char Stream.t"}]}}, {"value": {"name": "Utf16.number_of_char_pair", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/utf16.mli|1739"}, "info": {"description": "<span class=\"code\" >number_of_char_pair bo c1 c2<\/span> returns the code point encoded in <span class=\"code\" >c1<\/span> and <span class=\"code\" >c2<\/span> following byte order <span class=\"code\" >bo<\/span>."}, "type": "Utf16.byte_order -> char -> char -> int", "params": [{"name": "", "type": "Utf16.byte_order"}, {"name": "", "type": "char"}, {"name": "", "type": "char"}]}}, {"value": {"name": "Utf16.char_pair_of_number", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/utf16.mli|1904"}, "info": {"description": "<span class=\"code\" >char_pair_of_number bo cp<\/span> encodes code point <span class=\"code\" >cp<\/span> into two characters with byte order <span class=\"code\" >bo<\/span>."}, "type": "Utf16.byte_order -> int -> char * char", "params": [{"name": "", "type": "Utf16.byte_order"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Utf16.next_code", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/utf16.mli|2093"}, "info": {"description": "<span class=\"code\" >next_code bo s pos bytes bo<\/span> reads the code point starting at position <span class=\"code\" >pos<\/span> in a string <span class=\"code\" >s<\/span> of total length <span class=\"code\" >bytes<\/span>."}, "type": "Utf16.byte_order -> string -> int -> int -> int * int", "params": [{"name": "", "type": "Utf16.byte_order"}, {"name": "", "type": "string"}, {"name": "", "type": "int"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Utf16.compute_len", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/utf16.mli|2298"}, "info": {"description": "<span class=\"code\" >compute_len opt_bo str pos len<\/span> computes the number of encoded code points in string <span class=\"code\" >str<\/span> from position <span class=\"code\" >pos<\/span> to <span class=\"code\" >pos+len-1<\/span>."}, "type": "Utf16.byte_order option -> string -> int -> int -> int", "params": [{"name": "", "type": "Utf16.byte_order option"}, {"name": "", "type": "string"}, {"name": "", "type": "int"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Utf16.blit_to_int", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/utf16.mli|2514"}, "info": {"description": "<span class=\"code\" >blit_to_int bo str spos a apos n<\/span> decode <span class=\"code\" >len<\/span> bytes from string <span class=\"code\" >str<\/span> starting at position <span class=\"code\" >spos<\/span> into array <span class=\"code\" >a<\/span>, at position <span class=\"code\" >apos<\/span>."}, "type": "Utf16.byte_order option -> string -> int -> int array -> int -> int -> unit", "params": [{"name": "", "type": "Utf16.byte_order option"}, {"name": "", "type": "string"}, {"name": "", "type": "int"}, {"name": "", "type": "int array"}, {"name": "", "type": "int"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Utf16.store", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/utf16.mli|2703"}, "info": {"description": "<span class=\"code\" >store bo buf cp<\/span> adds a codepoint <span class=\"code\" >cp<\/span> to a buffer <span class=\"code\" >buf<\/span> following the byte order <span class=\"code\" >bo<\/span>."}, "type": "Utf16.byte_order -> Buffer.t -> int -> unit", "params": [{"name": "", "type": "Utf16.byte_order"}, {"name": "", "type": "Buffer.t"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Utf16.from_utf16_stream", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/utf16.mli|2756"}, "info": {"description": "<span class=\"code\" >from_utf16_stream s opt_bo<\/span> creates a lexbuf from an UTF-16 encoded stream. If <span class=\"code\" >opt_bo<\/span> matches with <span class=\"code\" >None<\/span> the function expects a BOM (Byte Order Mark), and takes the byte order as <span class=\"code\" >Utf16.Big_endian<\/span> if it cannot find one. When <span class=\"code\" >opt_bo<\/span> matches  with <span class=\"code\" >Some bo<\/span>, <span class=\"code\" >bo<\/span> is taken as byte order. In this case a leading BOM is kept in the stream - the lexer has to ignore it and a `wrong' BOM (<span class=\"code\" >0xfffe<\/span>) will raise Utf16.InvalidCodepoint."}, "type": "char Stream.t -> Utf16.byte_order option -> Ulexing.lexbuf", "params": [{"name": "", "type": "char Stream.t"}, {"name": "", "type": "Utf16.byte_order option"}]}}, {"value": {"name": "Utf16.from_utf16_channel", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/utf16.mli|3317"}, "info": {"description": "Works as <span class=\"code\" >from_utf16_stream<\/span> with an <span class=\"code\" >in_channel<\/span>."}, "type": "Pervasives.in_channel -> Utf16.byte_order option -> Ulexing.lexbuf", "params": [{"name": "", "type": "Pervasives.in_channel"}, {"name": "", "type": "Utf16.byte_order option"}]}}, {"value": {"name": "Utf16.from_utf16_string", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/utf16.mli|3517"}, "info": {"description": "Works as <span class=\"code\" >from_utf16_stream<\/span> with a <span class=\"code\" >string<\/span>."}, "type": "string -> Utf16.byte_order option -> Ulexing.lexbuf", "params": [{"name": "", "type": "string"}, {"name": "", "type": "Utf16.byte_order option"}]}}, {"value": {"name": "Utf16.utf16_lexeme", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/utf16.mli|3705"}, "info": {"description": "<span class=\"code\" >utf16_lexeme lb bo bom<\/span> as <span class=\"code\" >Ulexing.lexeme<\/span> with a result encoded in UTF-16 in byte_order <span class=\"code\" >bo<\/span> and starting with a BOM if <span class=\"code\" >bom = true<\/span>."}, "type": "Ulexing.lexbuf -> Utf16.byte_order -> bool -> string", "params": [{"name": "", "type": "Ulexing.lexbuf"}, {"name": "", "type": "Utf16.byte_order"}, {"name": "", "type": "bool"}]}}, {"value": {"name": "Utf16.utf16_sub_lexeme", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/utf16.mli|3975"}, "info": {"description": "<span class=\"code\" >utf16_sub_lexeme lb pos len bo bom<\/span> as <span class=\"code\" >Ulexing.sub_lexeme<\/span> with a  result encoded in UTF-16 with byte order <span class=\"code\" >bo<\/span> and starting with a BOM if <span class=\"code\" >bom=true<\/span>"}, "type": "Ulexing.lexbuf -> int -> int -> Utf16.byte_order -> bool -> string", "params": [{"name": "", "type": "Ulexing.lexbuf"}, {"name": "", "type": "int"}, {"name": "", "type": "int"}, {"name": "", "type": "Utf16.byte_order"}, {"name": "", "type": "bool"}]}}], "dependencies": {"uses": ["Ulexing", "Stream", "Buffer"], "used_by": []}}}, "Ulexing": {"module": {"name": "Ulexing", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/ulexing.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/ulexing.mli|0"}, "info": {"description": "Runtime support for lexers generated by <span class=\"code\" >ulex<\/span>. This module is roughly equivalent to the module Lexing from  the OCaml standard library, except that its lexbuffers handles Unicode code points (OCaml type: <span class=\"code\" >int<\/span> in the range <span class=\"code\" >0..0x10ffff<\/span>) instead of bytes (OCaml type: <span class=\"code\" >char<\/span>).<br><\/br> It is possible to have ulex-generated lexers work on a custom implementation for lex buffers. To do this, define a module <span class=\"code\" >L<\/span> which implements the <span class=\"code\" >start<\/span>, <span class=\"code\" >next<\/span>, <span class=\"code\" >mark<\/span> and <span class=\"code\" >backtrack<\/span> functions (See the Internal Interface section below for a specification), and the <span class=\"code\" >Error<\/span> exception.   They need not work on a type named <span class=\"code\" >lexbuf<\/span>: you can use the type name you want. Then, just do in your ulex-processed source, before the first lexer specification:<br><\/br> <span class=\"code\" >module Ulexing = L<\/span><br><\/br> Of course, you'll probably want to define functions like <span class=\"code\" >lexeme<\/span> to be used in the lexers semantic actions."}, "type": "sig  end", "module_structure": [{"type": {"name": "Ulexing.lexbuf", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/ulexing.mli|908"}, "info": {"description": "The type of lexer buffers. A lexer buffer is the argument passed to the scanning functions defined by the generated lexers. The lexer buffer holds the internal information for the scanners, including the code points of the token currently scanned, its position from the beginning of the input stream, and the current position of the lexer."}, "params": [], "kind": {"type": "abstract"}}}, {"exception": {"name": "Ulexing.Error", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/ulexing.mli|1285"}, "info": {"description": "Raised by a lexer when it cannot parse a token from the lexbuf.  The functions <span class=\"code\" >Ulexing.lexeme_start<\/span> (resp. <span class=\"code\" >Ulexing.lexeme_end<\/span>) can be  used to find to positions of the first code point of the current matched substring (resp. the first code point that yield the error)."}}}, {"exception": {"name": "Ulexing.InvalidCodepoint", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/ulexing.mli|1596"}, "info": {"description": "Raised by some functions to signal that some code point is not compatible with a specified encoding."}, "exception_args": ["int"]}}, {"comment": "<h6>Clients interface<\/h6>"}, {"value": {"name": "Ulexing.create", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/ulexing.mli|1775"}, "info": {"description": "Create a generic lexer buffer.  When the lexer needs more characters, it will call the given function, giving it an array of integers <span class=\"code\" >a<\/span>, a position <span class=\"code\" >pos<\/span> and a code point count <span class=\"code\" >n<\/span>.  The function should put <span class=\"code\" >n<\/span> code points or less in <span class=\"code\" >a<\/span>, starting at position <span class=\"code\" >pos<\/span>, and return the number of characters provided. A return value of 0 means end of input."}, "type": "(int array -> int -> int -> int) -> Ulexing.lexbuf", "params": [{"name": "", "type": "int array -> int -> int -> int"}]}}, {"value": {"name": "Ulexing.from_stream", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/ulexing.mli|2217"}, "info": {"description": "Create a lexbuf from a stream of Unicode code points."}, "type": "int Stream.t -> Ulexing.lexbuf", "params": [{"name": "", "type": "int Stream.t"}]}}, {"value": {"name": "Ulexing.from_int_array", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/ulexing.mli|2321"}, "info": {"description": "Create a lexbuf from an array of Unicode code points."}, "type": "int array -> Ulexing.lexbuf", "params": [{"name": "", "type": "int array"}]}}, {"value": {"name": "Ulexing.from_latin1_stream", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/ulexing.mli|2425"}, "info": {"description": "Create a lexbuf from a Latin1 encoded stream (ie a stream of Unicode code points in the range <span class=\"code\" >0..255<\/span>)"}, "type": "char Stream.t -> Ulexing.lexbuf", "params": [{"name": "", "type": "char Stream.t"}]}}, {"value": {"name": "Ulexing.from_latin1_channel", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/ulexing.mli|2591"}, "info": {"description": "Create a lexbuf from a Latin1 encoded input channel. The client is responsible for closing the channel."}, "type": "Pervasives.in_channel -> Ulexing.lexbuf", "params": [{"name": "", "type": "Pervasives.in_channel"}]}}, {"value": {"name": "Ulexing.from_latin1_string", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/ulexing.mli|2755"}, "info": {"description": "Create a lexbuf from a Latin1 encoded string."}, "type": "string -> Ulexing.lexbuf", "params": [{"name": "", "type": "string"}]}}, {"value": {"name": "Ulexing.from_utf8_stream", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/ulexing.mli|2852"}, "info": {"description": "Create a lexbuf from a UTF-8 encoded stream."}, "type": "char Stream.t -> Ulexing.lexbuf", "params": [{"name": "", "type": "char Stream.t"}]}}, {"value": {"name": "Ulexing.from_utf8_channel", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/ulexing.mli|2953"}, "info": {"description": "Create a lexbuf from a UTF-8 encoded input channel."}, "type": "Pervasives.in_channel -> Ulexing.lexbuf", "params": [{"name": "", "type": "Pervasives.in_channel"}]}}, {"value": {"name": "Ulexing.from_utf8_string", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/ulexing.mli|3059"}, "info": {"description": "Create a lexbuf from a UTF-8 encoded string."}, "type": "string -> Ulexing.lexbuf", "params": [{"name": "", "type": "string"}]}}, {"type": {"name": "Ulexing.enc", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/ulexing.mli|3158"}, "info": "", "params": [], "kind": {"type": "variant", "private": "false", "constructors": [{"name": "Ascii", "type": []}, {"name": "Latin1", "type": []}, {"name": "Utf8", "type": []}]}}}, {"value": {"name": "Ulexing.from_var_enc_stream", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/ulexing.mli|3186"}, "info": {"description": "Create a lexbuf from a stream whose encoding is subject to change during lexing. The reference can be changed at any point. Note that bytes that have been consumed by the lexer buffer are not re-interpreted with the new encoding.<br><\/br> In <span class=\"code\" >Ascii<\/span> mode, non-ASCII bytes (ie <span class=\"code\" >&gt;127<\/span>) in the stream raise an <span class=\"code\" >InvalidCodepoint<\/span> exception."}, "type": "Ulexing.enc Pervasives.ref -> char Stream.t -> Ulexing.lexbuf", "params": [{"name": "", "type": "Ulexing.enc Pervasives.ref"}, {"name": "", "type": "char Stream.t"}]}}, {"value": {"name": "Ulexing.from_var_enc_string", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/ulexing.mli|3605"}, "info": {"description": "Same as <span class=\"code\" >Ulexing.from_var_enc_stream<\/span> with a string as input."}, "type": "Ulexing.enc Pervasives.ref -> string -> Ulexing.lexbuf", "params": [{"name": "", "type": "Ulexing.enc Pervasives.ref"}, {"name": "", "type": "string"}]}}, {"value": {"name": "Ulexing.from_var_enc_channel", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/ulexing.mli|3730"}, "info": {"description": "Same as <span class=\"code\" >Ulexing.from_var_enc_stream<\/span> with a channel as input."}, "type": "Ulexing.enc Pervasives.ref -> Pervasives.in_channel -> Ulexing.lexbuf", "params": [{"name": "", "type": "Ulexing.enc Pervasives.ref"}, {"name": "", "type": "Pervasives.in_channel"}]}}, {"comment": "<h6>Interface for lexers semantic actions<\/h6>"}, {"comment": "The following functions can be called from the semantic actions of lexer definitions.  They give access to the character string matched by the regular expression associated with the semantic action. These functions must be applied to the argument <span class=\"code\" >lexbuf<\/span>, which, in the code generated by <span class=\"code\" >ulex<\/span>, is bound to the lexer buffer passed to the parsing function.<br><\/br> These functions can also be called when capturing a <span class=\"code\" >Ulexing.Error<\/span>  exception to retrieve the problematic string."}, {"value": {"name": "Ulexing.lexeme_start", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/ulexing.mli|4407"}, "info": {"description": "<span class=\"code\" >Ulexing.lexeme_start lexbuf<\/span> returns the offset in the input stream of the first code point of the matched string. The first code point of the stream has offset 0."}, "type": "Ulexing.lexbuf -> int", "params": [{"name": "", "type": "Ulexing.lexbuf"}]}}, {"value": {"name": "Ulexing.lexeme_end", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/ulexing.mli|4622"}, "info": {"description": "<span class=\"code\" >Ulexing.lexeme_end lexbuf<\/span> returns the offset in the input stream of the character following the last code point of the matched string. The first character of the stream has offset 0."}, "type": "Ulexing.lexbuf -> int", "params": [{"name": "", "type": "Ulexing.lexbuf"}]}}, {"value": {"name": "Ulexing.loc", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/ulexing.mli|4851"}, "info": {"description": "<span class=\"code\" >Ulexing.loc lexbuf<\/span> returns the pair  <span class=\"code\" >(Ulexing.lexeme_start lexbuf,Ulexing.lexeme_end lexbuf)<\/span>."}, "type": "Ulexing.lexbuf -> int * int", "params": [{"name": "", "type": "Ulexing.lexbuf"}]}}, {"value": {"name": "Ulexing.lexeme_length", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/ulexing.mli|4988"}, "info": {"description": "<span class=\"code\" >Ulexing.loc lexbuf<\/span> returns the difference  <span class=\"code\" >(Ulexing.lexeme_end lexbuf) - (Ulexing.lexeme_start lexbuf)<\/span>, that is, the length (in code points) of the matched string."}, "type": "Ulexing.lexbuf -> int", "params": [{"name": "", "type": "Ulexing.lexbuf"}]}}, {"value": {"name": "Ulexing.lexeme", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/ulexing.mli|5201"}, "info": {"description": "<span class=\"code\" >Ulexing.lexeme lexbuf<\/span> returns the string matched by the regular expression as an array of Unicode code point."}, "type": "Ulexing.lexbuf -> int array", "params": [{"name": "", "type": "Ulexing.lexbuf"}]}}, {"value": {"name": "Ulexing.get_buf", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/ulexing.mli|5355"}, "info": {"description": "Direct access to the internal buffer."}, "type": "Ulexing.lexbuf -> int array", "params": [{"name": "", "type": "Ulexing.lexbuf"}]}}, {"value": {"name": "Ulexing.get_start", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/ulexing.mli|5435"}, "info": {"description": "Direct access to the starting position of the lexeme in the internal buffer."}, "type": "Ulexing.lexbuf -> int", "params": [{"name": "", "type": "Ulexing.lexbuf"}]}}, {"value": {"name": "Ulexing.get_pos", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/ulexing.mli|5556"}, "info": {"description": "Direct access to the current position (end of lexeme) in the internal buffer."}, "type": "Ulexing.lexbuf -> int", "params": [{"name": "", "type": "Ulexing.lexbuf"}]}}, {"value": {"name": "Ulexing.lexeme_char", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/ulexing.mli|5677"}, "info": {"description": "<span class=\"code\" >Ulexing.lexeme_char lexbuf pos<\/span> returns code point number <span class=\"code\" >pos<\/span> in the matched string."}, "type": "Ulexing.lexbuf -> int -> int", "params": [{"name": "", "type": "Ulexing.lexbuf"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Ulexing.sub_lexeme", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/ulexing.mli|5819"}, "info": {"description": "<span class=\"code\" >Ulexing.lexeme lexbuf pos len<\/span> returns a substring of the string matched by the regular expression as an array of Unicode code point."}, "type": "Ulexing.lexbuf -> int -> int -> int array", "params": [{"name": "", "type": "Ulexing.lexbuf"}, {"name": "", "type": "int"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Ulexing.latin1_lexeme", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/ulexing.mli|6015"}, "info": {"description": "As <span class=\"code\" >Ulexing.lexeme<\/span> with a result encoded in Latin1. This function throws an exception <span class=\"code\" >InvalidCodepoint<\/span> if it is not possible to encode the result in Latin1."}, "type": "Ulexing.lexbuf -> string", "params": [{"name": "", "type": "Ulexing.lexbuf"}]}}, {"value": {"name": "Ulexing.latin1_sub_lexeme", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/ulexing.mli|6223"}, "info": {"description": "As <span class=\"code\" >Ulexing.sub_lexeme<\/span> with a result encoded in Latin1. This function throws an exception <span class=\"code\" >InvalidCodepoint<\/span> if it is not possible to encode the result in Latin1."}, "type": "Ulexing.lexbuf -> int -> int -> string", "params": [{"name": "", "type": "Ulexing.lexbuf"}, {"name": "", "type": "int"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Ulexing.latin1_lexeme_char", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/ulexing.mli|6453"}, "info": {"description": "As <span class=\"code\" >Ulexing.lexeme_char<\/span> with a result encoded in Latin1. This function throws an exception <span class=\"code\" >InvalidCodepoint<\/span> if it is not possible to encode the result in Latin1."}, "type": "Ulexing.lexbuf -> int -> char", "params": [{"name": "", "type": "Ulexing.lexbuf"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Ulexing.utf8_lexeme", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/ulexing.mli|6678"}, "info": {"description": "As <span class=\"code\" >Ulexing.lexeme<\/span> with a result encoded in UTF-8."}, "type": "Ulexing.lexbuf -> string", "params": [{"name": "", "type": "Ulexing.lexbuf"}]}}, {"value": {"name": "Ulexing.utf8_sub_lexeme", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/ulexing.mli|6772"}, "info": {"description": "As <span class=\"code\" >Ulexing.sub_lexeme<\/span> with a result encoded in UTF-8."}, "type": "Ulexing.lexbuf -> int -> int -> string", "params": [{"name": "", "type": "Ulexing.lexbuf"}, {"name": "", "type": "int"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Ulexing.rollback", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/ulexing.mli|6889"}, "info": {"description": "<span class=\"code\" >Ulexing.rollback lexbuf<\/span> puts <span class=\"code\" >lexbuf<\/span> back in its configuration before the last lexeme was matched. It is then possible to use another lexer to parse the same characters again. The other functions above in this section should not be used in the semantic action after a call to <span class=\"code\" >Ulexing.rollback<\/span>."}, "type": "Ulexing.lexbuf -> unit", "params": [{"name": "", "type": "Ulexing.lexbuf"}]}}, {"comment": "<h6>Internal interface<\/h6>"}, {"comment": "These functions are used internally by the lexers. They could be used to write lexers by hand, or with a lexer generator different from <span class=\"code\" >ulex<\/span>. The lexer buffers have a unique internal slot that can store an integer. They also store a \"backtrack\" position."}, {"value": {"name": "Ulexing.start", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/ulexing.mli|7535"}, "info": {"description": "<span class=\"code\" >Ulexing.start lexbuf<\/span> informs the lexer buffer that any code points until the current position can be discarded. The current position become the \"start\" position as returned by <span class=\"code\" >Ulexing.lexeme_start<\/span>. Moreover, the internal slot is set to <span class=\"code\" >-1<\/span> and the backtrack position is set to the current position."}, "type": "Ulexing.lexbuf -> unit", "params": [{"name": "", "type": "Ulexing.lexbuf"}]}}, {"value": {"name": "Ulexing.next", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/ulexing.mli|7881"}, "info": {"description": "<span class=\"code\" >Ulexing.next lexbuf next<\/span> extracts the next code point from the lexer buffer and increments to current position. If the input stream is exhausted, the function returns <span class=\"code\" >-1<\/span>."}, "type": "Ulexing.lexbuf -> int", "params": [{"name": "", "type": "Ulexing.lexbuf"}]}}, {"value": {"name": "Ulexing.mark", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/ulexing.mli|8092"}, "info": {"description": "<span class=\"code\" >Ulexing.mark lexbuf i<\/span> stores the integer <span class=\"code\" >i<\/span> in the internal slot. The backtrack position is set to the current position."}, "type": "Ulexing.lexbuf -> int -> unit", "params": [{"name": "", "type": "Ulexing.lexbuf"}, {"name": "", "type": "int"}]}}, {"value": {"name": "Ulexing.backtrack", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/ulexing.mli|8258"}, "info": {"description": "<span class=\"code\" >Ulexing.backtrack lexbuf<\/span> returns the value stored in the internal slot of the buffer, and performs backtracking (the current position is set to the value of the backtrack position)."}, "type": "Ulexing.lexbuf -> int", "params": [{"name": "", "type": "Ulexing.lexbuf"}]}}], "dependencies": {"uses": ["Stream"], "used_by": ["Utf16"]}}}, "Dyntype": {"module": {"name": "Dyntype", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dyntype.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dyntype.mli|0"}, "info": {"description": "Dynamic types"}, "type": "sig  end", "module_structure": [{"type": {"name": "Dyntype.t", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dyntype.mli|832"}, "info": "", "params": [], "kind": {"type": "variant", "private": "false", "constructors": [{"name": "Unit", "description": "unit", "type": []}, {"name": "Bool", "description": "booleans", "type": []}, {"name": "Float", "description": "floating-point numbers", "type": []}, {"name": "Char", "description": "characters", "type": []}, {"name": "String", "description": "strings", "type": []}, {"name": "Int", "description": "integer type of a given size (as 31-,32- or 64-bits); <span class=\"code\" >Int None<\/span> is for bigints", "type": ["int option"]}, {"name": "List", "description": "collection of stuff of the same type (stored as lists)", "type": ["Dyntype.t"]}, {"name": "Array", "description": "collection of stuff of the same type (stored as arrays)", "type": ["Dyntype.t"]}, {"name": "Tuple", "description": "Cartesian product", "type": ["Dyntype.t list"]}, {"name": "Dict", "description": "record <span class=\"code\" >'R<\/span> or object <span class=\"code\" >'O<\/span> type; <span class=\"code\" >`RW<\/span> stands for mutable fields", "type": ["[ `O | `R ]", "(string * [ `RO | `RW ] * Dyntype.t) list"]}, {"name": "Sum", "description": "polymorphic <span class=\"code\" >`P<\/span> or normal <span class=\"code\" >`N<\/span> variant type", "type": ["[ `N | `P ]", "(string * Dyntype.t list) list"]}, {"name": "Option", "description": "option type", "type": ["Dyntype.t"]}, {"name": "Rec", "description": "recursive type", "type": ["string", "Dyntype.t"]}, {"name": "Var", "description": "recursive fix-point", "type": ["string"]}, {"name": "Arrow", "description": "arrow type", "type": ["Dyntype.t", "Dyntype.t"]}, {"name": "Ext", "description": "type variable", "type": ["string", "Dyntype.t"]}]}}}, {"comment": "<h2>Utility functions<\/h2>"}, {"value": {"name": "Dyntype.is_mutable", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dyntype.mli|1794"}, "info": {"description": "<span class=\"code\" >is_mutable t<\/span> checks whether <span class=\"code\" >t<\/span> contains a mutable field"}, "type": "Dyntype.t -> bool", "params": [{"name": "", "type": "Dyntype.t"}]}}, {"value": {"name": "Dyntype.free_vars", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dyntype.mli|1990"}, "info": {"description": "<span class=\"code\" >free_vars t<\/span> returns all the free variables of type <span class=\"code\" >t<\/span>. If <span class=\"code\" >t<\/span> is unfolded (as it should be when calling <span class=\"code\" >type_of_t<\/span>, this call should return an empty list."}, "type": "Dyntype.t -> string list", "params": [{"name": "", "type": "Dyntype.t"}]}}, {"value": {"name": "Dyntype.foreigns", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dyntype.mli|2093"}, "info": {"description": "<span class=\"code\" >foreigns t<\/span> returns all the type variables appearing in <span class=\"code\" >t<\/span>."}, "type": "Dyntype.t -> string list", "params": [{"name": "", "type": "Dyntype.t"}]}}, {"value": {"name": "Dyntype.unroll", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dyntype.mli|2221"}, "info": {"description": "<span class=\"code\" >unroll env t<\/span> replaces every type appearing in <span class=\"code\" >t<\/span> by its type value defined in <span class=\"code\" >env<\/span>."}, "type": "(string * Dyntype.t) list -> Dyntype.t -> Dyntype.t", "params": [{"name": "", "type": "(string * Dyntype.t) list"}, {"name": "", "type": "Dyntype.t"}]}}, {"comment": "<h2>Sub-typing<\/h2>"}, {"value": {"name": "Dyntype.is_subtype_of", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dyntype.mli|2551"}, "info": {"description": "<span class=\"code\" >is_subtype_of s t<\/span> checks whether <span class=\"code\" >s<\/span> is a sub-type of <span class=\"code\" >t<\/span>. Sub-typing relation is based on naming. Basically, <span class=\"code\" >s<\/span> is a sub-type of <span class=\"code\" >t<\/span> if (i) named attributes have either compatible types (ii) or some fields\/methods defined in <span class=\"code\" >t<\/span> do not appear in <span class=\"code\" >s<\/span>."}, "type": "Dyntype.t -> Dyntype.t -> bool", "params": [{"name": "", "type": "Dyntype.t"}, {"name": "", "type": "Dyntype.t"}]}}, {"value": {"name": "Dyntype.(<:)", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dyntype.mli|2642"}, "info": {"description": "<span class=\"code\" >s &lt;: t<\/span> is a short-cut for <span class=\"code\" >is_subtype_of s t<\/span>"}, "type": "Dyntype.t -> Dyntype.t -> bool", "params": [{"name": "", "type": "Dyntype.t"}, {"name": "", "type": "Dyntype.t"}]}}, {"value": {"name": "Dyntype.string_of_last_type_error", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dyntype.mli|2764"}, "info": {"description": "Returns the more recent failing sub-type relation tested by <span class=\"code\" >(&lt;:)<\/span> or <span class=\"code\" >is_subtype_of<\/span>"}, "type": "unit -> string", "params": [{"name": "", "type": "unit"}]}}, {"comment": "<h2>Pretty-printing<\/h2>"}, {"value": {"name": "Dyntype.to_string", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dyntype.mli|2888"}, "info": {"description": "<span class=\"code\" >to_string t<\/span> pretty-prints the type <span class=\"code\" >t<\/span>"}, "type": "Dyntype.t -> string", "params": [{"name": "", "type": "Dyntype.t"}]}}, {"exception": {"name": "Dyntype.Parse_error", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dyntype.mli|2970"}, "info": {"description": "Exception that may be raised by <span class=\"code\" >!of_string<\/span>"}, "exception_args": ["string"]}}, {"value": {"name": "Dyntype.of_string", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/dyntype.mli|3145"}, "info": {"description": "<span class=\"code\" >of_string str<\/span> returns the type <span class=\"code\" >t<\/span> corresponding to the pretty-printed string <span class=\"code\" >str<\/span>. Raises <span class=\"code\" >!Parse_error<\/span> if is not a valid string"}, "type": "string -> Dyntype.t", "params": [{"name": "", "type": "string"}]}}], "dependencies": {"uses": [], "used_by": []}}}, "Cow": {"module": {"name": "Cow", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|0"}, "info": {"description": "Streaming XML IO.  <br><\/br> A well-formed sequence of <a href=\"#TYPEsignal\" >signals<\/a> represents an <a href=\"http:\/\/www.w3.org\/TR\/REC-xml\" >XML<\/a> document tree traversal in depth first order (this has nothing to do with XML well-formedness). Input pulls a well-formed sequence of signals from a data source and output pushes a well-formed sequence of signals to a data destination. Functions are provided to easily  transform sequences of signals to\/from arborescent data structures.<br><\/br> Consult the <a href=\"#io\" >features and limitations<\/a> and <a href=\"#ex\" >examples<\/a>  of use.<br><\/br> <em>Version 1.0.2 - daniel.buenzl i@erratique.ch <\/em><br><\/br> <b>References.<\/b><br><\/br> Tim Bray.  <em><a href=\"http:\/\/www.xml.com\/axml\/axml.html\" >The annotated XML Specification<\/a><\/em>,  1998. <br><\/br> Tim Bray et al.  <em><a href=\"http:\/\/www.w3.org\/TR\/xml-names11\" >Namespaces in XML 1.1 (2nd ed.)<\/a><\/em>, 2006.<br><\/br> <h1>Basic types and values<\/h1>"}, "type": "sig  end", "module_structure": [{"module": {"name": "Cow.Xml", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|0"}, "info": "", "type": "sig  end", "module_structure": [{"comment": "Streaming XML IO.  <br><\/br> A well-formed sequence of <a href=\"#TYPEsignal\" >signals<\/a> represents an <a href=\"http:\/\/www.w3.org\/TR\/REC-xml\" >XML<\/a> document tree traversal in depth first order (this has nothing to do with XML well-formedness). Input pulls a well-formed sequence of signals from a data source and output pushes a well-formed sequence of signals to a data destination. Functions are provided to easily  transform sequences of signals to\/from arborescent data structures.<br><\/br> Consult the <a href=\"#io\" >features and limitations<\/a> and <a href=\"#ex\" >examples<\/a>  of use.<br><\/br> <em>Version 1.0.2 - daniel.buenzl i@erratique.ch <\/em><br><\/br> <b>References.<\/b><br><\/br> Tim Bray.  <em><a href=\"http:\/\/www.xml.com\/axml\/axml.html\" >The annotated XML Specification<\/a><\/em>,  1998. <br><\/br> Tim Bray et al.  <em><a href=\"http:\/\/www.w3.org\/TR\/xml-names11\" >Namespaces in XML 1.1 (2nd ed.)<\/a><\/em>, 2006.<br><\/br> <h1>Basic types and values<\/h1>"}, {"type": {"name": "Cow.Xml.encoding", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|1090"}, "info": {"description": "The type for character encodings. For <span class=\"code\" >`UTF_16<\/span>, endianness is determined from the  <a href=\"http:\/\/www.unicode.org\/unicode\/faq\/utf_bom.html#BOM\" >BOM<\/a>."}, "params": [], "kind": {"type": "abstract"}, "manifest": "[ `ISO_8859_1 | `US_ASCII | `UTF_16 | `UTF_16BE | `UTF_16LE | `UTF_8 ]"}}, {"type": {"name": "Cow.Xml.dtd", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|1313"}, "info": {"description": "The type for the optional <a href=\"http:\/\/www.w3.org\/TR\/REC-xml\/#dt-doctype\" >DTD<\/a>."}, "params": [], "kind": {"type": "abstract"}, "manifest": "string option"}}, {"type": {"name": "Cow.Xml.name", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|1426"}, "info": {"description": "The type for attribute and element's <a href=\"http:\/\/www.w3.org\/TR\/xml-names11\/#dt-expname\" >expanded names<\/a>  <span class=\"code\" >(uri,local)<\/span>. An empty <span class=\"code\" >uri<\/span> represents a name without a namespace name, i.e. an unprefixed name  that is not under the scope of a default namespace."}, "params": [], "kind": {"type": "abstract"}, "manifest": "string * string"}}, {"type": {"name": "Cow.Xml.attribute", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|1732"}, "info": {"description": "The type for attributes. Name and attribute data."}, "params": [], "kind": {"type": "abstract"}, "manifest": "Cow.Xml.name * string"}}, {"type": {"name": "Cow.Xml.tag", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|1821"}, "info": {"description": "The type for an element tag. Tag name and attribute list."}, "params": [], "kind": {"type": "abstract"}, "manifest": "Cow.Xml.name * Cow.Xml.attribute list"}}, {"type": {"name": "Cow.Xml.signal", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|1920"}, "info": {"description": "The type for signals. A <em>well-formed<\/em> sequence of signals belongs to the language of the <span class=\"code\" >doc<\/span> grammar : <span class=\"codepre\" >doc ::= `Dtd tree tree ::= `El_start child `El_end child ::= `Data | tree | epsilon <\/span> Input and output deal only with well-formed sequences or exceptions are raised."}, "params": [], "kind": {"type": "abstract"}, "manifest": "[ `Data of string\n  | `Dtd of Cow.Xml.dtd\n  | `El_end\n  | `El_start of Cow.Xml.tag\n  | `Raw of string ]"}}, {"value": {"name": "Cow.Xml.ns_xml", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|2311"}, "info": {"description": "Namespace name <a href=\"http:\/\/www.w3.org\/XML\/1998\/namespace\" >value<\/a> bound to the  reserved <span class=\"code\" >\"xml\"<\/span> prefix."}, "type": "string", "params": []}}, {"value": {"name": "Cow.Xml.ns_xmlns", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|2445"}, "info": {"description": "Namespace name <a href=\"http:\/\/www.w3.org\/2000\/xmlns\/\" >value<\/a> bound to the  reserved <span class=\"code\" >\"xmlns\"<\/span> prefix."}, "type": "string", "params": []}}, {"comment": "<h1>Input<\/h1>"}, {"type": {"name": "Cow.Xml.pos", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|2598"}, "info": {"description": "The type for input positions. Line and column number, both start with 1."}, "params": [], "kind": {"type": "abstract"}, "manifest": "int * int"}}, {"type": {"name": "Cow.Xml.error", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|2739"}, "info": {"description": "The type for input errors."}, "params": [], "kind": {"type": "abstract"}, "manifest": "[ `Expected_char_seqs of string list * string\n  | `Expected_root_element\n  | `Illegal_char_ref of string\n  | `Illegal_char_seq of string\n  | `Malformed_char_stream\n  | `Max_buffer_size\n  | `Unexpected_eoi\n  | `Unknown_encoding of string\n  | `Unknown_entity_ref of string\n  | `Unknown_ns_prefix of string ]"}}, {"value": {"name": "Cow.Xml.error_message", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|3555"}, "info": {"description": "Converts the error to an english error message."}, "type": "Cow.Xml.error -> string", "params": [{"name": "", "type": "Cow.Xml.error"}]}}, {"exception": {"name": "Cow.Xml.Error", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|3647"}, "info": {"description": "Raised on input errors."}, "exception_args": ["Cow.Xml.pos", "Cow.Xml.error"]}}, {"type": {"name": "Cow.Xml.source", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|3715"}, "info": {"description": "The type for input sources. For <span class=\"code\" >`String<\/span> starts reading at the given integer position. For <span class=\"code\" >`Fun<\/span> the function must return the next <em>byte<\/em> as an <span class=\"code\" >int<\/span> and raise <span class=\"code\" >End_of_file<\/span> if there is no such byte."}, "params": [], "kind": {"type": "abstract"}, "manifest": "[ `Fun of unit -> int | `String of int * string ]"}}, {"type": {"name": "Cow.Xml.input", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|4008"}, "info": {"description": "The type for input abstractions."}, "params": [], "kind": {"type": "abstract"}}}, {"value": {"name": "Cow.Xml.make_input", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|4055"}, "info": {"description": "Returns a new input abstraction reading from the given source. <ul><li><span class=\"code\" >enc<\/span>, character encoding of the document, <a href=\"#inenc\" > details<\/a>.  Defaults to <span class=\"code\" >None<\/span>.<\/li><li><span class=\"code\" >strip<\/span>, strips whitespace in character data, <a href=\"#inwspace\" > details<\/a>. Defaults to <span class=\"code\" >false<\/span>.<\/li><li><span class=\"code\" >ns<\/span> is called to bind undeclared namespace prefixes, <a href=\"#inns\" > details<\/a>. Default returns always <span class=\"code\" >None<\/span>.<\/li><li><span class=\"code\" >entity<\/span> is called to resolve non predefined entity references, <a href=\"#inentity\" > details<\/a>. Default returns always <span class=\"code\" >None<\/span>.<\/li><\/ul>"}, "type": "?templates:bool ->\n  ?enc:Cow.Xml.encoding option ->\n  ?strip:bool ->\n  ?ns:(string -> string option) ->\n  ?entity:(string -> string option) -> Cow.Xml.source -> Cow.Xml.input", "params": [{"name": "templates", "type": "bool option"}, {"name": "enc", "type": "Cow.Xml.encoding option option"}, {"name": "strip", "type": "bool option"}, {"name": "ns", "type": "(string -> string option) option"}, {"name": "entity", "type": "(string -> string option) option"}, {"name": "", "type": "Cow.Xml.source"}]}}, {"value": {"name": "Cow.Xml.input", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|4768"}, "info": {"description": "Inputs a signal. Repeated invocation of the function with the same input abstraction will generate a <a href=\"#TYPEsignal\" >well-formed<\/a> sequence of signals or an <a href=\"{exception|Cow.Xml.Error}\" ><span class=\"code\" >Cow.Xml.Error<\/span><\/a> is raised. Furthermore there will be no two consecutive <span class=\"code\" >`Data<\/span> signals in the sequence and their string is always non empty. After a well-formed sequence was input another may  be input, see <a href=\"{value|Cow.Xml.eoi}\" ><span class=\"code\" >Cow.Xml.eoi<\/span><\/a> and <a href=\"#iseq\" >details<\/a>.<br><\/br> <b>Raises<\/b> <a href=\"{exception|Cow.Xml.Error}\" ><span class=\"code\" >Cow.Xml.Error<\/span><\/a> on input errors."}, "type": "Cow.Xml.input -> Cow.Xml.signal", "params": [{"name": "", "type": "Cow.Xml.input"}]}}, {"value": {"name": "Cow.Xml.input_tree", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|5252"}, "info": {"description": "If the next signal is a : <ul><li><span class=\"code\" >`Data<\/span> signal, inputs it and invokes <span class=\"code\" >data<\/span> with the character data.<\/li><li><span class=\"code\" >`El_start<\/span> signal, inputs the sequence of signals until its  matching <span class=\"code\" >`El_end<\/span> and invokes <span class=\"code\" >el<\/span> and <span class=\"code\" >data<\/span> as follows <ul><li><span class=\"code\" >el<\/span>, is called on each <span class=\"code\" >`El_end<\/span> signals with the corresponding  <span class=\"code\" >`El_start<\/span> tag and the result of the callback invocation for the  element's children.<\/li><li><span class=\"code\" >data<\/span>, is called on each <span class=\"code\" >`Data<\/span> signals with the character data.  This function won't be called twice consecutively or with the empty  string.<\/li><\/ul><\/li><li>Other signals, raises <span class=\"code\" >Invalid_argument<\/span>.<\/li><\/ul><br><\/br> <b>Raises<\/b> <a href=\"{exception|Cow.Xml.Error}\" ><span class=\"code\" >Cow.Xml.Error<\/span><\/a> on input errors and <span class=\"code\" >Invalid_argument<\/span> if the next signal is not <span class=\"code\" >`El_start<\/span> or <span class=\"code\" >`Data<\/span>."}, "type": "el:(Cow.Xml.tag -> 'a list -> 'a) ->\n  data:(string -> 'a) -> Cow.Xml.input -> 'a", "params": [{"name": "el", "type": "Cow.Xml.tag -> 'a list -> 'a"}, {"name": "data", "type": "string -> 'a"}, {"name": "", "type": "Cow.Xml.input"}]}}, {"value": {"name": "Cow.Xml.input_doc_tree", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|6125"}, "info": {"description": "Same as <a href=\"{value|Cow.Xml.input_tree}\" ><span class=\"code\" >Cow.Xml.input_tree<\/span><\/a> but reads a complete <a href=\"#TYPEsignal\" >well-formed<\/a>   sequence of signals. <br><\/br> <b>Raises<\/b> <a href=\"{exception|Cow.Xml.Error}\" ><span class=\"code\" >Cow.Xml.Error<\/span><\/a> on input errors and <span class=\"code\" >Invalid_argument<\/span> if the next signal is not <span class=\"code\" >`Dtd<\/span>."}, "type": "el:(Cow.Xml.tag -> 'a list -> 'a) ->\n  data:(string -> 'a) -> Cow.Xml.input -> Cow.Xml.dtd * 'a", "params": [{"name": "el", "type": "Cow.Xml.tag -> 'a list -> 'a"}, {"name": "data", "type": "string -> 'a"}, {"name": "", "type": "Cow.Xml.input"}]}}, {"value": {"name": "Cow.Xml.peek", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|6454"}, "info": {"description": "Same as <a href=\"{value|Cow.Xml.input}\" ><span class=\"code\" >Cow.Xml.input<\/span><\/a> but doesn't remove the signal from the sequence. <br><\/br> <b>Raises<\/b> <a href=\"{exception|Cow.Xml.Error}\" ><span class=\"code\" >Cow.Xml.Error<\/span><\/a> on input errors."}, "type": "Cow.Xml.input -> Cow.Xml.signal", "params": [{"name": "", "type": "Cow.Xml.input"}]}}, {"value": {"name": "Cow.Xml.eoi", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|6598"}, "info": {"description": "Returns <span class=\"code\" >true<\/span> if the end of input is reached. See <a href=\"#iseq\" >details<\/a>.<br><\/br> <b>Raises<\/b> <a href=\"{exception|Cow.Xml.Error}\" ><span class=\"code\" >Cow.Xml.Error<\/span><\/a> on input errors."}, "type": "Cow.Xml.input -> bool", "params": [{"name": "", "type": "Cow.Xml.input"}]}}, {"value": {"name": "Cow.Xml.pos", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|6743"}, "info": {"description": "Current position in the input abstraction."}, "type": "Cow.Xml.input -> Cow.Xml.pos", "params": [{"name": "", "type": "Cow.Xml.input"}]}}, {"comment": "<h1>Output<\/h1>"}, {"type": {"name": "Cow.Xml.frag", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|6841"}, "info": {"description": "The type for deconstructing data structures of type <span class=\"code\" >'a<\/span>."}, "params": [{"covariant": "true", "contravariant": "false", "type": "'a"}], "kind": {"type": "abstract"}, "manifest": "[ `Data of string | `El of Cow.Xml.tag * 'a list ]"}}, {"type": {"name": "Cow.Xml.t", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|6966"}, "info": {"description": "The type for XML fragments"}, "params": [], "kind": {"type": "abstract"}, "manifest": "('a Cow.Xml.frag as 'a) Cow.Xml.frag list"}}, {"type": {"name": "Cow.Xml.dest", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|7038"}, "info": {"description": "The type for output destinations. For <span class=\"code\" >`Buffer<\/span>, the buffer won't be cleared. For <span class=\"code\" >`Fun<\/span> the function is called with the output <em>    bytes<\/em> as <span class=\"code\" >int<\/span>s."}, "params": [], "kind": {"type": "abstract"}, "manifest": "[ `Buffer of Buffer.t | `Fun of int -> unit ]"}}, {"type": {"name": "Cow.Xml.output", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|7278"}, "info": {"description": "The type for output abstractions."}, "params": [], "kind": {"type": "abstract"}}}, {"value": {"name": "Cow.Xml.make_output", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|7327"}, "info": {"description": "Returns a new output abstraction writing to the given destination. <ul><li><span class=\"code\" >nl<\/span>, if <span class=\"code\" >true<\/span> a newline is output when the root's element <span class=\"code\" >`El_end<\/span>  signal is output. Defaults to <span class=\"code\" >false<\/span>.<\/li><li><span class=\"code\" >indent<\/span>, identation behaviour, see <a href=\"#outindent\" > details<\/a>. Defaults to <span class=\"code\" >None<\/span>.<\/li><li><span class=\"code\" >ns_prefix<\/span>, undeclared namespace prefix bindings,  see <a href=\"#outns\" >details<\/a>. Default returns always <span class=\"code\" >None<\/span>.<\/li><\/ul>"}, "type": "?nl:bool ->\n  ?indent:int option ->\n  ?ns_prefix:(string -> string option) -> Cow.Xml.dest -> Cow.Xml.output", "params": [{"name": "nl", "type": "bool option"}, {"name": "indent", "type": "int option option"}, {"name": "ns_prefix", "type": "(string -> string option) option"}, {"name": "", "type": "Cow.Xml.dest"}]}}, {"value": {"name": "Cow.Xml.output", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|7883"}, "info": {"description": "Outputs a signal. After a well-formed sequence of signals was  output a new well-formed sequence can be output.<br><\/br> <b>Raises<\/b> <span class=\"code\" >Invalid_argument<\/span> if the resulting signal sequence on the output abstraction is not <a href=\"#TYPEsignal\" >well-formed<\/a> or if a namespace name could not be bound to a prefix."}, "type": "Cow.Xml.output -> Cow.Xml.signal -> unit", "params": [{"name": "", "type": "Cow.Xml.output"}, {"name": "", "type": "Cow.Xml.signal"}]}}, {"value": {"name": "Cow.Xml.output_tree", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|8237"}, "info": {"description": "Outputs signals corresponding to a value by recursively applying the given value deconstructor.<br><\/br> <b>Raises<\/b> see <a href=\"{value|Cow.Xml.output}\" ><span class=\"code\" >Cow.Xml.output<\/span><\/a>."}, "type": "('a -> 'a Cow.Xml.frag) -> Cow.Xml.output -> 'a -> unit", "params": [{"name": "", "type": "'a -> 'a Cow.Xml.frag"}, {"name": "", "type": "Cow.Xml.output"}, {"name": "", "type": "'a"}]}}, {"value": {"name": "Cow.Xml.output_doc_tree", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|8434"}, "info": {"description": "Same as <a href=\"{value|Cow.Xml.output_tree}\" ><span class=\"code\" >Cow.Xml.output_tree<\/span><\/a> but outputs a complete <a href=\"#TYPEsignal\" >well-formed<\/a>  sequence of signals.<br><\/br> <b>Raises<\/b> see <a href=\"{value|Cow.Xml.output}\" ><span class=\"code\" >Cow.Xml.output<\/span><\/a>."}, "type": "('a -> 'a Cow.Xml.frag) -> Cow.Xml.output -> Cow.Xml.dtd * 'a -> unit", "params": [{"name": "", "type": "'a -> 'a Cow.Xml.frag"}, {"name": "", "type": "Cow.Xml.output"}, {"tuple": {"type": "Cow.Xml.dtd * 'a", "contents": [{"name": "", "type": "Cow.Xml.dtd"}, {"name": "", "type": "'a"}]}}]}}, {"comment": "<h1>Functorial interface<\/h1> <br><\/br> <a href=\"{module|Cow.Xml.Make}\" ><span class=\"code\" >Cow.Xml.Make<\/span><\/a> allows client to specify types for strings and internal buffers. Among other things this can be used to perform hash-consing or to process the character stream, e.g. to normalize unicode characters or to convert to a custom encoding."}, {"type": {"name": "Cow.Xml.std_string", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|8948"}, "info": "", "params": [], "kind": {"type": "abstract"}, "manifest": "string"}}, {"type": {"name": "Cow.Xml.std_buffer", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|8973"}, "info": "", "params": [], "kind": {"type": "abstract"}, "manifest": "Buffer.t"}}, {"module_type": {"name": "Cow.Xml.XMLString", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|9032"}, "info": {"description": "Input signature for strings."}, "type": "sig  end", "kind": ""}}, {"module_type": {"name": "Cow.Xml.XMLBuffer", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|10071"}, "info": {"description": "Input signature for internal buffers."}, "type": "sig  end", "kind": ""}}, {"module_type": {"name": "Cow.Xml.S", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|10811"}, "info": {"description": "Output signature of <a href=\"{module|Cow.Xml.Make}\" ><span class=\"code\" >Cow.Xml.Make<\/span><\/a>."}, "type": "sig  end", "kind": ""}}, {"module": {"name": "Cow.Xml.Make", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|12952"}, "info": {"description": "Functor building streaming XML IO with the given strings and buffers."}, "type": "functor (String : XMLString) -> functor (Buffer : sig  end) -> sig  end", "module_functor": {"parameter": {"name": "String"}, "module_functor": {"parameter": {"name": "Buffer"}, "module_with": "unavailable"}}, "dependencies": {"uses": []}}}, {"comment": "<h1>Features and limitations<\/h1><br><\/br> The module assumes strings are immutable, thus strings the client gives or receives <em>during<\/em> the input and output process  must not be modified. <h2>Input<\/h2> <h3>Encoding<\/h3>    <br><\/br> The parser supports ASCII, US-ASCII,  <a href=\"http:\/\/www.faqs.org\/rfcs\/rfc3629.html\" > UTF-8<\/a>, <a href=\"http:\/\/www.faqs.org\/rfcs\/rfc2781.html\" > UTF-16<\/a>, <a href=\"http:\/\/www.faqs.org\/rfcs\/rfc2781.html\" > UTF-16LE<\/a>, <a href=\"http:\/\/www.faqs.org\/rfcs\/rfc2781.html\" > UTF-16BE<\/a> and <a href=\"http:\/\/anubis.dkuug.dk\/JTC1\/SC2\/WG3\/docs\/n411.pdf\" >ISO-8559-1<\/a>  (Latin-1) encoded documents. But strings returned by the library are <b>always<\/b> UTF-8 encoded (unless you use the functor). <br><\/br> The encoding can be specified explicitly using the optional argument <span class=\"code\" >enc<\/span>. Otherwise the parser uses UTF-16 or UTF-8 if there is a <a href=\"http:\/\/www.unicode.org\/unicode\/faq\/utf_bom.html#BOM\" >BOM<\/a> at the beginning of the document. If there is no BOM it uses the encoding specified in the <a href=\"http:\/\/www.w3.org\/TR\/REC-xml\/#NT-XMLDecl\" > XML declaration<\/a>. Finally, if there is no XML declaration UTF-8 is assumed. <h3>White space handling<\/h3><br><\/br> The parser performs <a href=\"http:\/\/www.w3.org\/TR\/REC-xml\/#AVNormalize\" >attribute data normalization<\/a> on <em>every<\/em> attribute data.  This means that attribute data does not have leading and trailling white space and that  any white space is collapsed and transformed to a single space  character (<span class=\"code\" >U+0020<\/span>).<br><\/br> White space handling of character data depends on the <span class=\"code\" >strip<\/span> argument. If <span class=\"code\" >strip<\/span> is <span class=\"code\" >true<\/span>, character data is treated like attribute data, white space before and after elements is removed and any white space is collapsed and transformed to a single space character (<span class=\"code\" >U+0020<\/span>), except if the data is under the scope of a <em>    xml:space<\/em> attribute whose value is <em>preserve<\/em>.  If <span class=\"code\" >strip<\/span> is <span class=\"code\" >false<\/span> all white space data is preserved as present in the document (however all kinds of <a href=\"http:\/\/www.w3.org\/TR\/REC-xml\/#sec-line-ends\" >line ends<\/a> are translated to the newline character (<span class=\"code\" >U+000A<\/span>).  <h3>Namespaces<\/h3><br><\/br> Xmlm's <a href=\"#TYPEname\" >names<\/a> are <a href=\"http:\/\/www.w3.org\/TR\/xml-names11\/#dt-expname\" >expanded names<\/a>. The parser automatically handles the document's namespace declarations.  Undeclared namespace prefixes can be bound via the callback <span class=\"code\" >ns<\/span>, which must return a namespace name. If <span class=\"code\" >ns<\/span> returns <span class=\"code\" >None<\/span> an <span class=\"code\" >`Unknown_ns_prefix<\/span> error is raised.<br><\/br> Attributes used for namespace declarations are preserved by the parser. They are in the <a href=\"{value|Cow.Xml.ns_xmlns}\" ><span class=\"code\" >Cow.Xml.ns_xmlns<\/span><\/a> namespace. Default namespace declarations made with <i>xmlns<\/i> have the attribute name <span class=\"code\" >(Xmlm.ns_xmlns, \"xmlns\")<\/span>. Prefix declarations have the prefix as the local name, for example <i>xmlns:ex<\/i> results in the attribute name <span class=\"code\" >(Xmlm.ns_xmlns, \"ex\")<\/span>.<br><\/br> Regarding constraints on the usage of the <i>xml<\/i> and <i>xmlns<\/i> prefixes by documents, the parser does not report errors on violations  of the <i>must<\/i> constraints listed in <a href=\"http:\/\/www.w3.org\/TR\/xml-names11\/#xmlReserved\" >this paragraph<\/a>.  <h3>Character and entity references<\/h3><br><\/br> <a href=\"http:\/\/www.w3.org\/TR\/REC-xml\/#dt-charref\" >Character references<\/a> and <a href=\"http:\/\/www.w3.org\/TR\/REC-xml\/#sec-predefined-ent\" >predefined entities<\/a> are automatically resolved. Other entity references can be resolved by the callback <span class=\"code\" >entity<\/span>, which must return an UTF-8 (unless you use the functor) string corresponding to the replacement character data.  The replacement data is <em>not<\/em> analysed for further references, it is added to the data as such modulo white space stripping. If <span class=\"code\" >entity<\/span> returns <span class=\"code\" >None<\/span> the error <span class=\"code\" >`Unknown_entity_ref<\/span> is returned.     <h3>Sequences of documents<\/h3><br><\/br> When a well-formed sequence of signals is input, no data is consumed beyond the closing <span class=\"code\" >'&gt;'<\/span> of the document's root element. <br><\/br> If you want to parse a document as <a href=\"http:\/\/www.w3.org\/TR\/REC-xml\/#NT-document\" >defined<\/a> in the XML specification, call <a href=\"{value|Cow.Xml.eoi}\" ><span class=\"code\" >Cow.Xml.eoi<\/span><\/a> after a well-formed sequence of signals, it must return <span class=\"code\" >true<\/span>. If you expect another document on the same input abstraction a new well-formed sequence of signals can be <a href=\"{value|Cow.Xml.input}\" ><span class=\"code\" >Cow.Xml.input<\/span><\/a>. Use <a href=\"{value|Cow.Xml.eoi}\" ><span class=\"code\" >Cow.Xml.eoi<\/span><\/a> to check if a document follows (this may consume data).<br><\/br> Invoking <a href=\"{value|Cow.Xml.eoi}\" ><span class=\"code\" >Cow.Xml.eoi<\/span><\/a> after a well-formed sequence of signals skips whitespaces, comments and processing instructions until it gets to either an <a href=\"http:\/\/www.w3.org\/TR\/REC-xml\/#NT-XMLDecl\" > XML declaration<\/a> or a <a href=\"http:\/\/www.w3.org\/TR\/REC-xml\/#dt-doctype\" >DTD<\/a> or the start of a new element or the end of input (in which case <a href=\"{value|Cow.Xml.eoi}\" ><span class=\"code\" >Cow.Xml.eoi<\/span><\/a> returns <span class=\"code\" >true<\/span>).  If there is a new document but there is no XML declaration or the declaration specifies UTF-16, the same encoding as for the previous document is used.<br><\/br> <h3>Miscellaneous<\/h3> <ul><li>Parses the more liberal and simpler XML 1.1  <a href=\"http:\/\/www.w3.org\/TR\/xml11\/#NT-Name\" >Name<\/a> definition (minus <span class=\"code\" >':'<\/span> because of namespaces).<\/li><li>The <a href=\"http:\/\/www.w3.org\/TR\/REC-xml\/#dt-doctype\" >DTD<\/a> is parsed roughly (no guarantee it is well formed) and its information is ignored.<\/li><li>The parser drops  <a href=\"http:\/\/www.w3.org\/TR\/REC-xml\/#dt-comment\" >comments<\/a>,  <a href=\"http:\/\/www.w3.org\/TR\/REC-xml\/#dt-pi\" >processing instructions<\/a>, and  <a href=\"http:\/\/www.w3.org\/TR\/REC-xml\/#sec-rmd\" >standalone declaration<\/a>.<\/li><li>Element attributes are not checked for uniqueness.<\/li><li>Attribute and character data chunks are limited by  <span class=\"code\" >Sys.max_string_length<\/span> (unless you use the functor).  The error <span class=\"code\" >`Max_buffer_size<\/span> is raised if the limit is hit.<\/li><li>Tail recursive.<\/li><li>Non validating.<\/li><\/ul><br><\/br> <h2>Output<\/h2>  <h3>Encoding<\/h3> <br><\/br> Outputs only <a href=\"http:\/\/www.faqs.org\/rfcs\/rfc3629.html\" > UTF-8<\/a> encoded documents (even if you use the functor).  Strings given to output functions <b>must be<\/b> UTF-8 encoded (unless you use the functor, but you need to provide a translation), no checks are performed.  <h3>Namespaces<\/h3><br><\/br> Xmlm's <a href=\"#TYPEname\" >names<\/a> are <a href=\"http:\/\/www.w3.org\/TR\/xml-names11\/#dt-expname\" >expanded names<\/a>. Expanded names are automatically converted to <a href=\"http:\/\/www.w3.org\/TR\/xml-names11\/#dt-qualname\" >qualified names<\/a> by the output abstraction. There is no particular api to specify  prefixes and default namespaces,  the actual result depends solely on the output of attributes belonging to the <a href=\"{value|Cow.Xml.ns_xmlns}\" ><span class=\"code\" >Cow.Xml.ns_xmlns<\/span><\/a> namespace. For example to set  the default namespace of an element to <i>http:\/\/example.org\/myns<\/i>,  use the following attribute : <span class=\"codepre\" >(* xmlns='http:\/\/example.org\/myns' *) let default_ns = (Xmlm.ns_xmlns, \"xmlns\"), \"http:\/\/example.org\/myns\"<\/span> To bind the prefix <span class=\"code\" >\"ex\"<\/span> to <i>http:\/\/example.org\/ex<\/i>, use the  following attribute : <span class=\"codepre\" >(* xmlns:ex='http:\/\/example.org\/ex' *) let ex_ns = (Xmlm.ns_xmlns, \"ex\"), \"http:\/\/example.org\/ex\"<\/span> Note that outputing input signals without touching namespace declaration attributes will preserve existing prefixes and bindings provided the same namespace name is not bound to different prefixes in a given context.<br><\/br> The callback <span class=\"code\" >ns_prefix<\/span> of an output abstraction can be used to give a prefix to a namespace name lacking a prefix binding in the current output scope. Given a namespace name the function must return  the prefix to use. Note that this will <b>not<\/b> add any namespace declaration attribute to the output.  If the function returns <span class=\"code\" >None<\/span>, <a href=\"{value|Cow.Xml.output}\" ><span class=\"code\" >Cow.Xml.output<\/span><\/a> will raise <span class=\"code\" >Invalid_argument<\/span>.  The default function returns always <span class=\"code\" >None<\/span>. <h3>Indentation<\/h3><br><\/br> Output can be indented by specifying the <span class=\"code\" >indent<\/span> argument when an output abstraction is created. If <span class=\"code\" >indent<\/span> is <span class=\"code\" >None<\/span> (default) signal output does not introduce any extra white space.  If <span class=\"code\" >ident<\/span> is <span class=\"code\" >Some c<\/span>, each <a href=\"{type|Cow.Xml.signal}\" ><span class=\"code\" >Cow.Xml.signal<\/span><\/a> is output on its own line (for empty elements <span class=\"code\" >`El_start<\/span> and <span class=\"code\" >`El_end<\/span> are collapsed on a single line) and nested elements are indented with <span class=\"code\" >c<\/span> space characters. <h3>Sequences of documents<\/h3> <br><\/br> After a well-formed sequence of signals was output, the output abstraction can be reused to output a new well-formed sequence of signals.<br><\/br> <h3>Miscellaneous<\/h3> <ul><li>In attribute and character data you provide, markup  delimiters <span class=\"code\" >'&lt;'<\/span>,<span class=\"code\" >'&gt;'<\/span>,<span class=\"code\" >'&amp;'<\/span>, and <span class=\"code\" >'\\\"'<\/span> are  automatically escaped to  <a href=\"http:\/\/www.w3.org\/TR\/REC-xml\/#sec-predefined-ent\" >predefined entities<\/a>.<\/li><li>No checks are peformed on the prefix and local part of output names to verify they are <a href=\"http:\/\/www.w3.org\/TR\/xml-names11\/#NT-NCName\" >NCName<\/a>s. For example using the tag name <span class=\"code\" >(\"\",\"dip d\")<\/span> will produce  a non well-formed document because of the space character.<\/li><li>Tail recursive.<\/li><\/ul><br><\/br> <h2>Tips<\/h2>  <ul><li>The best options to do an input\/output round trip and preserve as much information as possible is to  input with <span class=\"code\" >strip = false<\/span> and output with <span class=\"code\" >indent = None<\/span>.<\/li><li>Complete whitespace control on output is achieved  with <span class=\"code\" >indent = None<\/span> and suitable <span class=\"code\" >`Data<\/span> signals<\/li><\/ul>"}, {"comment": "<h1>Examples<\/h1> <br><\/br> <h2>Sequential processing<\/h2>    <br><\/br> Sequential processing has the advantage that you don't need to get the whole document tree in memory to process it.<br><\/br> The following function reads a <em>single<\/em> document on an input channel and outputs it. <span class=\"codepre\" >let id ic oc =  let i = Xmlm.make_input (`Channel ic) in  let o = Xmlm.make_output (`Channel oc) in  let rec pull i o depth =  Xmlm.output o (Xmlm.peek i); match Xmlm.input i with  | `El_start _ -&gt; pull i o (depth + 1) | `El_end -&gt; if depth = 1 then () else pull i o (depth - 1) | `Data _ -&gt; pull i o depth  | `Dtd _ -&gt; assert false in Xmlm.output o (Xmlm.input i); (* `Dtd *) pull i o 0; if not (Xmlm.eoi i) then invalid_arg \"document not well-formed\"<\/span> The following function reads a <em>sequence<\/em> of documents on an input channel and outputs it. <span class=\"codepre\" >let id_seq ic oc =  let i = Xmlm.make_input (`Channel ic) in  let o = Xmlm.make_output ~nl:true (`Channel oc) in  while not (Xmlm.eoi i) do Xmlm.output o (Xmlm.input i) done<\/span> The following function reads a <em>sequence<\/em> of documents on the  input channel. In each document's tree it prunes non root elements whose name belongs to <span class=\"code\" >prune_list<\/span>. <span class=\"codepre\" >let prune_docs prune_list ic oc =  let i = Xmlm.make_input (`Channel ic) in let o = Xmlm.make_output ~nl:true (`Channel oc) in let copy i o = Xmlm.output o (Xmlm.input i) in let prune (name, _) = List.mem name prune_list in let rec process i o d =  let rec skip i d = match Xmlm.input i with | `El_start _ -&gt; skip i (d + 1) | `El_end -&gt; if d = 1 then () else skip i (d - 1) | s -&gt; skip i d in match Xmlm.peek i with  | `El_start tag when prune tag -&gt; skip i 0; process i o d | `El_start _ -&gt; copy i o; process i o (d + 1) | `El_end -&gt; copy i o; if d = 0 then () else process i o (d - 1) | `Data _ -&gt; copy i o; process i o d | `Dtd _ -&gt; assert false in let rec docs i o =  copy i o; (* `Dtd *) copy i o; (* root start *) process i o 0; if Xmlm.eoi i then () else docs i o in docs i o<\/span><br><\/br> <h2>Tree processing<\/h2> <br><\/br> A document's sequence of signals can be easily converted to an arborescent data structure. Assume your trees are defined by : <span class=\"codepre\" >type tree = E of Xmlm.tag * tree list | D of string<\/span> The following functions input\/output xml documents from\/to abstractions  as value of type <span class=\"code\" >tree<\/span>. <span class=\"codepre\" >let in_tree i =  let el tag childs = E (tag, childs)  in let data d = D d in Xmlm.input_doc_tree ~el ~data i let out_tree o t =  let frag = function | E (tag, childs) -&gt; `El (tag, childs)  | D d -&gt; `Data d  in Xmlm.output_doc_tree frag o t<\/span> <br><\/br> <h2>Tabular data processing<\/h2><br><\/br> We show how to process XML data that represents tabular data (some people like do that).<br><\/br> The file we need to deal with represents nominal data about <a href=\"http:\/\/www.w3.org\/\" >W3C bureaucrats<\/a>. There are no namespaces and attributes are ignored. The element structure of the document is : <ul><li>&lt;list&gt; <ul><li>&lt;bureaucrat&gt; represents a W3C bureaucrat (zero or more).<br><\/br> A bureaucrat contains the following elements, in order. <ul><li>&lt;name&gt; its name (mandatory, string).<\/li><li>&lt;surname&gt; its surname (mandatory, string).<\/li><li>&lt;honest&gt; present iff he implemented one of its spec  (optional, empty).<\/li><li>&lt;obfuscation_level&gt; its grade on the open scale of obfuscation (mandatory, float).<\/li><li>&lt;tr&gt; (zero or more, string), technical reports he worked on.<\/li><\/ul><\/li><\/ul><\/li><\/ul><br><\/br> In OCaml we represent a W3C bureaucrat by this type : <span class=\"codepre\" >type w3c_bureaucrat = {  name : string;  surname : string;  honest : bool;  obfuscation_level : float; trs : string list; }<\/span> The following functions input and output W3C bureaucrats as lists of values of type <span class=\"code\" >w3c_bureaucrat<\/span>. <span class=\"codepre\" >let in_w3c_bureaucrats src =  let i = Xmlm.make_input ~strip:true src in let tag n = (\"\", n), [] in let error () = invalid_arg \"parse error\" in let accept s i = if Xmlm.input i = s then () else error () in let rec i_seq el acc i = match Xmlm.peek i with  | `El_start _ -&gt; i_seq el ((el i) :: acc) i | `El_end -&gt; List.rev acc | _ -&gt; error () in let i_el n i =  accept (`El_start (tag n)) i; let d = match Xmlm.peek i with | `Data d -&gt; ignore (Xmlm.input i); d | `El_end -&gt; \"\" | _ -&gt; error () in accept (`El_end) i; d in let i_bureaucrat i =  try accept (`El_start (tag \"bureaucrat\")) i; let name = i_el \"name\" i in let surname = i_el \"surname\" i in let honest = match Xmlm.peek i with | `El_start ((\"\", \"honest\"), []) -&gt; ignore (i_el \"honest\" i); true | _ -&gt; false in let obf = float_of_string (i_el \"obfuscation_level\" i) in let trs = i_seq (i_el \"tr\") [] i in accept (`El_end) i; { name = name; surname = surname; honest = honest;  obfuscation_level = obf; trs = trs } with | Failure _ -&gt; error () (* float_of_string *) in accept (`Dtd None) i; accept (`El_start (tag \"list\")) i; let bl = i_seq i_bureaucrat [] i in accept (`El_end) i; if not (Xmlm.eoi i) then invalid_arg \"more than one document\"; bl let out_w3c_bureaucrats dst bl =  let tag n = (\"\", n), [] in let o = Xmlm.make_output ~nl:true ~indent:(Some 2) dst in let out = Xmlm.output o in let o_el n d =  out (`El_start (tag n));  if d &lt;&gt; \"\" then out (`Data d);  out `El_end  in let o_bureaucrat b =  out (`El_start (tag \"bureaucrat\")); o_el \"name\" b.name; o_el \"surname\" b.surname; if b.honest then o_el \"honest\" \"\"; o_el \"obfuscation_level\" (string_of_float b.obfuscation_level); List.iter (o_el \"tr\") b.trs; out `El_end in out (`Dtd None); out (`El_start (tag \"list\")); List.iter o_bureaucrat bl; out (`El_end)<\/span>"}, {"value": {"name": "Cow.Xml.to_string", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|28319"}, "info": "", "type": "Cow.Xml.t -> string", "params": [{"name": "", "type": "Cow.Xml.t"}]}}, {"value": {"name": "Cow.Xml.of_string", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|28347"}, "info": "", "type": "?entity:(string -> string option) ->\n  ?templates:(string * Cow.Xml.t) list ->\n  ?enc:Cow.Xml.encoding -> string -> Cow.Xml.t", "params": [{"name": "entity", "type": "(string -> string option) option"}, {"name": "templates", "type": "(string * Cow.Xml.t) list option"}, {"name": "enc", "type": "Cow.Xml.encoding option"}, {"name": "", "type": "string"}]}}], "dependencies": {"uses": []}}}, {"module": {"name": "Cow.Html", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|30203"}, "info": "", "type": "sig  end", "module_structure": [{"type": {"name": "Cow.Html.t", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|30228"}, "info": "", "params": [], "kind": {"type": "abstract"}, "manifest": "('a Cow.Xml.frag as 'a) Cow.Xml.frag list"}}, {"value": {"name": "Cow.Html.to_string", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|30269"}, "info": "", "type": "Cow.Html.t -> string", "params": [{"name": "", "type": "Cow.Html.t"}]}}, {"value": {"name": "Cow.Html.of_string", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|30298"}, "info": "", "type": "?templates:(string * Cow.Html.t) list ->\n  ?enc:Cow.Xml.encoding -> string -> Cow.Html.t", "params": [{"name": "templates", "type": "(string * Cow.Html.t) list option"}, {"name": "enc", "type": "Cow.Xml.encoding option"}, {"name": "", "type": "string"}]}}, {"comment": "<h2>HTML library<\/h2>"}, {"type": {"name": "Cow.Html.link", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|30420"}, "info": "", "params": [], "kind": {"type": "record", "private": "false", "fields": [{"name": "text", "mutable": false, "type": "string"}, {"name": "href", "mutable": false, "type": "string"}]}}}, {"value": {"name": "Cow.Html.html_of_link", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|30465"}, "info": "", "type": "Cow.Html.link -> Cow.Html.t", "params": [{"name": "", "type": "Cow.Html.link"}]}}, {"value": {"name": "Cow.Html.interleave", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|30495"}, "info": "", "type": "string array -> Cow.Html.t list -> Cow.Html.t list", "params": [{"name": "", "type": "string array"}, {"name": "", "type": "Cow.Html.t list"}]}}, {"value": {"name": "Cow.Html.html_of_string", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|30546"}, "info": "", "type": "string -> Cow.Html.t", "params": [{"name": "", "type": "string"}]}}, {"value": {"name": "Cow.Html.html_of_int", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|30579"}, "info": "", "type": "int -> Cow.Html.t", "params": [{"name": "", "type": "int"}]}}, {"value": {"name": "Cow.Html.html_of_float", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|30606"}, "info": "", "type": "float -> Cow.Html.t", "params": [{"name": "", "type": "float"}]}}, {"type": {"name": "Cow.Html.table", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|30643"}, "info": "", "params": [], "kind": {"type": "abstract"}, "manifest": "Cow.Html.t array array"}}, {"value": {"name": "Cow.Html.html_of_table", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|30666"}, "info": "", "type": "?headings:bool -> Cow.Html.table -> Cow.Html.t", "params": [{"name": "headings", "type": "bool option"}, {"name": "", "type": "Cow.Html.table"}]}}, {"value": {"name": "Cow.Html.nil", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|30716"}, "info": "", "type": "Cow.Html.t", "params": []}}], "dependencies": {"uses": []}}}, {"module": {"name": "Cow.Css", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|30732"}, "info": "", "type": "sig  end", "module_structure": [{"type": {"name": "Cow.Css.elt", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|30778"}, "info": {"description": "Single element"}, "params": [], "kind": {"type": "variant", "private": "false", "constructors": [{"name": "Str", "type": ["string"]}, {"name": "Fun", "type": ["string", "Cow.Css.expr list"]}]}}}, {"type": {"name": "Cow.Css.expr", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|30889"}, "info": {"description": "Expression: `.body a:hover`. No commas here."}, "params": [], "kind": {"type": "abstract"}, "manifest": "Cow.Css.elt list"}}, {"type": {"name": "Cow.Css.prop_decl", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|30947"}, "info": {"description": "We allow nested declarations"}, "params": [], "kind": {"type": "variant", "private": "false", "constructors": [{"name": "Prop", "type": ["string", "Cow.Css.expr list"]}, {"name": "Decl", "type": ["Cow.Css.expr list", "Cow.Css.prop_decl list"]}]}}}, {"type": {"name": "Cow.Css.t", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|31124"}, "info": {"description": "The type of CSS fragment"}, "params": [], "kind": {"type": "variant", "private": "false", "constructors": [{"name": "Props", "type": ["Cow.Css.prop_decl list"]}, {"name": "Exprs", "type": ["Cow.Css.expr list"]}]}}}, {"value": {"name": "Cow.Css.to_string", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|31180"}, "info": "", "type": "Cow.Css.t -> string", "params": [{"name": "", "type": "Cow.Css.t"}]}}, {"comment": "<h2>Getters<\/h2>"}, {"value": {"name": "Cow.Css.expr", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|31229"}, "info": "", "type": "Cow.Css.t -> Cow.Css.expr", "params": [{"name": "", "type": "Cow.Css.t"}]}}, {"value": {"name": "Cow.Css.exprs", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|31250"}, "info": "", "type": "Cow.Css.t -> Cow.Css.expr list", "params": [{"name": "", "type": "Cow.Css.t"}]}}, {"value": {"name": "Cow.Css.props", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|31277"}, "info": "", "type": "Cow.Css.t -> Cow.Css.prop_decl list", "params": [{"name": "", "type": "Cow.Css.t"}]}}, {"value": {"name": "Cow.Css.string", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|31309"}, "info": "", "type": "Cow.Css.t -> string", "params": [{"name": "", "type": "Cow.Css.t"}]}}, {"comment": "<h3>Helpers<\/h3>"}, {"value": {"name": "Cow.Css.unroll", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|31468"}, "info": {"description": "transform a fragment with nested declarations into an equivalent fragment with only root declarations"}, "type": "Cow.Css.t -> Cow.Css.t", "params": [{"name": "", "type": "Cow.Css.t"}]}}, {"comment": "<h2>CSS library<\/h2>"}, {"value": {"name": "Cow.Css.gradient", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|31513"}, "info": "", "type": "low:Cow.Css.t -> high:Cow.Css.t -> Cow.Css.t", "params": [{"name": "low", "type": "Cow.Css.t"}, {"name": "high", "type": "Cow.Css.t"}]}}, {"value": {"name": "Cow.Css.top_rounded", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|31550"}, "info": "", "type": "Cow.Css.t", "params": []}}, {"value": {"name": "Cow.Css.bottom_rounded", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|31570"}, "info": "", "type": "Cow.Css.t", "params": []}}, {"value": {"name": "Cow.Css.rounded", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|31593"}, "info": "", "type": "Cow.Css.t", "params": []}}, {"value": {"name": "Cow.Css.box_shadow", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|31610"}, "info": "", "type": "Cow.Css.t", "params": []}}, {"value": {"name": "Cow.Css.text_shadow", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|31629"}, "info": "", "type": "Cow.Css.t", "params": []}}, {"value": {"name": "Cow.Css.no_padding", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|31650"}, "info": "", "type": "Cow.Css.t", "params": []}}, {"value": {"name": "Cow.Css.reset_padding", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|31669"}, "info": "", "type": "Cow.Css.t", "params": []}}], "dependencies": {"uses": []}}}, {"module": {"name": "Cow.Code", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|31696"}, "info": "", "type": "sig  end", "module_structure": [{"value": {"name": "Cow.Code.ocaml", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|31825"}, "info": {"description": "Convert a string into an xHTML fragment, where keywords have been classified in different classes"}, "type": "string -> Cow.Html.t", "params": [{"name": "", "type": "string"}]}}, {"value": {"name": "Cow.Code.ocaml_css", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|31926"}, "info": {"description": "CSS fragment to colorize the keywords, depending on their class"}, "type": "Cow.Css.t", "params": []}}], "dependencies": {"uses": []}}}, {"module": {"name": "Cow.Atom", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|31952"}, "info": "", "type": "sig  end", "module_structure": [{"type": {"name": "Cow.Atom.author", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|31977"}, "info": "", "params": [], "kind": {"type": "record", "private": "false", "fields": [{"name": "name", "mutable": false, "type": "string"}, {"name": "uri", "mutable": false, "type": "string option"}, {"name": "email", "mutable": false, "type": "string option"}]}}}, {"type": {"name": "Cow.Atom.date", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|32064"}, "info": "", "params": [], "kind": {"type": "abstract"}, "manifest": "int * int * int * int * int"}}, {"value": {"name": "Cow.Atom.compare", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|32100"}, "info": "", "type": "Cow.Atom.date -> Cow.Atom.date -> int", "params": [{"name": "", "type": "Cow.Atom.date"}, {"name": "", "type": "Cow.Atom.date"}]}}, {"type": {"name": "Cow.Atom.meta", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|32140"}, "info": "", "params": [], "kind": {"type": "record", "private": "false", "fields": [{"name": "id", "mutable": false, "type": "string"}, {"name": "title", "mutable": false, "type": "string"}, {"name": "subtitle", "mutable": false, "type": "string option"}, {"name": "author", "mutable": false, "type": "Cow.Atom.author option"}, {"name": "rights", "mutable": false, "type": "string option"}, {"name": "updated", "mutable": false, "type": "Cow.Atom.date"}]}}}, {"type": {"name": "Cow.Atom.summary", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|32326"}, "info": "", "params": [], "kind": {"type": "abstract"}, "manifest": "string option"}}, {"type": {"name": "Cow.Atom.entry", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|32356"}, "info": "", "params": [], "kind": {"type": "record", "private": "false", "fields": [{"name": "entry", "mutable": false, "type": "Cow.Atom.meta"}, {"name": "summary", "mutable": false, "type": "Cow.Atom.summary"}, {"name": "content", "mutable": false, "type": "Cow.Xml.t"}]}}}, {"type": {"name": "Cow.Atom.feed", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|32432"}, "info": "", "params": [], "kind": {"type": "record", "private": "false", "fields": [{"name": "feed", "mutable": false, "type": "Cow.Atom.meta"}, {"name": "entries", "mutable": false, "type": "Cow.Atom.entry list"}]}}}, {"value": {"name": "Cow.Atom.xml_of_feed", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|32486"}, "info": "", "type": "?self:string -> Cow.Atom.feed -> Cow.Xml.t", "params": [{"name": "self", "type": "string option"}, {"name": "", "type": "Cow.Atom.feed"}]}}], "dependencies": {"uses": []}}}, {"module": {"name": "Cow.Markdown", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|32539"}, "info": "", "type": "sig  end", "module_structure": [{"type": {"name": "Cow.Markdown.ref", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|32568"}, "info": "", "params": [], "kind": {"type": "record", "private": "false", "fields": [{"name": "src", "mutable": false, "type": "string"}, {"name": "desc", "mutable": false, "type": "string"}]}}}, {"type": {"name": "Cow.Markdown.paragraph", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|32612"}, "info": "", "params": [], "kind": {"type": "variant", "private": "false", "constructors": [{"name": "Normal", "type": ["Cow.Markdown.par_text"]}, {"name": "Html", "type": ["Cow.Html.t"]}, {"name": "Pre", "type": ["string", "string option"]}, {"name": "Heading", "type": ["int", "Cow.Markdown.par_text"]}, {"name": "Quote", "type": ["Cow.Markdown.paragraph list"]}, {"name": "Ulist", "type": ["Cow.Markdown.paragraph list", "Cow.Markdown.paragraph list list"]}, {"name": "Olist", "type": ["Cow.Markdown.paragraph list", "Cow.Markdown.paragraph list list"]}]}}}, {"type": {"name": "Cow.Markdown.par_text", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|32863"}, "info": "", "params": [], "kind": {"type": "abstract"}, "manifest": "Cow.Markdown.text list"}}, {"type": {"name": "Cow.Markdown.text", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|32889"}, "info": "", "params": [], "kind": {"type": "variant", "private": "false", "constructors": [{"name": "Text", "type": ["string"]}, {"name": "Emph", "type": ["string"]}, {"name": "Bold", "type": ["string"]}, {"name": "Struck", "type": ["Cow.Markdown.par_text"]}, {"name": "Code", "type": ["string"]}, {"name": "Link", "type": ["Cow.Markdown.href"]}, {"name": "Anchor", "type": ["string"]}, {"name": "Image", "type": ["Cow.Markdown.img_ref"]}]}}}, {"type": {"name": "Cow.Markdown.href", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|33059"}, "info": "", "params": [], "kind": {"type": "record", "private": "false", "fields": [{"name": "href_target", "mutable": false, "type": "string"}, {"name": "href_desc", "mutable": false, "type": "string"}]}}}, {"type": {"name": "Cow.Markdown.img_ref", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|33117"}, "info": "", "params": [], "kind": {"type": "record", "private": "false", "fields": [{"name": "img_src", "mutable": false, "type": "string"}, {"name": "img_alt", "mutable": false, "type": "string"}]}}}, {"type": {"name": "Cow.Markdown.t", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|33172"}, "info": "", "params": [], "kind": {"type": "abstract"}, "manifest": "Cow.Markdown.paragraph list"}}, {"value": {"name": "Cow.Markdown.to_html", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|33193"}, "info": "", "type": "Cow.Markdown.t -> Cow.Html.t", "params": [{"name": "", "type": "Cow.Markdown.t"}]}}, {"value": {"name": "Cow.Markdown.of_string", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|33220"}, "info": "", "type": "string -> Cow.Markdown.t", "params": [{"name": "", "type": "string"}]}}], "dependencies": {"uses": []}}}, {"module": {"name": "Cow.Json", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|33252"}, "info": "", "type": "sig  end", "module_structure": [{"type": {"name": "Cow.Json.t", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|33277"}, "info": "", "params": [], "kind": {"type": "variant", "private": "false", "constructors": [{"name": "Int", "type": ["int64"]}, {"name": "Bool", "type": ["bool"]}, {"name": "Float", "type": ["float"]}, {"name": "String", "type": ["string"]}, {"name": "Array", "type": ["Cow.Json.t list"]}, {"name": "Object", "type": ["(string * Cow.Json.t) list"]}, {"name": "Null", "type": []}]}}}, {"value": {"name": "Cow.Json.to_string", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|33417"}, "info": "", "type": "Cow.Json.t -> string", "params": [{"name": "", "type": "Cow.Json.t"}]}}, {"value": {"name": "Cow.Json.of_string", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|33445"}, "info": "", "type": "string -> Cow.Json.t", "params": [{"name": "", "type": "string"}]}}, {"exception": {"name": "Cow.Json.Runtime_error", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|33474"}, "info": "", "exception_args": ["string", "Cow.Json.t"]}}], "dependencies": {"uses": []}}}, {"module": {"name": "Cow.Twitter", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|33516"}, "info": "", "type": "sig  end", "module_structure": [{"module": {"name": "Cow.Twitter.User", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|33539"}, "info": "", "type": "sig  end", "module_structure": [{"type": {"name": "Cow.Twitter.User.t", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|33567"}, "info": "", "params": [], "kind": {"type": "record", "private": "false", "fields": [{"name": "id_str", "mutable": false, "type": "string"}, {"name": "screen_name", "mutable": false, "type": "string"}]}}}, {"value": {"name": "Cow.Twitter.User.json_of_t", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|33631"}, "info": "", "type": "Cow.Twitter.User.t -> Cow.Json.t", "params": [{"name": "", "type": "Cow.Twitter.User.t"}]}}, {"value": {"name": "Cow.Twitter.User.t_of_json", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|33661"}, "info": "", "type": "Cow.Json.t -> Cow.Twitter.User.t", "params": [{"name": "", "type": "Cow.Json.t"}]}}], "dependencies": {"uses": []}}}, {"module": {"name": "Cow.Twitter.Status", "file": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|33695"}, "info": "", "type": "sig  end", "module_structure": [{"type": {"name": "Cow.Twitter.Status.t", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|33723"}, "info": "", "params": [], "kind": {"type": "record", "private": "false", "fields": [{"name": "id", "mutable": false, "type": "int"}, {"name": "user", "mutable": false, "type": "Cow.Twitter.User.t"}, {"name": "text", "mutable": false, "type": "string"}]}}}, {"value": {"name": "Cow.Twitter.Status.json_of_t", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|33790"}, "info": "", "type": "Cow.Twitter.Status.t -> Cow.Json.t", "params": [{"name": "", "type": "Cow.Twitter.Status.t"}]}}, {"value": {"name": "Cow.Twitter.Status.t_of_json", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|33820"}, "info": "", "type": "Cow.Json.t -> Cow.Twitter.Status.t", "params": [{"name": "", "type": "Cow.Json.t"}]}}, {"value": {"name": "Cow.Twitter.Status.json_of_t_list", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|33851"}, "info": "", "type": "Cow.Twitter.Status.t list -> Cow.Json.t", "params": [{"name": "", "type": "Cow.Twitter.Status.t list"}]}}, {"value": {"name": "Cow.Twitter.Status.t_list_of_json", "location": {"implementation": "unknown", "interface": "\/Users\/avsm\/src\/git\/avsm\/mirage\/lib\/_build\/unix-socket\/std\/cow.mli|33891"}, "info": "", "type": "Cow.Json.t -> Cow.Twitter.Status.t list", "params": [{"name": "", "type": "Cow.Json.t"}]}}], "dependencies": {"uses": []}}}], "dependencies": {"uses": []}}}], "dependencies": {"uses": ["Buffer", "*predef*"], "used_by": []}}}}}
