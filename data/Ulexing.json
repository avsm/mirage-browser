{ "module": 
  { "name": "Ulexing",
    "file": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/ulexing.mli",
    "location": 
      { "implementation": "unknown",
        "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/ulexing.mli|0" },
    "info": 
      { "description": "Runtime support for lexers generated by <span class=\"code\" >ulex</span>. This module is roughly equivalent to the module Lexing from  the OCaml standard library, except that its lexbuffers handles Unicode code points (OCaml type: <span class=\"code\" >int</span> in the range <span class=\"code\" >0..0x10ffff</span>) instead of bytes (OCaml type: <span class=\"code\" >char</span>).<br></br> It is possible to have ulex-generated lexers work on a custom implementation for lex buffers. To do this, define a module <span class=\"code\" >L</span> which implements the <span class=\"code\" >start</span>, <span class=\"code\" >next</span>, <span class=\"code\" >mark</span> and <span class=\"code\" >backtrack</span> functions (See the Internal Interface section below for a specification), and the <span class=\"code\" >Error</span> exception.   They need not work on a type named <span class=\"code\" >lexbuf</span>: you can use the type name you want. Then, just do in your ulex-processed source, before the first lexer specification:<br></br> <span class=\"code\" >module Ulexing = L</span><br></br> Of course, you'll probably want to define functions like <span class=\"code\" >lexeme</span> to be used in the lexers semantic actions." },
    "type": "sig  end",
    "module_structure": [ 
      { "type": 
          { "name": "Ulexing.lexbuf",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/ulexing.mli|908" },
            "info": 
              { "description": "The type of lexer buffers. A lexer buffer is the argument passed to the scanning functions defined by the generated lexers. The lexer buffer holds the internal information for the scanners, including the code points of the token currently scanned, its position from the beginning of the input stream, and the current position of the lexer." },
            "params": [  ],
            "kind": 
              { "type": "abstract" } } }, 
      { "exception": 
          { "name": "Ulexing.Error",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/ulexing.mli|1285" },
            "info": 
              { "description": "Raised by a lexer when it cannot parse a token from the lexbuf.  The functions <span class=\"code\" >Ulexing.lexeme_start</span> (resp. <span class=\"code\" >Ulexing.lexeme_end</span>) can be  used to find to positions of the first code point of the current matched substring (resp. the first code point that yield the error)." } } }, 
      { "exception": 
          { "name": "Ulexing.InvalidCodepoint",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/ulexing.mli|1596" },
            "info": 
              { "description": "Raised by some functions to signal that some code point is not compatible with a specified encoding." },
            "exception_args": [ "int" ] } }, 
      { "comment": "<h6>Clients interface</h6>" }, 
      { "value": 
          { "name": "Ulexing.create",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/ulexing.mli|1775" },
            "info": 
              { "description": "Create a generic lexer buffer.  When the lexer needs more characters, it will call the given function, giving it an array of integers <span class=\"code\" >a</span>, a position <span class=\"code\" >pos</span> and a code point count <span class=\"code\" >n</span>.  The function should put <span class=\"code\" >n</span> code points or less in <span class=\"code\" >a</span>, starting at position <span class=\"code\" >pos</span>, and return the number of characters provided. A return value of 0 means end of input." },
            "type": "(int array -> int -> int -> int) -> Ulexing.lexbuf",
            "params": [ 
              { "name": "",
                "type": "int array -> int -> int -> int" } ] } }, 
      { "value": 
          { "name": "Ulexing.from_stream",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/ulexing.mli|2217" },
            "info": 
              { "description": "Create a lexbuf from a stream of Unicode code points." },
            "type": "int Stream.t -> Ulexing.lexbuf",
            "params": [ 
              { "name": "",
                "type": "int Stream.t" } ] } }, 
      { "value": 
          { "name": "Ulexing.from_int_array",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/ulexing.mli|2321" },
            "info": 
              { "description": "Create a lexbuf from an array of Unicode code points." },
            "type": "int array -> Ulexing.lexbuf",
            "params": [ 
              { "name": "",
                "type": "int array" } ] } }, 
      { "value": 
          { "name": "Ulexing.from_latin1_stream",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/ulexing.mli|2425" },
            "info": 
              { "description": "Create a lexbuf from a Latin1 encoded stream (ie a stream of Unicode code points in the range <span class=\"code\" >0..255</span>)" },
            "type": "char Stream.t -> Ulexing.lexbuf",
            "params": [ 
              { "name": "",
                "type": "char Stream.t" } ] } }, 
      { "value": 
          { "name": "Ulexing.from_latin1_channel",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/ulexing.mli|2591" },
            "info": 
              { "description": "Create a lexbuf from a Latin1 encoded input channel. The client is responsible for closing the channel." },
            "type": "Pervasives.in_channel -> Ulexing.lexbuf",
            "params": [ 
              { "name": "",
                "type": "Pervasives.in_channel" } ] } }, 
      { "value": 
          { "name": "Ulexing.from_latin1_string",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/ulexing.mli|2755" },
            "info": 
              { "description": "Create a lexbuf from a Latin1 encoded string." },
            "type": "string -> Ulexing.lexbuf",
            "params": [ 
              { "name": "",
                "type": "string" } ] } }, 
      { "value": 
          { "name": "Ulexing.from_utf8_stream",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/ulexing.mli|2852" },
            "info": 
              { "description": "Create a lexbuf from a UTF-8 encoded stream." },
            "type": "char Stream.t -> Ulexing.lexbuf",
            "params": [ 
              { "name": "",
                "type": "char Stream.t" } ] } }, 
      { "value": 
          { "name": "Ulexing.from_utf8_channel",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/ulexing.mli|2953" },
            "info": 
              { "description": "Create a lexbuf from a UTF-8 encoded input channel." },
            "type": "Pervasives.in_channel -> Ulexing.lexbuf",
            "params": [ 
              { "name": "",
                "type": "Pervasives.in_channel" } ] } }, 
      { "value": 
          { "name": "Ulexing.from_utf8_string",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/ulexing.mli|3059" },
            "info": 
              { "description": "Create a lexbuf from a UTF-8 encoded string." },
            "type": "string -> Ulexing.lexbuf",
            "params": [ 
              { "name": "",
                "type": "string" } ] } }, 
      { "type": 
          { "name": "Ulexing.enc",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/ulexing.mli|3158" },
            "info": "",
            "params": [  ],
            "kind": 
              { "type": "variant",
                "private": "false",
                "constructors": [ 
                  { "name": "Ascii",
                    "type": [  ] }, 
                  { "name": "Latin1",
                    "type": [  ] }, 
                  { "name": "Utf8",
                    "type": [  ] } ] } } }, 
      { "value": 
          { "name": "Ulexing.from_var_enc_stream",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/ulexing.mli|3186" },
            "info": 
              { "description": "Create a lexbuf from a stream whose encoding is subject to change during lexing. The reference can be changed at any point. Note that bytes that have been consumed by the lexer buffer are not re-interpreted with the new encoding.<br></br> In <span class=\"code\" >Ascii</span> mode, non-ASCII bytes (ie <span class=\"code\" >&gt;127</span>) in the stream raise an <span class=\"code\" >InvalidCodepoint</span> exception." },
            "type": "Ulexing.enc Pervasives.ref -> char Stream.t -> Ulexing.lexbuf",
            "params": [ 
              { "name": "",
                "type": "Ulexing.enc Pervasives.ref" }, 
              { "name": "",
                "type": "char Stream.t" } ] } }, 
      { "value": 
          { "name": "Ulexing.from_var_enc_string",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/ulexing.mli|3605" },
            "info": 
              { "description": "Same as <span class=\"code\" >Ulexing.from_var_enc_stream</span> with a string as input." },
            "type": "Ulexing.enc Pervasives.ref -> string -> Ulexing.lexbuf",
            "params": [ 
              { "name": "",
                "type": "Ulexing.enc Pervasives.ref" }, 
              { "name": "",
                "type": "string" } ] } }, 
      { "value": 
          { "name": "Ulexing.from_var_enc_channel",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/ulexing.mli|3730" },
            "info": 
              { "description": "Same as <span class=\"code\" >Ulexing.from_var_enc_stream</span> with a channel as input." },
            "type": "Ulexing.enc Pervasives.ref -> Pervasives.in_channel -> Ulexing.lexbuf",
            "params": [ 
              { "name": "",
                "type": "Ulexing.enc Pervasives.ref" }, 
              { "name": "",
                "type": "Pervasives.in_channel" } ] } }, 
      { "comment": "<h6>Interface for lexers semantic actions</h6>" }, 
      { "comment": "The following functions can be called from the semantic actions of lexer definitions.  They give access to the character string matched by the regular expression associated with the semantic action. These functions must be applied to the argument <span class=\"code\" >lexbuf</span>, which, in the code generated by <span class=\"code\" >ulex</span>, is bound to the lexer buffer passed to the parsing function.<br></br> These functions can also be called when capturing a <span class=\"code\" >Ulexing.Error</span>  exception to retrieve the problematic string." }, 
      { "value": 
          { "name": "Ulexing.lexeme_start",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/ulexing.mli|4407" },
            "info": 
              { "description": "<span class=\"code\" >Ulexing.lexeme_start lexbuf</span> returns the offset in the input stream of the first code point of the matched string. The first code point of the stream has offset 0." },
            "type": "Ulexing.lexbuf -> int",
            "params": [ 
              { "name": "",
                "type": "Ulexing.lexbuf" } ] } }, 
      { "value": 
          { "name": "Ulexing.lexeme_end",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/ulexing.mli|4622" },
            "info": 
              { "description": "<span class=\"code\" >Ulexing.lexeme_end lexbuf</span> returns the offset in the input stream of the character following the last code point of the matched string. The first character of the stream has offset 0." },
            "type": "Ulexing.lexbuf -> int",
            "params": [ 
              { "name": "",
                "type": "Ulexing.lexbuf" } ] } }, 
      { "value": 
          { "name": "Ulexing.loc",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/ulexing.mli|4851" },
            "info": 
              { "description": "<span class=\"code\" >Ulexing.loc lexbuf</span> returns the pair  <span class=\"code\" >(Ulexing.lexeme_start lexbuf,Ulexing.lexeme_end lexbuf)</span>." },
            "type": "Ulexing.lexbuf -> int * int",
            "params": [ 
              { "name": "",
                "type": "Ulexing.lexbuf" } ] } }, 
      { "value": 
          { "name": "Ulexing.lexeme_length",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/ulexing.mli|4988" },
            "info": 
              { "description": "<span class=\"code\" >Ulexing.loc lexbuf</span> returns the difference  <span class=\"code\" >(Ulexing.lexeme_end lexbuf) - (Ulexing.lexeme_start lexbuf)</span>, that is, the length (in code points) of the matched string." },
            "type": "Ulexing.lexbuf -> int",
            "params": [ 
              { "name": "",
                "type": "Ulexing.lexbuf" } ] } }, 
      { "value": 
          { "name": "Ulexing.lexeme",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/ulexing.mli|5201" },
            "info": 
              { "description": "<span class=\"code\" >Ulexing.lexeme lexbuf</span> returns the string matched by the regular expression as an array of Unicode code point." },
            "type": "Ulexing.lexbuf -> int array",
            "params": [ 
              { "name": "",
                "type": "Ulexing.lexbuf" } ] } }, 
      { "value": 
          { "name": "Ulexing.get_buf",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/ulexing.mli|5355" },
            "info": 
              { "description": "Direct access to the internal buffer." },
            "type": "Ulexing.lexbuf -> int array",
            "params": [ 
              { "name": "",
                "type": "Ulexing.lexbuf" } ] } }, 
      { "value": 
          { "name": "Ulexing.get_start",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/ulexing.mli|5435" },
            "info": 
              { "description": "Direct access to the starting position of the lexeme in the internal buffer." },
            "type": "Ulexing.lexbuf -> int",
            "params": [ 
              { "name": "",
                "type": "Ulexing.lexbuf" } ] } }, 
      { "value": 
          { "name": "Ulexing.get_pos",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/ulexing.mli|5556" },
            "info": 
              { "description": "Direct access to the current position (end of lexeme) in the internal buffer." },
            "type": "Ulexing.lexbuf -> int",
            "params": [ 
              { "name": "",
                "type": "Ulexing.lexbuf" } ] } }, 
      { "value": 
          { "name": "Ulexing.lexeme_char",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/ulexing.mli|5677" },
            "info": 
              { "description": "<span class=\"code\" >Ulexing.lexeme_char lexbuf pos</span> returns code point number <span class=\"code\" >pos</span> in the matched string." },
            "type": "Ulexing.lexbuf -> int -> int",
            "params": [ 
              { "name": "",
                "type": "Ulexing.lexbuf" }, 
              { "name": "",
                "type": "int" } ] } }, 
      { "value": 
          { "name": "Ulexing.sub_lexeme",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/ulexing.mli|5819" },
            "info": 
              { "description": "<span class=\"code\" >Ulexing.lexeme lexbuf pos len</span> returns a substring of the string matched by the regular expression as an array of Unicode code point." },
            "type": "Ulexing.lexbuf -> int -> int -> int array",
            "params": [ 
              { "name": "",
                "type": "Ulexing.lexbuf" }, 
              { "name": "",
                "type": "int" }, 
              { "name": "",
                "type": "int" } ] } }, 
      { "value": 
          { "name": "Ulexing.latin1_lexeme",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/ulexing.mli|6015" },
            "info": 
              { "description": "As <span class=\"code\" >Ulexing.lexeme</span> with a result encoded in Latin1. This function throws an exception <span class=\"code\" >InvalidCodepoint</span> if it is not possible to encode the result in Latin1." },
            "type": "Ulexing.lexbuf -> string",
            "params": [ 
              { "name": "",
                "type": "Ulexing.lexbuf" } ] } }, 
      { "value": 
          { "name": "Ulexing.latin1_sub_lexeme",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/ulexing.mli|6223" },
            "info": 
              { "description": "As <span class=\"code\" >Ulexing.sub_lexeme</span> with a result encoded in Latin1. This function throws an exception <span class=\"code\" >InvalidCodepoint</span> if it is not possible to encode the result in Latin1." },
            "type": "Ulexing.lexbuf -> int -> int -> string",
            "params": [ 
              { "name": "",
                "type": "Ulexing.lexbuf" }, 
              { "name": "",
                "type": "int" }, 
              { "name": "",
                "type": "int" } ] } }, 
      { "value": 
          { "name": "Ulexing.latin1_lexeme_char",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/ulexing.mli|6453" },
            "info": 
              { "description": "As <span class=\"code\" >Ulexing.lexeme_char</span> with a result encoded in Latin1. This function throws an exception <span class=\"code\" >InvalidCodepoint</span> if it is not possible to encode the result in Latin1." },
            "type": "Ulexing.lexbuf -> int -> char",
            "params": [ 
              { "name": "",
                "type": "Ulexing.lexbuf" }, 
              { "name": "",
                "type": "int" } ] } }, 
      { "value": 
          { "name": "Ulexing.utf8_lexeme",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/ulexing.mli|6678" },
            "info": 
              { "description": "As <span class=\"code\" >Ulexing.lexeme</span> with a result encoded in UTF-8." },
            "type": "Ulexing.lexbuf -> string",
            "params": [ 
              { "name": "",
                "type": "Ulexing.lexbuf" } ] } }, 
      { "value": 
          { "name": "Ulexing.utf8_sub_lexeme",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/ulexing.mli|6772" },
            "info": 
              { "description": "As <span class=\"code\" >Ulexing.sub_lexeme</span> with a result encoded in UTF-8." },
            "type": "Ulexing.lexbuf -> int -> int -> string",
            "params": [ 
              { "name": "",
                "type": "Ulexing.lexbuf" }, 
              { "name": "",
                "type": "int" }, 
              { "name": "",
                "type": "int" } ] } }, 
      { "value": 
          { "name": "Ulexing.rollback",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/ulexing.mli|6889" },
            "info": 
              { "description": "<span class=\"code\" >Ulexing.rollback lexbuf</span> puts <span class=\"code\" >lexbuf</span> back in its configuration before the last lexeme was matched. It is then possible to use another lexer to parse the same characters again. The other functions above in this section should not be used in the semantic action after a call to <span class=\"code\" >Ulexing.rollback</span>." },
            "type": "Ulexing.lexbuf -> unit",
            "params": [ 
              { "name": "",
                "type": "Ulexing.lexbuf" } ] } }, 
      { "comment": "<h6>Internal interface</h6>" }, 
      { "comment": "These functions are used internally by the lexers. They could be used to write lexers by hand, or with a lexer generator different from <span class=\"code\" >ulex</span>. The lexer buffers have a unique internal slot that can store an integer. They also store a \"backtrack\" position." }, 
      { "value": 
          { "name": "Ulexing.start",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/ulexing.mli|7535" },
            "info": 
              { "description": "<span class=\"code\" >Ulexing.start lexbuf</span> informs the lexer buffer that any code points until the current position can be discarded. The current position become the \"start\" position as returned by <span class=\"code\" >Ulexing.lexeme_start</span>. Moreover, the internal slot is set to <span class=\"code\" >-1</span> and the backtrack position is set to the current position." },
            "type": "Ulexing.lexbuf -> unit",
            "params": [ 
              { "name": "",
                "type": "Ulexing.lexbuf" } ] } }, 
      { "value": 
          { "name": "Ulexing.next",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/ulexing.mli|7881" },
            "info": 
              { "description": "<span class=\"code\" >Ulexing.next lexbuf next</span> extracts the next code point from the lexer buffer and increments to current position. If the input stream is exhausted, the function returns <span class=\"code\" >-1</span>." },
            "type": "Ulexing.lexbuf -> int",
            "params": [ 
              { "name": "",
                "type": "Ulexing.lexbuf" } ] } }, 
      { "value": 
          { "name": "Ulexing.mark",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/ulexing.mli|8092" },
            "info": 
              { "description": "<span class=\"code\" >Ulexing.mark lexbuf i</span> stores the integer <span class=\"code\" >i</span> in the internal slot. The backtrack position is set to the current position." },
            "type": "Ulexing.lexbuf -> int -> unit",
            "params": [ 
              { "name": "",
                "type": "Ulexing.lexbuf" }, 
              { "name": "",
                "type": "int" } ] } }, 
      { "value": 
          { "name": "Ulexing.backtrack",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/ulexing.mli|8258" },
            "info": 
              { "description": "<span class=\"code\" >Ulexing.backtrack lexbuf</span> returns the value stored in the internal slot of the buffer, and performs backtracking (the current position is set to the value of the backtrack position)." },
            "type": "Ulexing.lexbuf -> int",
            "params": [ 
              { "name": "",
                "type": "Ulexing.lexbuf" } ] } } ],
    "dependencies": 
      { "uses": [ "Stream" ],
        "used_by": [ "Utf16" ] } } }