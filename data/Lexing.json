{ "module": 
  { "name": "Lexing",
    "file": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/lexing.mli",
    "location": 
      { "implementation": "unknown",
        "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/lexing.mli|0" },
    "info": 
      { "description": "The run-time library for lexers generated by <span class=\"code\" >ocamllex</span>." },
    "type": "sig  end",
    "module_structure": [ 
      { "comment": "<h6>Positions</h6>" }, 
      { "type": 
          { "name": "Lexing.position",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/lexing.mli|1041" },
            "info": 
              { "description": "A value of type <span class=\"code\" >position</span> describes a point in a source file. <span class=\"code\" >pos_fname</span> is the file name; <span class=\"code\" >pos_lnum</span> is the line number; <span class=\"code\" >pos_bol</span> is the offset of the beginning of the line (number of characters between the beginning of the file and the beginning of the line); <span class=\"code\" >pos_cnum</span> is the offset of the position (number of characters between the beginning of the file and the position).<br></br> See the documentation of type <span class=\"code\" >lexbuf</span> for information about how the lexing engine will manage positions." },
            "params": [  ],
            "kind": 
              { "type": "record",
                "private": "false",
                "fields": [ 
                  { "name": "pos_fname",
                    "mutable": false,
                    "type": "string" }, 
                  { "name": "pos_lnum",
                    "mutable": false,
                    "type": "int" }, 
                  { "name": "pos_bol",
                    "mutable": false,
                    "type": "int" }, 
                  { "name": "pos_cnum",
                    "mutable": false,
                    "type": "int" } ] } } }, 
      { "value": 
          { "name": "Lexing.dummy_pos",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/lexing.mli|1649" },
            "info": 
              { "description": "A value of type <span class=\"code\" >position</span>, guaranteed to be different from any valid position." },
            "type": "Lexing.position",
            "params": [  ] } }, 
      { "comment": "<h6>Lexer buffers</h6>" }, 
      { "type": 
          { "name": "Lexing.lexbuf",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/lexing.mli|1801" },
            "info": 
              { "description": "The type of lexer buffers. A lexer buffer is the argument passed to the scanning functions defined by the generated scanners. The lexer buffer holds the current state of the scanner, plus a function to refill the buffer from the input.<br></br> At each token, the lexing engine will copy <span class=\"code\" >lex_curr_p</span> to <span class=\"code\" >lex_start_p</span>, then change the <span class=\"code\" >pos_cnum</span> field of <span class=\"code\" >lex_curr_p</span> by updating it with the number of characters read since the start of the <span class=\"code\" >lexbuf</span>.  The other fields are left unchanged by the lexing engine.  In order to keep them accurate, they must be initialised before the first use of the lexbuf, and updated by the relevant lexer actions (i.e. at each end of line -- see also <span class=\"code\" >new_line</span>)." },
            "params": [  ],
            "kind": 
              { "type": "record",
                "private": "false",
                "fields": [ 
                  { "name": "refill_buff",
                    "mutable": false,
                    "type": "Lexing.lexbuf -> unit" }, 
                  { "name": "lex_buffer",
                    "mutable": true,
                    "type": "string" }, 
                  { "name": "lex_buffer_len",
                    "mutable": true,
                    "type": "int" }, 
                  { "name": "lex_abs_pos",
                    "mutable": true,
                    "type": "int" }, 
                  { "name": "lex_start_pos",
                    "mutable": true,
                    "type": "int" }, 
                  { "name": "lex_curr_pos",
                    "mutable": true,
                    "type": "int" }, 
                  { "name": "lex_last_pos",
                    "mutable": true,
                    "type": "int" }, 
                  { "name": "lex_last_action",
                    "mutable": true,
                    "type": "int" }, 
                  { "name": "lex_eof_reached",
                    "mutable": true,
                    "type": "bool" }, 
                  { "name": "lex_mem",
                    "mutable": true,
                    "type": "int array" }, 
                  { "name": "lex_start_p",
                    "mutable": true,
                    "type": "Lexing.position" }, 
                  { "name": "lex_curr_p",
                    "mutable": true,
                    "type": "Lexing.position" } ] } } }, 
      { "value": 
          { "name": "Lexing.from_string",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/lexing.mli|2949" },
            "info": 
              { "description": "Create a lexer buffer which reads from the given string. Reading starts from the first character in the string. An end-of-input condition is generated when the end of the string is reached." },
            "type": "string -> Lexing.lexbuf",
            "params": [ 
              { "name": "",
                "type": "string" } ] } }, 
      { "value": 
          { "name": "Lexing.from_function",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/lexing.mli|3191" },
            "info": 
              { "description": "Create a lexer buffer with the given function as its reading method. When the scanner needs more characters, it will call the given function, giving it a character string <span class=\"code\" >s</span> and a character count <span class=\"code\" >n</span>. The function should put <span class=\"code\" >n</span> characters or less in <span class=\"code\" >s</span>, starting at character number 0, and return the number of characters provided. A return value of 0 means end of input." },
            "type": "(string -> int -> int) -> Lexing.lexbuf",
            "params": [ 
              { "name": "",
                "type": "string -> int -> int" } ] } }, 
      { "comment": "<h6>Functions for lexer semantic actions</h6>" }, 
      { "comment": "The following functions can be called from the semantic actions of lexer definitions (the ML code enclosed in braces that computes the value returned by lexing functions). They give access to the character string matched by the regular expression associated with the semantic action. These functions must be applied to the argument <span class=\"code\" >lexbuf</span>, which, in the code generated by <span class=\"code\" >ocamllex</span>, is bound to the lexer buffer passed to the parsing function." }, 
      { "value": 
          { "name": "Lexing.lexeme",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/lexing.mli|4169" },
            "info": 
              { "description": "<span class=\"code\" >Lexing.lexeme lexbuf</span> returns the string matched by the regular expression." },
            "type": "Lexing.lexbuf -> string",
            "params": [ 
              { "name": "",
                "type": "Lexing.lexbuf" } ] } }, 
      { "value": 
          { "name": "Lexing.lexeme_char",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/lexing.mli|4295" },
            "info": 
              { "description": "<span class=\"code\" >Lexing.lexeme_char lexbuf i</span> returns character number <span class=\"code\" >i</span> in the matched string." },
            "type": "Lexing.lexbuf -> int -> char",
            "params": [ 
              { "name": "",
                "type": "Lexing.lexbuf" }, 
              { "name": "",
                "type": "int" } ] } }, 
      { "value": 
          { "name": "Lexing.lexeme_start",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/lexing.mli|4428" },
            "info": 
              { "description": "<span class=\"code\" >Lexing.lexeme_start lexbuf</span> returns the offset in the input stream of the first character of the matched string. The first character of the stream has offset 0." },
            "type": "Lexing.lexbuf -> int",
            "params": [ 
              { "name": "",
                "type": "Lexing.lexbuf" } ] } }, 
      { "value": 
          { "name": "Lexing.lexeme_end",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/lexing.mli|4637" },
            "info": 
              { "description": "<span class=\"code\" >Lexing.lexeme_end lexbuf</span> returns the offset in the input stream of the character following the last character of the matched string. The first character of the stream has offset 0." },
            "type": "Lexing.lexbuf -> int",
            "params": [ 
              { "name": "",
                "type": "Lexing.lexbuf" } ] } }, 
      { "value": 
          { "name": "Lexing.lexeme_start_p",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/lexing.mli|4865" },
            "info": 
              { "description": "Like <span class=\"code\" >lexeme_start</span>, but return a complete <span class=\"code\" >position</span> instead of an offset." },
            "type": "Lexing.lexbuf -> Lexing.position",
            "params": [ 
              { "name": "",
                "type": "Lexing.lexbuf" } ] } }, 
      { "value": 
          { "name": "Lexing.lexeme_end_p",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/lexing.mli|4993" },
            "info": 
              { "description": "Like <span class=\"code\" >lexeme_end</span>, but return a complete <span class=\"code\" >position</span> instead of an offset." },
            "type": "Lexing.lexbuf -> Lexing.position",
            "params": [ 
              { "name": "",
                "type": "Lexing.lexbuf" } ] } }, 
      { "value": 
          { "name": "Lexing.new_line",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/lexing.mli|5117" },
            "info": 
              { "description": "Update the <span class=\"code\" >lex_curr_p</span> field of the lexbuf to reflect the start of a new line.  You can call this function in the semantic action of the rule that matches the end-of-line character.",
                "since": "3.11.0" },
            "type": "Lexing.lexbuf -> unit",
            "params": [ 
              { "name": "",
                "type": "Lexing.lexbuf" } ] } }, 
      { "comment": "<h6>Miscellaneous functions</h6>" }, 
      { "value": 
          { "name": "Lexing.flush_input",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/lexing.mli|5400" },
            "info": 
              { "description": "Discard the contents of the buffer and reset the current position to 0.  The next use of the lexbuf will trigger a refill." },
            "type": "Lexing.lexbuf -> unit",
            "params": [ 
              { "name": "",
                "type": "Lexing.lexbuf" } ] } } ],
    "dependencies": 
      { "uses": [  ],
        "used_by": [ "Parsing", "Dns" ] } } }