{ "module": 
  { "name": "List",
    "file": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/list.mli",
    "location": 
      { "implementation": "unknown",
        "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/list.mli|0" },
    "info": 
      { "description": "List operations.<br></br> Some functions are flagged as not tail-recursive.  A tail-recursive function uses constant stack space, while a non-tail-recursive function uses stack space proportional to the length of its list argument, which can be a problem with very long lists.  When the function takes several list arguments, an approximate formula giving stack usage (in some unspecified constant unit) is shown in parentheses.<br></br> The above considerations can usually be ignored if your lists are not longer than about 10000 elements." },
    "type": "sig  end",
    "module_structure": [ 
      { "value": 
          { "name": "List.length",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/list.mli|1504" },
            "info": 
              { "description": "Return the length (number of elements) of the given list." },
            "type": "'a list -> int",
            "params": [ 
              { "name": "",
                "type": "'a list" } ] } }, 
      { "value": 
          { "name": "List.hd",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/list.mli|1598" },
            "info": 
              { "description": "Return the first element of the given list. Raise <span class=\"code\" >Failure \"hd\"</span> if the list is empty." },
            "type": "'a list -> 'a",
            "params": [ 
              { "name": "",
                "type": "'a list" } ] } }, 
      { "value": 
          { "name": "List.tl",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/list.mli|1719" },
            "info": 
              { "description": "Return the given list without its first element. Raise <span class=\"code\" >Failure \"tl\"</span> if the list is empty." },
            "type": "'a list -> 'a list",
            "params": [ 
              { "name": "",
                "type": "'a list" } ] } }, 
      { "value": 
          { "name": "List.nth",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/list.mli|1850" },
            "info": 
              { "description": "Return the <span class=\"code\" >n</span>-th element of the given list. The first element (head of the list) is at position 0. Raise <span class=\"code\" >Failure \"nth\"</span> if the list is too short. Raise <span class=\"code\" >Invalid_argument \"List.nth\"</span> if <span class=\"code\" >n</span> is negative." },
            "type": "'a list -> int -> 'a",
            "params": [ 
              { "name": "",
                "type": "'a list" }, 
              { "name": "",
                "type": "int" } ] } }, 
      { "value": 
          { "name": "List.rev",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/list.mli|2102" },
            "info": 
              { "description": "List reversal." },
            "type": "'a list -> 'a list",
            "params": [ 
              { "name": "",
                "type": "'a list" } ] } }, 
      { "value": 
          { "name": "List.append",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/list.mli|2154" },
            "info": 
              { "description": "Catenate two lists.  Same function as the infix operator <span class=\"code\" >@</span>. Not tail-recursive (length of the first argument).  The <span class=\"code\" >@</span> operator is not tail-recursive either." },
            "type": "'a list -> 'a list -> 'a list",
            "params": [ 
              { "name": "",
                "type": "'a list" }, 
              { "name": "",
                "type": "'a list" } ] } }, 
      { "value": 
          { "name": "List.rev_append",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/list.mli|2372" },
            "info": 
              { "description": "<span class=\"code\" >List.rev_append l1 l2</span> reverses <span class=\"code\" >l1</span> and concatenates it to <span class=\"code\" >l2</span>. This is equivalent to <a href=\"{value|List.rev}\" ><span class=\"code\" >List.rev</span></a><span class=\"code\" > l1 @ l2</span>, but <span class=\"code\" >rev_append</span> is tail-recursive and more efficient." },
            "type": "'a list -> 'a list -> 'a list",
            "params": [ 
              { "name": "",
                "type": "'a list" }, 
              { "name": "",
                "type": "'a list" } ] } }, 
      { "value": 
          { "name": "List.concat",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/list.mli|2600" },
            "info": 
              { "description": "Concatenate a list of lists.  The elements of the argument are all concatenated together (in the same order) to give the result. Not tail-recursive (length of the argument + length of the longest sub-list)." },
            "type": "'a list list -> 'a list",
            "params": [ 
              { "name": "",
                "type": "'a list list" } ] } }, 
      { "value": 
          { "name": "List.flatten",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/list.mli|2861" },
            "info": 
              { "description": "Same as <span class=\"code\" >concat</span>.  Not tail-recursive (length of the argument + length of the longest sub-list)." },
            "type": "'a list list -> 'a list",
            "params": [ 
              { "name": "",
                "type": "'a list list" } ] } }, 
      { "comment": "<h6>Iterators</h6>" }, 
      { "value": 
          { "name": "List.iter",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/list.mli|3031" },
            "info": 
              { "description": "<span class=\"code\" >List.iter f [a1; ...; an]</span> applies function <span class=\"code\" >f</span> in turn to <span class=\"code\" >a1; ...; an</span>. It is equivalent to <span class=\"code\" >begin f a1; f a2; ...; f an; () end</span>." },
            "type": "('a -> unit) -> 'a list -> unit",
            "params": [ 
              { "name": "",
                "type": "'a -> unit" }, 
              { "name": "",
                "type": "'a list" } ] } }, 
      { "value": 
          { "name": "List.map",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/list.mli|3222" },
            "info": 
              { "description": "<span class=\"code\" >List.map f [a1; ...; an]</span> applies function <span class=\"code\" >f</span> to <span class=\"code\" >a1, ..., an</span>, and builds the list <span class=\"code\" >[f a1; ...; f an]</span> with the results returned by <span class=\"code\" >f</span>.  Not tail-recursive." },
            "type": "('a -> 'b) -> 'a list -> 'b list",
            "params": [ 
              { "name": "",
                "type": "'a -> 'b" }, 
              { "name": "",
                "type": "'a list" } ] } }, 
      { "value": 
          { "name": "List.rev_map",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/list.mli|3440" },
            "info": 
              { "description": "<span class=\"code\" >List.rev_map f l</span> gives the same result as <a href=\"{value|List.rev}\" ><span class=\"code\" >List.rev</span></a><span class=\"code\" > (</span><a href=\"{value|List.map}\" ><span class=\"code\" >List.map</span></a><span class=\"code\" > f l)</span>, but is tail-recursive and more efficient." },
            "type": "('a -> 'b) -> 'a list -> 'b list",
            "params": [ 
              { "name": "",
                "type": "'a -> 'b" }, 
              { "name": "",
                "type": "'a list" } ] } }, 
      { "value": 
          { "name": "List.fold_left",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/list.mli|3622" },
            "info": 
              { "description": "<span class=\"code\" >List.fold_left f a [b1; ...; bn]</span> is <span class=\"code\" >f (... (f (f a b1) b2) ...) bn</span>." },
            "type": "('a -> 'b -> 'a) -> 'a -> 'b list -> 'a",
            "params": [ 
              { "name": "",
                "type": "'a -> 'b -> 'a" }, 
              { "name": "",
                "type": "'a" }, 
              { "name": "",
                "type": "'a list" } ] } }, 
      { "value": 
          { "name": "List.fold_right",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/list.mli|3761" },
            "info": 
              { "description": "<span class=\"code\" >List.fold_right f [a1; ...; an] b</span> is <span class=\"code\" >f a1 (f a2 (... (f an b) ...))</span>.  Not tail-recursive." },
            "type": "('a -> 'b -> 'b) -> 'a list -> 'b -> 'b",
            "params": [ 
              { "name": "",
                "type": "'a -> 'b -> 'b" }, 
              { "name": "",
                "type": "'a list" }, 
              { "name": "",
                "type": "'a" } ] } }, 
      { "comment": "<h6>Iterators on two lists</h6>" }, 
      { "value": 
          { "name": "List.iter2",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/list.mli|3960" },
            "info": 
              { "description": "<span class=\"code\" >List.iter2 f [a1; ...; an] [b1; ...; bn]</span> calls in turn <span class=\"code\" >f a1 b1; ...; f an bn</span>. Raise <span class=\"code\" >Invalid_argument</span> if the two lists have different lengths." },
            "type": "('a -> 'b -> unit) -> 'a list -> 'b list -> unit",
            "params": [ 
              { "name": "",
                "type": "'a -> 'b -> unit" }, 
              { "name": "",
                "type": "'a list" }, 
              { "name": "",
                "type": "'a list" } ] } }, 
      { "value": 
          { "name": "List.map2",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/list.mli|4186" },
            "info": 
              { "description": "<span class=\"code\" >List.map2 f [a1; ...; an] [b1; ...; bn]</span> is <span class=\"code\" >[f a1 b1; ...; f an bn]</span>. Raise <span class=\"code\" >Invalid_argument</span> if the two lists have different lengths.  Not tail-recursive." },
            "type": "('a -> 'b -> 'c) -> 'a list -> 'b list -> 'c list",
            "params": [ 
              { "name": "",
                "type": "'a -> 'b -> 'c" }, 
              { "name": "",
                "type": "'a list" }, 
              { "name": "",
                "type": "'a list" } ] } }, 
      { "value": 
          { "name": "List.rev_map2",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/list.mli|4423" },
            "info": 
              { "description": "<span class=\"code\" >List.rev_map2 f l1 l2</span> gives the same result as <a href=\"{value|List.rev}\" ><span class=\"code\" >List.rev</span></a><span class=\"code\" > (</span><a href=\"{value|List.map2}\" ><span class=\"code\" >List.map2</span></a><span class=\"code\" > f l1 l2)</span>, but is tail-recursive and more efficient." },
            "type": "('a -> 'b -> 'c) -> 'a list -> 'b list -> 'c list",
            "params": [ 
              { "name": "",
                "type": "'a -> 'b -> 'c" }, 
              { "name": "",
                "type": "'a list" }, 
              { "name": "",
                "type": "'a list" } ] } }, 
      { "value": 
          { "name": "List.fold_left2",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/list.mli|4633" },
            "info": 
              { "description": "<span class=\"code\" >List.fold_left2 f a [b1; ...; bn] [c1; ...; cn]</span> is <span class=\"code\" >f (... (f (f a b1 c1) b2 c2) ...) bn cn</span>. Raise <span class=\"code\" >Invalid_argument</span> if the two lists have different lengths." },
            "type": "('a -> 'b -> 'c -> 'a) -> 'a -> 'b list -> 'c list -> 'a",
            "params": [ 
              { "name": "",
                "type": "'a -> 'b -> 'c -> 'a" }, 
              { "name": "",
                "type": "'a" }, 
              { "name": "",
                "type": "'a list" }, 
              { "name": "",
                "type": "'a list" } ] } }, 
      { "value": 
          { "name": "List.fold_right2",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/list.mli|4886" },
            "info": 
              { "description": "<span class=\"code\" >List.fold_right2 f [a1; ...; an] [b1; ...; bn] c</span> is <span class=\"code\" >f a1 b1 (f a2 b2 (... (f an bn c) ...))</span>. Raise <span class=\"code\" >Invalid_argument</span> if the two lists have different lengths.  Not tail-recursive." },
            "type": "('a -> 'b -> 'c -> 'c) -> 'a list -> 'b list -> 'c -> 'c",
            "params": [ 
              { "name": "",
                "type": "'a -> 'b -> 'c -> 'c" }, 
              { "name": "",
                "type": "'a list" }, 
              { "name": "",
                "type": "'a list" }, 
              { "name": "",
                "type": "'a" } ] } }, 
      { "comment": "<h6>List scanning</h6>" }, 
      { "value": 
          { "name": "List.for_all",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/list.mli|5190" },
            "info": 
              { "description": "<span class=\"code\" >for_all p [a1; ...; an]</span> checks if all elements of the list satisfy the predicate <span class=\"code\" >p</span>. That is, it returns <span class=\"code\" >(p a1) &amp;&amp; (p a2) &amp;&amp; ... &amp;&amp; (p an)</span>." },
            "type": "('a -> bool) -> 'a list -> bool",
            "params": [ 
              { "name": "",
                "type": "'a -> bool" }, 
              { "name": "",
                "type": "'a list" } ] } }, 
      { "value": 
          { "name": "List.exists",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/list.mli|5395" },
            "info": 
              { "description": "<span class=\"code\" >exists p [a1; ...; an]</span> checks if at least one element of the list satisfies the predicate <span class=\"code\" >p</span>. That is, it returns <span class=\"code\" >(p a1) || (p a2) || ... || (p an)</span>." },
            "type": "('a -> bool) -> 'a list -> bool",
            "params": [ 
              { "name": "",
                "type": "'a -> bool" }, 
              { "name": "",
                "type": "'a list" } ] } }, 
      { "value": 
          { "name": "List.for_all2",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/list.mli|5608" },
            "info": 
              { "description": "Same as <a href=\"{value|List.for_all}\" ><span class=\"code\" >List.for_all</span></a>, but for a two-argument predicate. Raise <span class=\"code\" >Invalid_argument</span> if the two lists have different lengths." },
            "type": "('a -> 'b -> bool) -> 'a list -> 'b list -> bool",
            "params": [ 
              { "name": "",
                "type": "'a -> 'b -> bool" }, 
              { "name": "",
                "type": "'a list" }, 
              { "name": "",
                "type": "'a list" } ] } }, 
      { "value": 
          { "name": "List.exists2",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/list.mli|5811" },
            "info": 
              { "description": "Same as <a href=\"{value|List.exists}\" ><span class=\"code\" >List.exists</span></a>, but for a two-argument predicate. Raise <span class=\"code\" >Invalid_argument</span> if the two lists have different lengths." },
            "type": "('a -> 'b -> bool) -> 'a list -> 'b list -> bool",
            "params": [ 
              { "name": "",
                "type": "'a -> 'b -> bool" }, 
              { "name": "",
                "type": "'a list" }, 
              { "name": "",
                "type": "'a list" } ] } }, 
      { "value": 
          { "name": "List.mem",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/list.mli|6012" },
            "info": 
              { "description": "<span class=\"code\" >mem a l</span> is true if and only if <span class=\"code\" >a</span> is equal to an element of <span class=\"code\" >l</span>." },
            "type": "'a -> 'a list -> bool",
            "params": [ 
              { "name": "",
                "type": "'a" }, 
              { "name": "",
                "type": "'a list" } ] } }, 
      { "value": 
          { "name": "List.memq",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/list.mli|6123" },
            "info": 
              { "description": "Same as <a href=\"{value|List.mem}\" ><span class=\"code\" >List.mem</span></a>, but uses physical equality instead of structural equality to compare list elements." },
            "type": "'a -> 'a list -> bool",
            "params": [ 
              { "name": "",
                "type": "'a" }, 
              { "name": "",
                "type": "'a list" } ] } }, 
      { "comment": "<h6>List searching</h6>" }, 
      { "value": 
          { "name": "List.find",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/list.mli|6301" },
            "info": 
              { "description": "<span class=\"code\" >find p l</span> returns the first element of the list <span class=\"code\" >l</span> that satisfies the predicate <span class=\"code\" >p</span>. Raise <span class=\"code\" >Not_found</span> if there is no value that satisfies <span class=\"code\" >p</span> in the list <span class=\"code\" >l</span>." },
            "type": "('a -> bool) -> 'a list -> 'a",
            "params": [ 
              { "name": "",
                "type": "'a -> bool" }, 
              { "name": "",
                "type": "'a list" } ] } }, 
      { "value": 
          { "name": "List.filter",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/list.mli|6521" },
            "info": 
              { "description": "<span class=\"code\" >filter p l</span> returns all the elements of the list <span class=\"code\" >l</span> that satisfy the predicate <span class=\"code\" >p</span>.  The order of the elements in the input list is preserved." },
            "type": "('a -> bool) -> 'a list -> 'a list",
            "params": [ 
              { "name": "",
                "type": "'a -> bool" }, 
              { "name": "",
                "type": "'a list" } ] } }, 
      { "value": 
          { "name": "List.find_all",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/list.mli|6729" },
            "info": 
              { "description": "<span class=\"code\" >find_all</span> is another name for <a href=\"{value|List.filter}\" ><span class=\"code\" >List.filter</span></a>." },
            "type": "('a -> bool) -> 'a list -> 'a list",
            "params": [ 
              { "name": "",
                "type": "'a -> bool" }, 
              { "name": "",
                "type": "'a list" } ] } }, 
      { "value": 
          { "name": "List.partition",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/list.mli|6834" },
            "info": 
              { "description": "<span class=\"code\" >partition p l</span> returns a pair of lists <span class=\"code\" >(l1, l2)</span>, where <span class=\"code\" >l1</span> is the list of all the elements of <span class=\"code\" >l</span> that satisfy the predicate <span class=\"code\" >p</span>, and <span class=\"code\" >l2</span> is the list of all the elements of <span class=\"code\" >l</span> that do not satisfy <span class=\"code\" >p</span>. The order of the elements in the input list is preserved." },
            "type": "('a -> bool) -> 'a list -> 'a list * 'a list",
            "params": [ 
              { "name": "",
                "type": "'a -> bool" }, 
              { "name": "",
                "type": "'a list" } ] } }, 
      { "comment": "<h6>Association lists</h6>" }, 
      { "value": 
          { "name": "List.assoc",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/list.mli|7212" },
            "info": 
              { "description": "<span class=\"code\" >assoc a l</span> returns the value associated with key <span class=\"code\" >a</span> in the list of pairs <span class=\"code\" >l</span>. That is, <span class=\"code\" >assoc a [ ...; (a,b); ...] = b</span> if <span class=\"code\" >(a,b)</span> is the leftmost binding of <span class=\"code\" >a</span> in list <span class=\"code\" >l</span>. Raise <span class=\"code\" >Not_found</span> if there is no value associated with <span class=\"code\" >a</span> in the list <span class=\"code\" >l</span>." },
            "type": "'a -> ('a * 'b) list -> 'b",
            "params": [ 
              { "name": "",
                "type": "'a" }, 
              { "name": "",
                "type": "('a * 'b) list" } ] } }, 
      { "value": 
          { "name": "List.assq",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/list.mli|7527" },
            "info": 
              { "description": "Same as <a href=\"{value|List.assoc}\" ><span class=\"code\" >List.assoc</span></a>, but uses physical equality instead of structural equality to compare keys." },
            "type": "'a -> ('a * 'b) list -> 'b",
            "params": [ 
              { "name": "",
                "type": "'a" }, 
              { "name": "",
                "type": "('a * 'b) list" } ] } }, 
      { "value": 
          { "name": "List.mem_assoc",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/list.mli|7674" },
            "info": 
              { "description": "Same as <a href=\"{value|List.assoc}\" ><span class=\"code\" >List.assoc</span></a>, but simply return true if a binding exists, and false if no bindings exist for the given key." },
            "type": "'a -> ('a * 'b) list -> bool",
            "params": [ 
              { "name": "",
                "type": "'a" }, 
              { "name": "",
                "type": "('a * 'b) list" } ] } }, 
      { "value": 
          { "name": "List.mem_assq",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/list.mli|7847" },
            "info": 
              { "description": "Same as <a href=\"{value|List.mem_assoc}\" ><span class=\"code\" >List.mem_assoc</span></a>, but uses physical equality instead of structural equality to compare keys." },
            "type": "'a -> ('a * 'b) list -> bool",
            "params": [ 
              { "name": "",
                "type": "'a" }, 
              { "name": "",
                "type": "('a * 'b) list" } ] } }, 
      { "value": 
          { "name": "List.remove_assoc",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/list.mli|8004" },
            "info": 
              { "description": "<span class=\"code\" >remove_assoc a l</span> returns the list of pairs <span class=\"code\" >l</span> without the first pair with key <span class=\"code\" >a</span>, if any. Not tail-recursive." },
            "type": "'a -> ('a * 'b) list -> ('a * 'b) list",
            "params": [ 
              { "name": "",
                "type": "'a" }, 
              { "name": "",
                "type": "('a * 'b) list" } ] } }, 
      { "value": 
          { "name": "List.remove_assq",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/list.mli|8190" },
            "info": 
              { "description": "Same as <a href=\"{value|List.remove_assoc}\" ><span class=\"code\" >List.remove_assoc</span></a>, but uses physical equality instead of structural equality to compare keys.  Not tail-recursive." },
            "type": "'a -> ('a * 'b) list -> ('a * 'b) list",
            "params": [ 
              { "name": "",
                "type": "'a" }, 
              { "name": "",
                "type": "('a * 'b) list" } ] } }, 
      { "comment": "<h6>Lists of pairs</h6>" }, 
      { "value": 
          { "name": "List.split",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/list.mli|8413" },
            "info": 
              { "description": "Transform a list of pairs into a pair of lists: <span class=\"code\" >split [(a1,b1); ...; (an,bn)]</span> is <span class=\"code\" >([a1; ...; an], [b1; ...; bn])</span>. Not tail-recursive." },
            "type": "('a * 'b) list -> 'a list * 'b list",
            "params": [ 
              { "name": "",
                "type": "('a * 'b) list" } ] } }, 
      { "value": 
          { "name": "List.combine",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/list.mli|8612" },
            "info": 
              { "description": "Transform a pair of lists into a list of pairs: <span class=\"code\" >combine [a1; ...; an] [b1; ...; bn]</span> is <span class=\"code\" >[(a1,b1); ...; (an,bn)]</span>. Raise <span class=\"code\" >Invalid_argument</span> if the two lists have different lengths.  Not tail-recursive." },
            "type": "'a list -> 'b list -> ('a * 'b) list",
            "params": [ 
              { "name": "",
                "type": "'a list" }, 
              { "name": "",
                "type": "'a list" } ] } }, 
      { "comment": "<h6>Sorting</h6>" }, 
      { "value": 
          { "name": "List.sort",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/list.mli|8908" },
            "info": 
              { "description": "Sort a list in increasing order according to a comparison function.  The comparison function must return 0 if its arguments compare as equal, a positive integer if the first is greater, and a negative integer if the first is smaller (see Array.sort for a complete specification).  For example, <a href=\"{value|Pervasives.compare}\" ><span class=\"code\" >Pervasives.compare</span></a> is a suitable comparison function. The resulting list is sorted in increasing order. <span class=\"code\" >List.sort</span> is guaranteed to run in constant heap space (in addition to the size of the result list) and logarithmic stack space.<br></br> The current implementation uses Merge Sort. It runs in constant heap space and logarithmic stack space." },
            "type": "('a -> 'a -> int) -> 'a list -> 'a list",
            "params": [ 
              { "name": "",
                "type": "'a -> 'a -> int" }, 
              { "name": "",
                "type": "'a list" } ] } }, 
      { "value": 
          { "name": "List.stable_sort",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/list.mli|9636" },
            "info": 
              { "description": "Same as <a href=\"{value|List.sort}\" ><span class=\"code\" >List.sort</span></a>, but the sorting algorithm is guaranteed to be stable (i.e. elements that compare equal are kept in their original order) .<br></br> The current implementation uses Merge Sort. It runs in constant heap space and logarithmic stack space." },
            "type": "('a -> 'a -> int) -> 'a list -> 'a list",
            "params": [ 
              { "name": "",
                "type": "'a -> 'a -> int" }, 
              { "name": "",
                "type": "'a list" } ] } }, 
      { "value": 
          { "name": "List.fast_sort",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/list.mli|9964" },
            "info": 
              { "description": "Same as <a href=\"{value|List.sort}\" ><span class=\"code\" >List.sort</span></a> or <a href=\"{value|List.stable_sort}\" ><span class=\"code\" >List.stable_sort</span></a>, whichever is faster on typical input." },
            "type": "('a -> 'a -> int) -> 'a list -> 'a list",
            "params": [ 
              { "name": "",
                "type": "'a -> 'a -> int" }, 
              { "name": "",
                "type": "'a list" } ] } }, 
      { "value": 
          { "name": "List.merge",
            "location": 
              { "implementation": "unknown",
                "interface": "/Users/avsm/src/git/avsm/mirage/lib/_build/unix-socket/std/list.mli|10115" },
            "info": 
              { "description": "Merge two lists: Assuming that <span class=\"code\" >l1</span> and <span class=\"code\" >l2</span> are sorted according to the comparison function <span class=\"code\" >cmp</span>, <span class=\"code\" >merge cmp l1 l2</span> will return a sorted list containting all the elements of <span class=\"code\" >l1</span> and <span class=\"code\" >l2</span>. If several elements compare equal, the elements of <span class=\"code\" >l1</span> will be before the elements of <span class=\"code\" >l2</span>. Not tail-recursive (sum of the lengths of the arguments)." },
            "type": "('a -> 'a -> int) -> 'a list -> 'a list -> 'a list",
            "params": [ 
              { "name": "",
                "type": "'a -> 'a -> int" }, 
              { "name": "",
                "type": "'a list" }, 
              { "name": "",
                "type": "'a list" } ] } } ],
    "dependencies": 
      { "uses": [  ],
        "used_by": [  ] } } }